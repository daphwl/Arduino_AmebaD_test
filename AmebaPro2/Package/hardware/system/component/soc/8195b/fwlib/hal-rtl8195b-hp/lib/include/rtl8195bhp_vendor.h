/**************************************************************************//**
 * @file     rtl8195bhp_vendor.h
 * @brief    CMSIS HeaderFile
 * @version  1.0
 * @date     04. July 2017
 * @note     Generated by SVDConv V3.3.9 on Tuesday, 04.07.2017 14:22:49
 *           from File 'rtl8195b-hp-vendorns.svd',
 *           last modified on Tuesday, 04.07.2017 06:22:47
 *
 ******************************************************************************
 *
 * Copyright(c) 2007 - 2017 Realtek Corporation. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/


/** 
 * @addtogroup hs_hal_vdr Vendor Control
 * @ingroup 8195bh_hal
 * @{
 * @brief The HAL API for Vendor Control.
 */


#ifndef RTL8195BHP_VENDOR_H
#define RTL8195BHP_VENDOR_H

#ifdef __cplusplus
extern "C" {
#endif

/// @cond DOXYGEN_VDR_REG_TYPE

/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup device_vendor_reg Vendor Control Device Type
  * @ingroup hs_hal_vdr
  * @{
  */



/* =========================================================================================================================== */
/* ================                                            VDR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Vendor Register (VDR)
  */

typedef struct {                                /*!< (@ 0x40002800) VDR Structure                                              */

  union {
    __IOM uint32_t watch_dog_tmr;               /*!< (@ 0x00000000) Watch Dog Timer Register                                   */

    struct {
      __IOM uint32_t vndr_divfactor : 16;       /*!< [15..0] Dividing factor. Watch dog timer is count with 32.768KHz/(divfactor+1)
                                                     Minimum dividing factor is 1.                                             */
      __IOM uint32_t wdt_en     : 1;            /*!< [16..16] Set 1 to enable watch dog timer                                  */
      __IM  uint32_t            : 7;
      __OM  uint32_t wdt_clear  : 1;            /*!< [24..24] Write 1 to clear timer                                           */
      __IOM uint32_t cnt_limit  : 4;            /*!< [28..25] 0: 0x001 1: 0x003 2: 0x007 3: 0x00F 4: 0x01F 5: 0x03F
                                                     6: 0x07F 7: 0x0FF 8: 0x1FF 9: 0x3FF 10: 0x7FF 11~15: 0xFFF                */
      __IM  uint32_t            : 1;
      __IOM uint32_t wdt_mode   : 1;            /*!< [30..30] 1: Reset system, 0: Interrupt CPU                                */
      __IOM uint32_t wdt_to     : 1;            /*!< [31..31] Watch dog timer timeout. 1 cycle pulse                           */
    } watch_dog_tmr_b;
  } ;

  union {
    __IOM uint32_t low_pri_int_mode;            /*!< (@ 0x00000004) Low Priority Interrupt Mode Register                       */

    struct {
      __IOM uint32_t low_pri_int_mode : 32;     /*!< [31..0] Each bit control corresponding interrupt mode. 1: Rising
                                                     edge trigger 0: High level active                                         */
    } low_pri_int_mode_b;
  } ;

  union {
    __IOM uint32_t low_pri_int_imr;             /*!< (@ 0x00000008) Low Priority Interrupt Mask Register                       */

    struct {
      __IOM uint32_t low_pri_int_imr : 32;      /*!< [31..0] Each bit enable corresponding interrupt. 1: Enable 0:
                                                     Disable                                                                   */
    } low_pri_int_imr_b;
  } ;

  union {
    __IOM uint32_t low_pri_int_isr;             /*!< (@ 0x0000000C) Low Priority Interrupt Status Register                     */

    struct {
      __IOM uint32_t wdt_voe    : 1;            /*!< [0..0] watchdog reset event of VOE                                        */
      __IOM uint32_t wdt_wl     : 1;            /*!< [1..1] watchdog reset event of WL                                         */
      __IOM uint32_t bst_ocp    : 1;            /*!< [2..2] indicate BST OCP event interrupt status                            */
      __IOM uint32_t swr_ocp    : 1;            /*!< [3..3] indicate SWR_M OCP event interrupt status                          */
      __IM  uint32_t            : 5;
      __IOM uint32_t rxi_bus    : 1;            /*!< [9..9] rxi bus interrupt status                                           */
      __IM  uint32_t            : 6;
      __IOM uint32_t ddrphy_dpi_int0 : 1;       /*!< [16..16] DDR PHY DPI INT0 Status                                          */
      __IOM uint32_t ddrphy_dpi_int1 : 1;       /*!< [17..17] DDR PHY DPI INT1 Status                                          */
      __IOM uint32_t ddrphy_dpi_int2 : 1;       /*!< [18..18] DDR PHY DPI INT2 Status                                          */
      __IOM uint32_t ddrphy_dpi_int3 : 1;       /*!< [19..19] DDR PHY DPI INT3 Status                                          */
    } low_pri_int_isr_b;
  } ;
  __IM  uint32_t  RESERVED[3];

  union {
    __IOM uint32_t debug_sel;                   /*!< (@ 0x0000001C) Debug Select Register                                      */

    struct {
      __IOM uint32_t debug_sel  : 12;           /*!< [11..0] Debug selection                                                   */
    } debug_sel_b;
  } ;

  union {
    __IOM uint32_t i2c_dat_swp_ctrl;            /*!< (@ 0x00000020) I2C Data FIFO Swap Control Register                        */
    
    struct {
      __IOM uint32_t i2c0_tx_swp_en : 1;        /*!< [0..0] TX bit swap enable for I2C0                                        */
      __IOM uint32_t i2c0_rx_swp_en : 1;        /*!< [1..1] RX bit swap enable for I2C0                                        */
      __IM  uint32_t            : 2;
      __IOM uint32_t i2c2_tx_swp_en : 1;        /*!< [4..4] TX bit swap enable for I2C2                                        */
      __IOM uint32_t i2c2_rx_swp_en : 1;        /*!< [5..5] RX bit swap enable for I2C2                                        */
      __IOM uint32_t i2c3_tx_swp_en : 1;        /*!< [6..6] TX bit swap enable for I2C3                                        */
      __IOM uint32_t i2c3_rx_swp_en : 1;        /*!< [7..7] RX bit swap enable for I2C3                                        */
    } i2c_dat_swp_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t i2c_dglch_ctrl;              /*!< (@ 0x00000024) I2C Deglitch Control Register                              */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] I2C deglitch calibrator enable. 1: Enable, 0: Done/Disable         */
      __IM  uint32_t            : 7;
      __IOM uint32_t dat_p_dglch_sts : 1;       /*!< [8..8] SDA positive deglitch filter status. 0: failed, 1:success          */
      __IOM uint32_t dat_n_dglch_sts : 1;       /*!< [9..9] SDA negative deglitch filter status. 0: failed, 1:success          */
      __IOM uint32_t clk_p_dglch_sts : 1;       /*!< [10..10] SCL positive deglitch filter status. 0: failed, 1:success        */
      __IOM uint32_t clk_n_dglch_sts : 1;       /*!< [11..11] SCL negative deglitch filter status. 0: failed, 1:success        */
    } i2c_dglch_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IM  uint32_t gdma0_isr;                   /*!< (@ 0x00000030) GDMA0 ISR Register                                         */

    struct {
      __IM  uint32_t gdma0_ch0_isr : 1;         /*!< [0..0] GDMA 0 ISR for Channel 0                                           */
      __IM  uint32_t gdma0_ch1_isr : 1;         /*!< [1..1] GDMA 0 ISR for Channel 1                                           */
      __IM  uint32_t gdma0_ch2_isr : 1;         /*!< [2..2] GDMA 0 ISR for Channel 2                                           */
      __IM  uint32_t gdma0_ch3_isr : 1;         /*!< [3..3] GDMA 0 ISR for Channel 3                                           */
      __IM  uint32_t gdma0_ch4_isr : 1;         /*!< [4..4] GDMA 0 ISR for Channel 4                                           */
      __IM  uint32_t gdma0_ch5_isr : 1;         /*!< [5..5] GDMA 0 ISR for Channel 5                                           */
    } gdma0_isr_b;
  } ;

  union {
    __IM  uint32_t gdma1_isr;                   /*!< (@ 0x00000034) GDMA1 ISR Register                                         */

    struct {
      __IM  uint32_t gdma1_ch0_isr : 1;         /*!< [0..0] GDMA 1 ISR for Channel 0                                           */
      __IM  uint32_t gdma1_ch1_isr : 1;         /*!< [1..1] GDMA 1 ISR for Channel 1                                           */
      __IM  uint32_t gdma1_ch2_isr : 1;         /*!< [2..2] GDMA 1 ISR for Channel 2                                           */
      __IM  uint32_t gdma1_ch3_isr : 1;         /*!< [3..3] GDMA 1 ISR for Channel 3                                           */
      __IM  uint32_t gdma1_ch4_isr : 1;         /*!< [4..4] GDMA 1 ISR for Channel 4                                           */
      __IM  uint32_t gdma1_ch5_isr : 1;         /*!< [5..5] GDMA 1 ISR for Channel 5                                           */
    } gdma1_isr_b;
  } ;

  union {
    __IM  uint32_t sgpio_isr;                   /*!< (@ 0x00000038) SGPIO ISR Register                                         */

    struct {
      __IM  uint32_t sgpio0_isr : 1;            /*!< [0..0] SGPIO 1 ISR                                                        */
      __IM  uint32_t sgpio1_isr : 1;            /*!< [1..1] SGPIO 0 ISR                                                        */
    } sgpio_isr_b;
  } ;

  union {
    __IM  uint32_t uart_isr;                    /*!< (@ 0x0000003C) UART ISR Register                                          */

    struct {
      __IM  uint32_t uart0_isr  : 1;            /*!< [0..0] UART 0 Interrupt pending status                                    */
      __IM  uint32_t uart1_isr  : 1;            /*!< [1..1] UART 1 Interrupt pending status                                    */
      __IM  uint32_t uart2_isr  : 1;            /*!< [2..2] UART 2 Interrupt pending status                                    */
    } uart_isr_b;
  } ;

  union {
    __IM  uint32_t i2c_isr;                     /*!< (@ 0x00000040) I2C ISR Register                                           */

    struct {
      __IM  uint32_t i2c0_isr   : 1;            /*!< [0..0] I2C0 ISR                                                           */
      __IM  uint32_t            : 1;
      __IM  uint32_t i2c2_isr   : 1;            /*!< [2..2] I2C2 ISR                                                           */
      __IM  uint32_t i2c3_isr   : 1;            /*!< [3..3] I2C3 ISR                                                           */
    } i2c_isr_b;
  } ;

  union {
    __IM  uint32_t spi_isr;                     /*!< (@ 0x00000044) SPI ISR Register                                           */

    struct {
      __IM  uint32_t spi0_isr   : 1;            /*!< [0..0] SPI0 ISR                                                           */
      __IM  uint32_t spi1_isr   : 1;            /*!< [1..1] SPI1 ISR                                                           */
      __IM  uint32_t spi2_isr   : 1;            /*!< [2..2] SPI2 ISR                                                           */
      __IM  uint32_t spi3_isr   : 1;            /*!< [3..3] SPI3 ISR                                                           */
    } spi_isr_b;
  } ;

  union {
    __IM  uint32_t i2s_pcm_isr;                 /*!< (@ 0x00000048) I2S ISR Register                                           */

    struct {
      __IM  uint32_t i2s0_isr   : 1;            /*!< [0..0] I2S 0 ISR                                                          */
      __IM  uint32_t i2s1_isr   : 1;            /*!< [1..1] I2S 1 ISR                                                          */
      __IM  uint32_t            : 2;
      __IM  uint32_t pcm0_isr   : 1;            /*!< [4..4] PCM 0 ISR                                                          */
      __IM  uint32_t pcm1_isr   : 1;            /*!< [5..5] PCM 1 ISR                                                          */
    } i2s_pcm_isr_b;
  } ;
  __IM  uint32_t  wl_isr;                       /*!< (@ 0x0000004C) WLAN ISR Register                                          */
  __IM  uint32_t  RESERVED2[4];

  union {
    __IOM uint32_t gdma_hsks_ctrl;              /*!< (@ 0x00000060) GDMA Handshake Control Register                            */

    struct {
      __IOM uint32_t hs_gdma_hsks_cfg : 32;     /*!< [31..0] GDMA handshake signal mapping. Some peripherals can
                                                     operate with either GDMA0 or GDMA1. This mapping decides
                                                     DMA handshake signal connection. If Nth bit is 0, the peripheral's
                                                     DMA handshake signal is connected to GDMA0; if Nth bit
                                                     is 1, the peripheral's DMA handshake signal is connected
                                                     to GDMA1. Peripheral and GDMA handshake signal connection
                                                     option is as in below table.                                              */
    } gdma_hsks_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED3[5];

  union {
    __IOM uint32_t mailbox_out_ctrl;            /*!< (@ 0x00000078) Mailbox Out Control Register                               */

    struct {
      __IOM uint32_t outrdy     : 1;            /*!< [0..0] Out mailbox data ready flag. CPU can only update OutData
                                                     when this bit is 0. After updating OutData, CPU should
                                                     set OutReady to 1. CPU writes 0 has no effect                             */
      __IOM uint32_t out_empty_int_en : 1;      /*!< [1..1] After OutData has been read by remote side (OutReady
                                                     == 0), CPU will receive interrupt if this bit is set to
                                                     1.                                                                        */
      __IM  uint32_t            : 5;
      __IOM uint32_t out_abort  : 1;            /*!< [7..7] Out data abort FW write 1 to this bit will clear OutReady
                                                     This bit is auto-clear.                                                   */
    } mailbox_out_ctrl_b;
  } ;

  union {
    __IOM uint32_t pta_i2c_ctrl;                /*!< (@ 0x0000007C) I2C PTA Control Register                                   */

    struct {
      __IOM uint32_t pta_i2c_en : 1;            /*!< [0..0] pta_i2c_en                                                         */
      __IOM uint32_t pta_i2c_unlock : 1;        /*!< [1..1] pta_i2c_unlock                                                     */
      __IOM uint32_t pta_i2c_speed : 2;         /*!< [3..2] pta_i2c_speed                                                      */
      __IOM uint32_t pta_i2c_gnt_fw : 1;        /*!< [4..4] pta_i2c_gnt_fw                                                     */
      __IOM uint32_t pta_i2c_bus_gnt_fw : 3;    /*!< [7..5] pta_i2c_bus_gnt_fw                                                 */
    } pta_i2c_ctrl_b;
  } ;
  __IM  uint32_t  RESERVED4[2];

  union {
    __IOM uint32_t wl_pmc_imr;                  /*!< (@ 0x00000088) WLAN PMC IMR Register                                      */

    struct {
      __IOM uint32_t bit_inrdy  : 1;            /*!< [0..0] In mailbox data ready status. After CPU read InData,
                                                     it should write 1 to clear this bit.                                      */
      __IOM uint32_t bit_inrdy_int_en : 1;      /*!< [1..1] Enable interrupt of In mailbox data ready                          */
    } wl_pmc_imr_b;
  } ;
  __IM  uint32_t  RESERVED5;

  union {
    __IOM uint32_t lx_ctrl0;                    /*!< (@ 0x00000090) Lexra Control Register 0                                   */

    struct {
      __IOM uint32_t lx_bus_timeout_en : 1;     /*!< [0..0] 1:Enable                                                           */
      __IOM uint32_t lx_bus_timeout_threshold : 2;/*!< [2..1] 2'b00: 2^15 lexra clock cycles 2'b01: 2^13 lexra clock
                                                     cycles 2'b10: 2^11 lexra clock cycles 2'b11: 2^9 lexra
                                                     clock cycles                                                              */
      __IOM uint32_t lx1_dma_lock_en : 1;       /*!< [3..3] 1'b1: set gnt=0 to lock lexra dma function.                        */
      __IM  uint32_t lx1_dma_lock_done : 1;     /*!< [4..4] 1'b1: lock is done. There is no dma transaction now.               */
      __IOM uint32_t pcm_spdup_en : 1;          /*!< [5..5] PCM speedup enable, only for test mode.                            */
      __IOM uint32_t pcm0_lx_req_en : 1;        /*!< [6..6] 1: Enable                                                          */
      __IOM uint32_t pcm1_lx_req_en : 1;        /*!< [7..7] 1: Enable                                                          */
      __IOM uint32_t lx2_dma_lock_en : 1;       /*!< [8..8] 1'b1: set gnt=0 to lock lexra dma function.                        */
      __IM  uint32_t lx2_dma_lock_done : 1;     /*!< [9..9] 1'b1: lock is done. There is no dma transaction now.               */
      __IM  uint32_t            : 6;
      __IOM uint32_t mii_lx_timeout_en : 1;     /*!< [16..16] 1:Enable                                                         */
      __IOM uint32_t mii_lx_timeout_threshold : 2;/*!< [18..17] 2'b00: 2^15 lexra clock cycles 2'b01: 2^13 lexra clock
                                                     cycles 2'b10: 2^11 lexra clock cycles 2'b11: 2^9 lexra
                                                     clock cycles                                                              */
    } lx_ctrl0_b;
  } ;

  union {
    __IM  uint32_t lx_ctrl1;                    /*!< (@ 0x00000094) Lexra Control Register 1                                   */

    struct {
      __IM  uint32_t r_lx1_to_addr_mst : 32;    /*!< [31..0] The address when lexra master is hanged.                          */
    } lx_ctrl1_b;
  } ;

  union {
    __IM  uint32_t lx_ctrl2;                    /*!< (@ 0x00000098) Lexra Control Register 2                                   */

    struct {
      __IM  uint32_t r_lx1_to_addr_slv : 32;    /*!< [31..0] The address when lexra slave is hanged.                           */
    } lx_ctrl2_b;
  } ;

  union {
    __IM  uint32_t reg_lx_ctrl3;                /*!< (@ 0x0000009C) Lexra Control Register 3                                   */

    struct {
      __IM  uint32_t r_lx2_to_addr_mst : 32;    /*!< [31..0] The address when lexra master is hanged.                          */
    } reg_lx_ctrl3_b;
  } ;
  __IM  uint32_t  RESERVED6[4];

  union {
    __IOM uint32_t mbist_ctrl0;                 /*!< (@ 0x000000B0) MBIST Control Register 0                                   */

    struct {
      __IOM uint32_t mbist_en   : 1;            /*!< [0..0] Set reset_n of mbist controller                                    */
      __IOM uint32_t mbist_cke  : 1;            /*!< [1..1] Set clock enable of mbist controller                               */
      __IM  uint32_t            : 6;
      __IOM uint32_t mbist_ctrlr_addr : 5;      /*!< [12..8] Set mbist controller address                                      */
    } mbist_ctrl0_b;
  } ;

  union {
    __IOM uint32_t mbist_ctrl1;                 /*!< (@ 0x000000B4) MBIST Control Register 1                                   */

    struct {
      __IOM uint32_t mbist_ctrlr_data : 32;     /*!< [31..0] Indirectly write to mbist controller with write strobe/Indirectly
                                                     read from mbist controller                                                */
    } mbist_ctrl1_b;
  } ;
} VDR_Type;                                     /*!< Size = 184 (0xb8)                                                         */


/** @} */ /* End of group device_vendor_reg */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup device_vendor_addr Vendor Control Base Address
  * @ingroup hs_hal_vdr
  * @{
  */

#define VDR_BASE                    0x40002800UL

/** @} */ /* End of group device_vendor_addr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup device_vendor_decl Vendor Control Device Declaration
  * @ingroup hs_hal_vdr
  * @{
  */

#define VDR                         ((VDR_Type*)               VDR_BASE)

/** @} */ /* End of group device_vendor_decl */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif

#include "rtl8195bhp_vdr_type.h"

/// @endcond /* End of condition DOXYGEN_VDR_REG_TYPE */

#ifdef __cplusplus
}
#endif

#endif /* RTL8195BHP_VENDOR_H */


/** @} */ /* End of group hs_hal_vdr */


