/*
 * Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0 
 * Licensed under the Apache License, Version 2.0 (the License); you may 
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 *
 * @file     rtl8195blp.h
 * @brief    CMSIS HeaderFile
 * @version  1.0
 * @date     16. July 2019
 * @note     Generated by SVDConv V3.3.18 on Tuesday, 16.07.2019 15:50:16
 *           from File 'rtl8195b-lp.svd',
 *           last modified on Tuesday, 16.07.2019 07:38:38
 */



/** @addtogroup Realtek Realtek Semiconductor Corp.
  * @{
  */


/** @addtogroup rtl8195blp
  * @{
  */


#ifndef RTL8195BLP_H
#define RTL8195BLP_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

enum {
/* ========================================  ARM ARMV8MBL Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* =========================================  rtl8195blp Specific Interrupt Numbers  ========================================= */
  SystemOn_IRQn             =   0,              /*!< 0  SystemOn                                                               */
  TimerGroup0_IRQn          =   1,              /*!< 1  TimerGroup0                                                            */
  GPIO_IRQn                 =   2,              /*!< 2  GPIO                                                                   */
  PWM_IRQn                  =   3,              /*!< 3  PWM                                                                    */
  ADC_IRQn                  =   4,              /*!< 4  ADC                                                                    */
  SGPIO_IRQn                =   5,              /*!< 5  SGPIO                                                                  */
  UART_IRQn                 =   6,              /*!< 6  UART                                                                   */
  I2C_IRQn                  =   7,              /*!< 7  I2C                                                                    */
  GDMA_IRQn                 =   8,              /*!< 8  GDMA                                                                   */
  ICC_IRQn                  =   9,              /*!< 9  ICC                                                                    */
  Comp_IRQn                 =  10,              /*!< 10 Comp                                                                   */
  QDec_IRQn                 =  11,              /*!< 11 QDec                                                                   */
  CIR_IRQn                  =  12,              /*!< 12 CIR                                                                    */
  WLan0_IRQn                =  13,              /*!< 13 WLan0                                                                  */
  WLan1_IRQn                =  14,              /*!< 14 WLan1                                                                  */
  LowPri_IRQn               =  15               /*!< 15 LowPri                                                                 */
};
typedef int32_t IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM ARMV8MBL Processor and Core Peripherals  ============================ */
#define __ARMV8MBL_REV                 0x0000U  /*!< ARMV8MBL Core Revision                                                    */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __SAU_REGION_PRESENT           0        /*!< SAU present or not                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_armv8mbl.h"                      /*!< ARM ARMV8MBL processor and core peripherals                               */
#include "system_rtl8195blp.h"                  /*!< rtl8195blp System                                                         */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           ICC_H                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter CPU Communication on HP Platform - for HP and LP CPU can communicate each other (ICC_H)
  */

typedef struct {                                /*!< (@ 0x40002B80) ICC_H Structure                                            */
  
  union {
    __IOM uint32_t hrlw0;                       /*!< (@ 0x00000000) HP Read LP Write Register 0                                */
    
    struct {
      __IOM uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } hrlw0_b;
  } ;
  
  union {
    __IOM uint32_t hrlw1;                       /*!< (@ 0x00000004) HP Read LP Write Register 1                                */
    
    struct {
      __IOM uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } hrlw1_b;
  } ;
  
  union {
    __IOM uint32_t hrlw2;                       /*!< (@ 0x00000008) HP Read LP Write Register 2                                */
    
    struct {
      __IOM uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } hrlw2_b;
  } ;
  
  union {
    __IOM uint32_t hrlw3;                       /*!< (@ 0x0000000C) HP Read LP Write Register 3                                */
    
    struct {
      __IOM uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } hrlw3_b;
  } ;
  
  union {
    __IOM uint32_t lptg;                        /*!< (@ 0x00000010) LP Toggle Register                                         */
    
    struct {
      __IOM uint32_t lptg0      : 1;            /*!< [0..0] It's a 1 bit sequence number for HRLW0 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IOM uint32_t lptg1      : 1;            /*!< [1..1] It's a 1 bit sequence number for HRLW1 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IOM uint32_t lptg2      : 1;            /*!< [2..2] It's a 1 bit sequence number for HRLW2 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IOM uint32_t lptg3      : 1;            /*!< [3..3] It's a 1 bit sequence number for HRLW3 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IM  uint32_t            : 12;
      __IOM uint32_t l2htg0     : 1;            /*!< [16..16] The toggle bit for HLRW0 register updating.                      */
      __IOM uint32_t l2htg1     : 1;            /*!< [17..17] The toggle bit for HLRW1 register updating.                      */
      __IOM uint32_t l2htg2     : 1;            /*!< [18..18] The toggle bit for HLRW2 register updating.                      */
      __IOM uint32_t l2htg3     : 1;            /*!< [19..19] The toggle bit for HLRW3 register updating.                      */
      __IOM uint32_t l2htgs     : 1;            /*!< [20..20] The toggle bit for REG_SEMA register updating.                   */
    } lptg_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t sema;                        /*!< (@ 0x00000018) HW Semaphore Register                                      */
    
    struct {
      __IOM uint32_t sema0_ls_own : 1;          /*!< [0..0] The "Owned by LP" bit of the HW semaphore0.1: the HW
                                                     semaphore0 is owned by LS platform.                                       */
      __IM  uint32_t sema0_hs_own : 1;          /*!< [1..1] The "Owned by HP" bit of the HW semaphore0.1: the HW
                                                     semaphore0 is owned by HP platform.                                       */
      __IOM uint32_t sema1_ls_own : 1;          /*!< [2..2] The "Owned by LP" bit of the HW semaphore1.1: the HW
                                                     semaphore1 is owned by LS platform.                                       */
      __IM  uint32_t sema1_hs_own : 1;          /*!< [3..3] The "Owned by HP" bit of the HW semaphore1.1: the HW
                                                     semaphore1 is owned by HP platform.                                       */
      __IOM uint32_t sema2_ls_own : 1;          /*!< [4..4] The "Owned by LP" bit of the HW semaphore2.1: the HW
                                                     semaphore2 is owned by LS platform.                                       */
      __IM  uint32_t sema2_hs_own : 1;          /*!< [5..5] The "Owned by HP" bit of the HW semaphore2.1: the HW
                                                     semaphore2 is owned by HP platform.                                       */
      __IOM uint32_t sema3_ls_own : 1;          /*!< [6..6] The "Owned by LP" bit of the HW semaphore3.1: the HW
                                                     semaphore3 is owned by LS platform.                                       */
      __IM  uint32_t sema3_hs_own : 1;          /*!< [7..7] The "Owned by HP" bit of the HW semaphore3.1: the HW
                                                     semaphore3 is owned by HP platform.                                       */
      __IOM uint32_t sema4_ls_own : 1;          /*!< [8..8] The "Owned by LP" bit of the HW semaphore4.1: the HW
                                                     semaphore4 is owned by LS platform.                                       */
      __IM  uint32_t sema4_hs_own : 1;          /*!< [9..9] The "Owned by HP" bit of the HW semaphore4.1: the HW
                                                     semaphore4 is owned by HP platform.                                       */
      __IOM uint32_t sema5_ls_own : 1;          /*!< [10..10] The "Owned by LP" bit of the HW semaphore5.1: the HW
                                                     semaphore5 is owned by LS platform.                                       */
      __IM  uint32_t sema5_hs_own : 1;          /*!< [11..11] The "Owned by HP" bit of the HW semaphore5.1: the HW
                                                     semaphore5 is owned by HP platform.                                       */
      __IOM uint32_t sema6_ls_own : 1;          /*!< [12..12] The "Owned by LP" bit of the HW semaphore6.1: the HW
                                                     semaphore6 is owned by LS platform.                                       */
      __IM  uint32_t sema6_hs_own : 1;          /*!< [13..13] The "Owned by HP" bit of the HW semaphore6.1: the HW
                                                     semaphore6 is owned by HP platform.                                       */
      __IOM uint32_t sema7_ls_own : 1;          /*!< [14..14] The "Owned by LP" bit of the HW semaphore7.1: the HW
                                                     semaphore7 is owned by LS platform.                                       */
      __IM  uint32_t sema7_hs_own : 1;          /*!< [15..15] The "Owned by HP" bit of the HW semaphore7.1: the HW
                                                     semaphore7 is owned by HP platform.                                       */
      __IOM uint32_t sema8_ls_own : 1;          /*!< [16..16] The "Owned by LP" bit of the HW semaphore8.1: the HW
                                                     semaphore8 is owned by LS platform.                                       */
      __IM  uint32_t sema8_hs_own : 1;          /*!< [17..17] The "Owned by HP" bit of the HW semaphore8.1: the HW
                                                     semaphore8 is owned by HP platform.                                       */
      __IOM uint32_t sema9_ls_own : 1;          /*!< [18..18] The "Owned by LP" bit of the HW semaphore9.1: the HW
                                                     semaphore9 is owned by LS platform.                                       */
      __IM  uint32_t sema9_hs_own : 1;          /*!< [19..19] The "Owned by HP" bit of the HW semaphore9.1: the HW
                                                     semaphore9 is owned by HP platform.                                       */
      __IOM uint32_t sema10_ls_own : 1;         /*!< [20..20] The "Owned by LP" bit of the HW semaphore10.1: the
                                                     HW semaphore10 is owned by LS platform.                                   */
      __IM  uint32_t sema10_hs_own : 1;         /*!< [21..21] The "Owned by HP" bit of the HW semaphore10.1: the
                                                     HW semaphore10 is owned by HP platform.                                   */
      __IOM uint32_t sema11_ls_own : 1;         /*!< [22..22] The "Owned by LP" bit of the HW semaphore11.1: the
                                                     HW semaphore11 is owned by LS platform.                                   */
      __IM  uint32_t sema11_hs_own : 1;         /*!< [23..23] The "Owned by HP" bit of the HW semaphore11.1: the
                                                     HW semaphore11 is owned by HP platform.                                   */
      __IOM uint32_t sema12_ls_own : 1;         /*!< [24..24] The "Owned by LP" bit of the HW semaphore12.1: the
                                                     HW semaphore12 is owned by LS platform.                                   */
      __IM  uint32_t sema12_hs_own : 1;         /*!< [25..25] The "Owned by HP" bit of the HW semaphore13.1: the
                                                     HW semaphore13 is owned by HP platform.                                   */
      __IOM uint32_t sema13_ls_own : 1;         /*!< [26..26] The "Owned by LP" bit of the HW semaphore13.1: the
                                                     HW semaphore13 is owned by LS platform.                                   */
      __IM  uint32_t sema13_hs_own : 1;         /*!< [27..27] The "Owned by HP" bit of the HW semaphore15.1: the
                                                     HW semaphore16 is owned by HP platform.                                   */
      __IOM uint32_t sema14_ls_own : 1;         /*!< [28..28] The "Owned by LP" bit of the HW semaphore14.1: the
                                                     HW semaphore14 is owned by LS platform.                                   */
      __IM  uint32_t sema14_hs_own : 1;         /*!< [29..29] The "Owned by HP" bit of the HW semaphore14.1: the
                                                     HW semaphore14 is owned by HP platform.                                   */
      __IOM uint32_t sema15_ls_own : 1;         /*!< [30..30] The "Owned by LP" bit of the HW semaphore15.1: the
                                                     HW semaphore15 is owned by LS platform.                                   */
      __IM  uint32_t sema15_hs_own : 1;         /*!< [31..31] The "Owned by HP" bit of the HW semaphore15.1: the
                                                     HW semaphore15 is owned by HP platform.                                   */
    } sema_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t hlrw0;                       /*!< (@ 0x00000020) HP and LP Read/Write Register 0                            */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores. Since both CPU
                                                     can write these registers, the writing side should read
                                                     the register back to check is the writing successful.                     */
    } hlrw0_b;
  } ;
  
  union {
    __IOM uint32_t hlrw1;                       /*!< (@ 0x00000024) HP Read LP Write Register 5                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } hlrw1_b;
  } ;
  
  union {
    __IOM uint32_t hlrw2;                       /*!< (@ 0x00000028) HP Read LP Write Register 6                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } hlrw2_b;
  } ;
  
  union {
    __IOM uint32_t hlrw3;                       /*!< (@ 0x0000002C) HP Read LP Write Register 7                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } hlrw3_b;
  } ;
  
  union {
    __IM  uint32_t hwlr0;                       /*!< (@ 0x00000030) HP Write LP Read Register 0                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr0_b;
  } ;
  
  union {
    __IM  uint32_t hwlr1;                       /*!< (@ 0x00000034) HP Write LP Read Register 1                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr1_b;
  } ;
  
  union {
    __IM  uint32_t hwlr2;                       /*!< (@ 0x00000038) HP Write LP Read Register 2                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr2_b;
  } ;
  
  union {
    __IM  uint32_t hwlr3;                       /*!< (@ 0x0000003C) HP Write LP Read Register 3                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr3_b;
  } ;
  
  union {
    __IM  uint32_t hwlr4;                       /*!< (@ 0x00000040) HP Write LP Read Register 4                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr4_b;
  } ;
  
  union {
    __IM  uint32_t hwlr5;                       /*!< (@ 0x00000044) HP Write LP Read Register 5                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr5_b;
  } ;
  
  union {
    __IM  uint32_t hwlr6;                       /*!< (@ 0x00000048) HP Write LP Read Register 6                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr6_b;
  } ;
  
  union {
    __IM  uint32_t hwlr7;                       /*!< (@ 0x0000004C) HP Write LP Read Register 7                                */
    
    struct {
      __IM  uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } hwlr7_b;
  } ;
  
  union {
    __IM  uint32_t hptg;                        /*!< (@ 0x00000050) HP Toggle Register                                         */
    
    struct {
      __IM  uint32_t hptg0      : 1;            /*!< [0..0] It's a 1 bit sequence number for HWLR0 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg1      : 1;            /*!< [1..1] It's a 1 bit sequence number for HWLR1 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg2      : 1;            /*!< [2..2] It's a 1 bit sequence number for HWLR2 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg3      : 1;            /*!< [3..3] It's a 1 bit sequence number for HWLR3 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg4      : 1;            /*!< [4..4] It's a 1 bit sequence number for HWLR4 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg5      : 1;            /*!< [5..5] It's a 1 bit sequence number for HWLR5 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg6      : 1;            /*!< [6..6] It's a 1 bit sequence number for HWLR6 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t hptg7      : 1;            /*!< [7..7] It's a 1 bit sequence number for HWLR7 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t            : 8;
      __IM  uint32_t h2ltg0     : 1;            /*!< [16..16] It's a 1 bit sequence number for HLRW0 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t h2ltg1     : 1;            /*!< [17..17] It's a 1 bit sequence number for HLRW1 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t h2ltg2     : 1;            /*!< [18..18] It's a 1 bit sequence number for HLRW2 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t h2ltg3     : 1;            /*!< [19..19] It's a 1 bit sequence number for HLRW3 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t h2ltgs     : 1;            /*!< [20..20] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTGS toggles. 0/1: Disable/Enable Interrupt            */
    } hptg_b;
  } ;
} ICC_H_Type;                                   /*!< Size = 84 (0x54)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Controller to control 4IO & 8IO DTR Flash (SPIC)
  */

typedef struct {                                /*!< (@ 0x40006000) SPIC Structure                                             */
  
  union {
    __IOM uint32_t ctrlr0;                      /*!< (@ 0x00000000) SPIC Control Register 0                                    */
    
    struct {
      __IM  uint32_t            : 6;
      __IOM uint32_t scph       : 1;            /*!< [6..6] Serial Clock Phase.                                                */
      __IOM uint32_t scpol      : 1;            /*!< [7..7] Serial Clock Polarity.                                             */
      __IOM uint32_t tmod       : 2;            /*!< [9..8] Transfer mode.                                                     */
      __IM  uint32_t            : 6;
      __IOM uint32_t addr_ch    : 2;            /*!< [17..16] Indicate channel number of address phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t data_ch    : 2;            /*!< [19..18] Indicate channel number of data phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t cmd_ch     : 2;            /*!< [21..20] Indicate channel number of command phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t fast_rd    : 1;            /*!< [22..22] Indicate to use fast read command in user mode. If
                                                     setting to 1, SPIC would use FBAUDR to derive spi_sclk.                   */
      __IOM uint32_t ck_mtimes  : 5;            /*!< [27..23] Indicate the check time.                                         */
      __IOM uint32_t addr_ddr_en : 1;           /*!< [28..28] Enable address phase ddr mode.                                   */
      __IOM uint32_t data_ddr_en : 1;           /*!< [29..29] Enable data phase ddr mode.                                      */
      __IOM uint32_t cmd_ddr_en : 1;            /*!< [30..30] Enable command phase ddr mode. Always 2-byte command
                                                     type.                                                                     */
    } ctrlr0_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr1;                      /*!< (@ 0x00000004) SPIC Control Register 1                                    */
    
    struct {
      __IOM uint32_t ndf        : 12;           /*!< [11..0] ndf                                                               */
    } ctrlr1_b;
  } ;
  
  union {
    __IOM uint32_t ssienr;                      /*!< (@ 0x00000008) SPIC Enable Register                                       */
    
    struct {
      __IOM uint32_t spic_en    : 1;            /*!< [0..0] Enable or disable SPIC.                                            */
      __OM  uint32_t atck_cmd   : 1;            /*!< [1..1] Set to enable ATCK_CMD implementation. After this bit
                                                     is set, SPIC would not accept any command until checking
                                                     flash is not busy or timeout.                                             */
    } ssienr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ser;                         /*!< (@ 0x00000010) Slave Enable Register                                      */
    
    struct {
      __IOM uint32_t ser        : 1;            /*!< [0..0] SPIC only has one slave select line. This bit should
                                                     be always set.                                                            */
    } ser_b;
  } ;
  
  union {
    __IOM uint32_t baudr;                       /*!< (@ 0x00000014) Baud Rate Select Register                                  */
    
    struct {
      __IOM uint32_t sckdv      : 12;           /*!< [11..0] This register controls the frequency of spi_sclk. spi_sclk
                                                     = frequency of bus_clk / (2*sckdv)                                        */
    } baudr_b;
  } ;
  
  union {
    __IOM uint32_t txftlr;                      /*!< (@ 0x00000018) Transmit FIFO Threshold Level                              */
    
    struct {
      __IOM uint32_t tft        : 8;            /*!< [7..0] Transmit FIFO Threshold. Controls the level of entries
                                                     (or below) at which the transmit FIFO controller triggers
                                                     an interrupt.                                                             */
    } txftlr_b;
  } ;
  
  union {
    __IOM uint32_t rxftlr;                      /*!< (@ 0x0000001C) Receive FIFO Threshold Level                               */
    
    struct {
      __IOM uint32_t rft        : 8;            /*!< [7..0] Receive FIFO Threshold. Controls the level of entries
                                                     (or above) at which the receive FIFO controller triggers
                                                     an interrupt.                                                             */
    } rxftlr_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
    
    struct {
      __IM  uint32_t txtfl      : 8;            /*!< [7..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000024) Receive FIFO Level Register                                */
    
    struct {
      __IM  uint32_t rxtfl      : 8;            /*!< [7..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IM  uint32_t sr;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] SPIC Busy Flag. When set, indicates that a serial transfer
                                                     is in progress; when cleared indicates that the SPIC is
                                                     idle or disabled.                                                         */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. 0 : Transmit FIFO is full 1 : Transmit FIFO is
                                                     not full                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When the transmit FIFO contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. 0 : Transmit FIFO
                                                     is not empty 1 : Transmit FIFO is empty                                   */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. Set when the receive FIFO contains
                                                     one or more entries and is cleared when the receive FIFO
                                                     is empty. This bit can be polled by software to completely
                                                     empty the receive FIFO. 0 : Receive FIFO is empty 1 : Receive
                                                     FIFO is not empty                                                         */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. 0 : Receive
                                                     FIFO is not full 1 : Receive FIFO is full                                 */
      __IM  uint32_t txe        : 1;            /*!< [5..5] Transmission Error. Set if the transmit FIFO is empty
                                                     when a transfer is started. This bit can be set only when
                                                     the DW_apb_ssi is configured as a slave device. Data from
                                                     the previous transmission is resent on the txd line. This
                                                     bit is cleared when read. 0 : No error 1 : Transmission
                                                     error                                                                     */
      __IM  uint32_t dcol       : 1;            /*!< [6..6] Transmitting Status. This bit is set when SPIC is transmitting
                                                     command, address or data to the data register. By observing
                                                     this bit, users can avoid reading wrong data at the wrong
                                                     time if data is not ready to be read.                                     */
    } sr_b;
  } ;
  
  union {
    __IOM uint32_t spic_imr;                    /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t txeim      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : spi_txeir_r interrupt
                                                     is masked 1 : spi_txeir_r interrupt is not masked                         */
      __IOM uint32_t txoim      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : spi_txoir_r
                                                     interrupt is masked 1 : spi_txoir_r interrupt is not masked               */
      __IOM uint32_t rxuim      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : spi_rxuir_r
                                                     interrupt is masked 1 : spi_rxuir_r interrupt is not masked               */
      __IOM uint32_t rxoim      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : spi_rxoir_r
                                                     interrupt is masked 1 : spi_rxoir_r interrupt is not masked               */
      __IOM uint32_t rxfim      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : spi_rxfir_r interrupt
                                                     is masked 1 : spi_rxfir_r interrupt is not masked                         */
      __IOM uint32_t fseim      : 1;            /*!< [5..5] FIFO Size Error Interrupt Mask. 0 : spi_fseir_r interrupt
                                                     is masked 1 : spi_fseir_r interrupt is not masked                         */
      __IOM uint32_t wbeim      : 1;            /*!< [6..6] Write Burst Error Interrupt Mask. 0 : spi_wbier_r interrupt
                                                     is masked 1 : spi_wbier_r interrupt is not masked                         */
      __IOM uint32_t byeim      : 1;            /*!< [7..7] Byte Enable Error Interrupt Mask 0 : spi_byeir_r interrupt
                                                     is masked 1 : spi_byeir_r interrupt is not masked                         */
      __IOM uint32_t aceim      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Mask. 0 : spi_aceir_r
                                                     interrupt is masked 1 : spi_aceir_r interrupt is not masked               */
      __IOM uint32_t txsim      : 1;            /*!< [9..9] Transmit Split Interrupt Mask. 0 : spi_tx_sir_r interrupt
                                                     is masked 1 : spi_tx_sir_r interrupt is not masked                        */
    } spic_imr_b;
  } ;
  
  union {
    __IM  uint32_t spic_isr;                    /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t txeis      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status after Masking 0
                                                     : spi_txeir_r interrupt is not active after masking 1 :
                                                     spi_txeir_r interrupt is active after masking                             */
      __IM  uint32_t txois      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_txoir_r interrupt is not active after masking 1
                                                     : spi_txoir_r interrupt is active after masking                           */
      __IM  uint32_t rxuis      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status after Masking
                                                     0 : spi_rxuir_r interrupt is not active after masking 1
                                                     : spi_rxuir_r interrupt is active after masking                           */
      __IM  uint32_t rxois      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_rxoir_r interrupt is not active after masking 1
                                                     : spi_rxoir_r interrupt is active after masking                           */
      __IM  uint32_t rxfis      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status after Masking 0 :
                                                     spi_rxfir_r interrupt is not active after masking 1 : spi_rxfir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t fseis      : 1;            /*!< [5..5] FIFO Size Error Interrupt Status after Masking. 0 : spi_fseir_r
                                                     interrupt is not active after masking 1 : spi_fseir_r interrupt
                                                     is active after masking                                                   */
      __IM  uint32_t wbeis      : 1;            /*!< [6..6] Write Burst Error Interrupt Status after Masking. 0 :
                                                     spi_wbier_r interrupt is not active after masking 1 : spi_wbier_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t byeis      : 1;            /*!< [7..7] Byte Enable Error Interrupt Status after Masking 0 :
                                                     spi_byeir_r interrupt is not active after masking 1 : spi_byeir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t aceis      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Status after Masking.
                                                     0 : spi_aceir_r interrupt is not active after masking 1
                                                     : spi_aceir_r interrupt is active after masking                           */
      __IM  uint32_t txsis      : 1;            /*!< [9..9] Transmit Split Interrupt Status after Masking. 0 : spi_tx_sir_r
                                                     interrupt is not active after masking 1 : spi_tx_sir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxsis      : 1;            /*!< [10..10] Receive Split Interrupt Status after Masking. 0 : spi_rx_sir_r
                                                     interrupt is not active after masking 1 : spi_rx_sir_r
                                                     interrupt is active after masking                                         */
    } spic_isr_b;
  } ;
  
  union {
    __IM  uint32_t spic_risr;                   /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t txeir      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Raw Status before Masking
                                                     0 : spi_txeir_r interrupt is not acitve before masking
                                                     1 : spi_txeir_r interrupt is acitve before masking                        */
      __IM  uint32_t txoir      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_txoir_r interrupt is not acitve before masking
                                                     1 : spi_txoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxuir      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Raw Status before Masking
                                                     0 : spi_rxuir_r interrupt is not acitve before masking
                                                     1 : spi_rxuir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxoir      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_rxoir_r interrupt is not acitve before masking
                                                     1 : spi_rxoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxfir      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Raw Status before Masking
                                                     0 : spi_rxfir_r interrupt is not acitve before masking
                                                     1 : spi_rxfir_r interrupt is acitve before masking                        */
      __IM  uint32_t fseir      : 1;            /*!< [5..5] FIFO Size Error Interrupt Raw Status before Masking.
                                                     0 : spi_fseir_r interrupt is not acitve before masking
                                                     1 : spi_fseir_r interrupt is acitve before masking                        */
      __IM  uint32_t wbeir      : 1;            /*!< [6..6] Write Burst Error Interrupt Raw Status before Masking.
                                                     0 : spi_wbier_r interrupt is not acitve before masking
                                                     1 : spi_wbier_r interrupt is acitve before masking                        */
      __IM  uint32_t byeir      : 1;            /*!< [7..7] Byte Enable Error Interrupt Raw Status before Masking
                                                     0 : spi_byeir_r interrupt is not acitve before masking
                                                     1 : spi_byeir_r interrupt is acitve before masking                        */
      __IM  uint32_t aceir      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Raw Status before
                                                     Masking. 0 : spi_aceir_r interrupt is not acitve before
                                                     masking 1 : spi_aceir_r interrupt is acitve before masking                */
    } spic_risr_b;
  } ;
  
  union {
    __IM  uint32_t txoicr;                      /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t txoicr     : 1;            /*!< [0..0] Clear Transmit FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txo_intr interrupt; writing has
                                                     no effect.                                                                */
    } txoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxoicr;                      /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
    
    struct {
      __IM  uint32_t rxoicr     : 1;            /*!< [0..0] Clear Receive FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxo_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxuicr;                      /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t rxuicr     : 1;            /*!< [0..0] Clear Receive FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxu_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxuicr_b;
  } ;
  
  union {
    __IM  uint32_t faeicr;                      /*!< (@ 0x00000044) Frame Alignment Interrupt Clear Register                   */
    
    struct {
      __IM  uint32_t faeicr     : 1;            /*!< [0..0] Clear Frame Alignment Interrupt. This register reflects
                                                     the status of the interrupt. A read from this register
                                                     clears the ssi_fae_intr interrupt; writing has no effect.                 */
    } faeicr_b;
  } ;
  
  union {
    __IM  uint32_t icr;                         /*!< (@ 0x00000048) Interrupt Clear Register                                   */
    
    struct {
      __IM  uint32_t icr        : 1;            /*!< [0..0] Clear Interrupts. This register is set if any of the
                                                     interrupts below are active. A read clears the ssi_txu_intr,
                                                     ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_fae_intr
                                                     interrupts. Writing to this register has no effect.                       */
    } icr_b;
  } ;
  
  union {
    __IOM uint32_t dmacr;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t rx_dmac_en : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel 0 : Receive DMA disabled 1 : Receive DMA
                                                     enabled                                                                   */
      __IOM uint32_t tx_dmac_en : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. 0 : Transmit DMA disabled 1 : Transmit
                                                     DMA enabled                                                               */
    } dmacr_b;
  } ;
  
  union {
    __IOM uint32_t dmatdlr;                     /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t dmatdl     : 8;            /*!< [7..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tx_dmac_en = 1.                                                       */
    } dmatdlr_b;
  } ;
  
  union {
    __IOM uint32_t dmardlr;                     /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
    
    struct {
      __IOM uint32_t dmardl     : 8;            /*!< [7..0] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or above this field value + 1, and rx_dmac_en
                                                     = 1.                                                                      */
    } dmardlr_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    union {
      __IOM uint32_t dr_word;                   /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint32_t word     : 32;           /*!< [31..0] Access FIFO as if its width is 4 byte per data item               */
      } dr_word_b;
    } ;
    
    union {
      __IOM uint16_t dr_half_word;              /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint16_t half_word : 16;          /*!< [15..0] Access FIFO as if its width is 2 byte per data item               */
      } dr_half_word_b;
    } ;
    
    union {
      __IOM uint8_t dr_byte;                    /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint8_t byte      : 8;            /*!< [7..0] Access FIFO as if its width is 1 byte per data item                */
      } dr_byte_b;
    } ;
  };
  __IM  uint32_t  RESERVED2[31];
  
  union {
    union {
      __IOM uint32_t read_fast_single;          /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_cmd  : 8;            /*!< [7..0] Fast read command.                                                 */
      } read_fast_single_b;
    } ;
    
    union {
      __IOM uint32_t rd_octal_io;               /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_octal_cmd : 16;      /*!< [15..0] Fast read command for Octal IO mode.                              */
      } rd_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t read_dual_data;              /*!< (@ 0x000000E4) Dual Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_dual_o_cmd : 8;         /*!< [7..0] Dual data read command, 1-1-2 mode.                                */
    } read_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t read_dual_addr_data;         /*!< (@ 0x000000E8) Dual IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual address and data read command, 1-2-2 mode.                    */
    } read_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_data;              /*!< (@ 0x000000EC) Quad Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_quad_o_cmd : 8;         /*!< [7..0] Quad data read command, 1-1-4 mode.                                */
    } read_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_addr_data;         /*!< (@ 0x000000F0) Quad IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_quad_io_cmd : 8;        /*!< [7..0] Quad address and data read command, 1-4-4 mode.                    */
      __IM  uint32_t            : 8;
      __IOM uint32_t prm_value  : 8;            /*!< [23..16] High Performance Read Mode Control Value.                        */
    } read_quad_addr_data_b;
  } ;
  
  union {
    union {
      __IOM uint32_t write_single;              /*!< (@ 0x000000F4) Single IO Page Program Command Register                    */
      
      struct {
        __IOM uint32_t wr_cmd   : 8;            /*!< [7..0] One bit mode page program command.                                 */
      } write_single_b;
    } ;
    
    union {
      __IOM uint32_t write_octal_io;            /*!< (@ 0x000000F4) Octal IO Page Program Command Register                     */
      
      struct {
        __IOM uint32_t wr_octal_cmd : 16;       /*!< [15..0] Octal IO page program command.                                    */
      } write_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t write_dual_data;             /*!< (@ 0x000000F8) Dual Page Program Command Register                         */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual page program command, 1-1-2 mode.                             */
    } write_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t write_dual_addr_data;        /*!< (@ 0x000000FC) Dual IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_dual_ii_cmd : 8;        /*!< [7..0] Dual IO page program command, 1-2-2 mode.                          */
    } write_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_data;             /*!< (@ 0x00000100) Quad Page Program Command Register                         */
    
    struct {
      __IOM uint32_t wr_quad_i_cmd : 8;         /*!< [7..0] Quad page program command, 1-1-4 mode.                             */
    } write_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_addr_data;        /*!< (@ 0x00000104) Quad IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_quad_ii_cmd : 8;        /*!< [7..0] Quad IO page program command, 1-4-4 mode.                          */
    } write_quad_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_enable;                /*!< (@ 0x00000108) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t wr_en_cmd  : 16;           /*!< [15..0] Write Enable Command. The second command byte is for
                                                     DTR mode.                                                                 */
    } write_enable_b;
  } ;
  
  union {
    __IOM uint32_t read_status;                 /*!< (@ 0x0000010C) Read Status Command Register                               */
    
    struct {
      __IOM uint32_t rd_st_cmd  : 16;           /*!< [15..0] Read flash status register command.                               */
    } read_status_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr2;                      /*!< (@ 0x00000110) SPIC Control Register 2                                    */
    
    struct {
      __IOM uint32_t so_dnum    : 1;            /*!< [0..0] Indicate SO input pin of SPI Flash is connected to spi_sout[0]
                                                     or spi_sout[1]. Set 1 to support multi-channels connection
                                                     in default.                                                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t seq_en     : 1;            /*!< [3..3] Set to enable data-split program / read.                           */
      __IOM uint32_t tx_fifo_entry : 4;         /*!< [7..4] Indicate the valid entry of transmit FIFO.                         */
      __IOM uint32_t rx_fifo_entry : 4;         /*!< [11..8] Indicate the valid entry of receive FIFO.                         */
      __IOM uint32_t cs_active_hold : 2;        /*!< [13..12] For flash chip select active hold time after SCLK resing
                                                     edge.                                                                     */
    } ctrlr2_b;
  } ;
  
  union {
    __IOM uint32_t fbaudr;                      /*!< (@ 0x00000114) Fast Read Baud Rate Select Register                        */
    
    struct {
      __IOM uint32_t fsckdv     : 12;           /*!< [11..0] This register controls the frequency of spi_sclk for
                                                     fast read command. spi_sclk = frequency of bus_clk / (2*fsckdv)           */
    } fbaudr_b;
  } ;
  
  union {
    __IOM uint32_t addr_length;                 /*!< (@ 0x00000118) Address Byte Length Register                               */
    
    struct {
      __IOM uint32_t addr_phase_length : 3;     /*!< [2..0] Indicate the number of bytes in address phase. addr_phase_length
                                                     [2] is an extended bit for 4-Byte Address with PRM mode.
                                                     Set to 5, SPIC can send 4 byte address and 1 byte PRM mode
                                                     value. 3-Byte Address with PRM mode need to set this bit
                                                     to 0, SPIC can send 3byte address and 1byte PRM mode value.
                                                     1 : One byte address, 2 : Two byte address, 3 : Three byte
                                                     address, 4: Four byte address with PRM value, 0 : Four
                                                     byte address / Three bytee addree with PRM value.                         */
    } addr_length_b;
  } ;
  
  union {
    union {
      __IOM uint32_t auto_length;               /*!< (@ 0x0000011C) Auto Mode Address Byte Length Register                     */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IM  uint32_t          : 4;
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t auto_dum_len : 8;        /*!< [25..18] Dummy cycle is used to check flash status in auto_write
                                                     operation if delay time of read data 1 cycle.                             */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_b;
    } ;
    
    union {
      __IOM uint32_t auto_length_seq;           /*!< (@ 0x0000011C) Sequential Auto Mode Address Byte Length Register          */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IOM uint32_t in_physical_cyc : 4;     /*!< [15..12] Indicate how many SPIC clk cycles from pad to internal
                                                     SPIC.                                                                     */
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t spic_cyc_per_byte : 8;   /*!< [25..18] Indicate how many SPIC clk cycles for one byte. Formula
                                                     = BAUD*2*Byte / CH, the maximum value is 256                              */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_seq_b;
    } ;
  };
  
  union {
    __IOM uint32_t valid_cmd;                   /*!< (@ 0x00000120) Valid Command Register                                     */
    
    struct {
      __IOM uint32_t frd_single : 1;            /*!< [0..0] Execute fast read for auto read mode.                              */
      __IOM uint32_t rd_dual_i  : 1;            /*!< [1..1] Execute dual data write for auto read mode. (1-1-2)                */
      __IOM uint32_t rd_dual_io : 1;            /*!< [2..2] Execute dual address data read for auto read mode. (1-2-2)         */
      __IOM uint32_t rd_quad_o  : 1;            /*!< [3..3] Execute quad data write for auto read mode. (1-1-4)                */
      __IOM uint32_t rd_quad_io : 1;            /*!< [4..4] Execute quad address data read for auto read mode. (1-4-4)         */
      __IOM uint32_t wr_dual_i  : 1;            /*!< [5..5] Execute dual data write for auto write mode. (1-1-2)               */
      __IOM uint32_t wr_dual_ii : 1;            /*!< [6..6] Execute dual address data write for auto write mode.
                                                     (1-2-2)                                                                   */
      __IOM uint32_t wr_quad_i  : 1;            /*!< [7..7] Execute quad data write for auto write mode. (1-1-4)               */
      __IOM uint32_t wr_quad_ii : 1;            /*!< [8..8] Execute quad address data write for auto write mode.
                                                     (1-4-4)                                                                   */
      __IOM uint32_t wr_blocking : 1;           /*!< [9..9] Accept next operation after the write data push to FIFO
                                                     and FIFO is pop data to empty by SPIC. Should always be
                                                     1.                                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t prm_en     : 1;            /*!< [11..11] Enable SPIC performance read mode in auto mode.                  */
      __IOM uint32_t ctrlr0_ch  : 1;            /*!< [12..12] Set this bit, then SPIC refers cmd_ch / data_ch / addr_en
                                                     / cmd_ddr_en / data_ddr_en / addr_ddr_en bit fields in
                                                     Control Register 0 in auto mode.                                          */
      __IM  uint32_t            : 1;
      __IOM uint32_t seq_trans_en : 1;          /*!< [14..14] Set 1 to enable read sequential transaction determination
                                                     function. If the auto read address is sequenctial, users
                                                     can save command phase and address phase under this mode.                 */
    } valid_cmd_b;
  } ;
  
  union {
    __IOM uint32_t flash_size;                  /*!< (@ 0x00000124) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t flash_size : 4;            /*!< [3..0] The size of flash size to select the target SPI flash
                                                     in auto mode.                                                             */
    } flash_size_b;
  } ;
  
  union {
    __IOM uint32_t flush_fifo;                  /*!< (@ 0x00000128) Read Status Command Register                               */
    
    struct {
      __OM  uint32_t flush_fifio : 1;           /*!< [0..0] Write to flush SPIC FIFO.                                          */
    } flush_fifo_b;
  } ;
} SPIC_Type;                                    /*!< Size = 300 (0x12c)                                                        */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real Time Clock (RTC) (RTC)
  */

typedef struct {                                /*!< (@ 0xA0000080) RTC Structure                                              */
  
  union {
    __IOM uint32_t cmd;                         /*!< (@ 0x00000000) REG_AON_LSFIF_CMD                                          */
    
    struct {
      __IOM uint32_t lsfif_ad   : 16;           /*!< [15..0] BIT_AON_LSFIF_AD[15:8]=8'h00: RTC register base address           */
      __IM  uint32_t            : 8;
      __IOM uint32_t lsfif_we   : 4;            /*!< [27..24] LSF register byte write enable. This field is valid
                                                     during LSF register write transfer, and is ignored during
                                                     LSF register read transfer                                                */
      __IOM uint32_t lsfif_wr   : 1;            /*!< [28..28] LSF register write transfer indicator. 1: LSF register
                                                     write transfer, 0: LSF register read transfer                             */
      __IM  uint32_t            : 2;
      __IOM uint32_t lsfif_poll : 1;            /*!< [31..31] Set this bit to do LSF register read or write transfer
                                                     depend on BIT_AON_LSFIF_WR. When transfer done, this bit
                                                     will be clear by HW                                                       */
    } cmd_b;
  } ;
  
  union {
    __IOM uint32_t lsfif_rwd;                   /*!< (@ 0x00000004) REG_AON_LSFIF_RWD                                          */
    
    struct {
      __IOM uint32_t lsfif_rwd  : 32;           /*!< [31..0] LSF(low speed function) write                                     */
    } lsfif_rwd_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x00000008) REG_AON_RTC_IMR                                            */
    
    struct {
      __IOM uint32_t cnt_sec_imr : 1;           /*!< [0..0] Interrupt mask of RTC seconds counter                              */
      __IOM uint32_t cnt_min_imr : 1;           /*!< [1..1] Interrupt mask of RTC minutes counter                              */
      __IOM uint32_t cnt_hrs_imr : 1;           /*!< [2..2] Interrupt mask of RTC hours counter                                */
      __IOM uint32_t cnt_dow_imr : 1;           /*!< [3..3] Interrupt mask of RTC day of week counter                          */
      __IOM uint32_t cnt_dom_imr : 1;           /*!< [4..4] Interrupt mask of RTC day of month counter                         */
      __IOM uint32_t cnt_mth_imr : 1;           /*!< [5..5] Interrupt mask of RTC month counter                                */
      __IOM uint32_t cnt_yrs_imr : 1;           /*!< [6..6] Interrupt mask of RTC years counter                                */
      __IOM uint32_t cnt_doy_imr : 1;           /*!< [7..7] Interrupt mask of RTC day of year counter                          */
      __IOM uint32_t alrm_sec_imr : 1;          /*!< [8..8] Interrupt mask of RTC second alarm                                 */
      __IOM uint32_t alrm_min_imr : 1;          /*!< [9..9] Interrupt mask of RTC minute alarm                                 */
      __IOM uint32_t alrm_hrs_imr : 1;          /*!< [10..10] Interrupt mask of RTC hour alarm                                 */
      __IOM uint32_t alrm_dow_imr : 1;          /*!< [11..11] Interrupt mask of RTC day of week alarm                          */
      __IOM uint32_t alrm_dom_imr : 1;          /*!< [12..12] Interrupt mask of RTC day of month alarm                         */
      __IOM uint32_t alrm_mth_imr : 1;          /*!< [13..13] Interrupt mask of RTC month alarm                                */
      __IOM uint32_t alrm_yrs_imr : 1;          /*!< [14..14] Interrupt mask of RTC year alarm                                 */
      __IOM uint32_t alrm_doy_imr : 1;          /*!< [15..15] Interrupt mask of RTC day of year alarm                          */
      __IOM uint32_t alrm_imr   : 1;            /*!< [16..16] Interrupt mask of RTC alarm                                      */
    } imr_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x0000000C) REG_AON_RTC_ISR                                            */
    
    struct {
      __IOM uint32_t cnt_sec_isr : 1;           /*!< [0..0] Indicate increment of the second timer                             */
      __IOM uint32_t cnt_min_isr : 1;           /*!< [1..1] Indicate increment of the minute timer                             */
      __IOM uint32_t cnt_hrs_isr : 1;           /*!< [2..2] Indicate increment of the hour timer                               */
      __IOM uint32_t cnt_dow_isr : 1;           /*!< [3..3] Indicate increment of the day-of-week timer                        */
      __IOM uint32_t cnt_dom_isr : 1;           /*!< [4..4] Indicate increment of the day-of-month timer                       */
      __IOM uint32_t cnt_mth_isr : 1;           /*!< [5..5] Indicate increment of the month timer                              */
      __IOM uint32_t cnt_yrs_isr : 1;           /*!< [6..6] Indicate increment of the year timer                               */
      __IOM uint32_t cnt_doy_isr : 1;           /*!< [7..7] Indicate increment of the Day-of-year timer                        */
      __IOM uint32_t alrm_sec_isr : 1;          /*!< [8..8] Indicate Second timer value match ALRM_SEC                         */
      __IOM uint32_t alrm_min_isr : 1;          /*!< [9..9] Indicate Minute timer value match ALRM_MIN                         */
      __IOM uint32_t alrm_hrs_isr : 1;          /*!< [10..10] Indicate Hour timer value match ALRM_HRS                         */
      __IOM uint32_t alrm_dow_isr : 1;          /*!< [11..11] Indicate DOW timer value match ALRM_DOW                          */
      __IOM uint32_t alrm_dom_isr : 1;          /*!< [12..12] Indicate DOM timer value match ALRM_DOM                          */
      __IOM uint32_t alrm_mth_isr : 1;          /*!< [13..13] Indicate MTH timer value match ALRM_MTH                          */
      __IOM uint32_t alrm_yrs_isr : 1;          /*!< [14..14] Indicate Year timer value match ALRM_YRS                         */
      __IOM uint32_t alrm_doy_isr : 1;          /*!< [15..15] Indicate DOY timer value match ALRM_DOY                          */
      __IOM uint32_t alrm_isr   : 1;            /*!< [16..16] Indicate ALL timer value match ALRM value                        */
    } isr_b;
  } ;
} RTC_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                           ICC_L                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter CPU Communication on LP Platform - for HP and LP CPU can communicate each other (ICC_L)
  */

typedef struct {                                /*!< (@ 0xA00002B0) ICC_L Structure                                            */
  
  union {
    __IOM uint32_t hptgie;                      /*!< (@ 0x00000000) HP Toggle Interrupt Enable Register                        */
    
    struct {
      __IOM uint32_t hptgie0    : 1;            /*!< [0..0] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG0 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie1    : 1;            /*!< [1..1] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG1 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie2    : 1;            /*!< [2..2] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG2 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie3    : 1;            /*!< [3..3] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG3 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie4    : 1;            /*!< [4..4] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG4 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie5    : 1;            /*!< [5..5] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG5 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie6    : 1;            /*!< [6..6] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG6 toggles. 0/1: Disable / Enable Interrupt           */
      __IOM uint32_t hptgie7    : 1;            /*!< [7..7] This bit is used to control the enable of the interrupt
                                                     triggered by the HPTG7 toggles. 0/1: Disable / Enable Interrupt           */
      __IM  uint32_t            : 8;
      __IOM uint32_t h2ltgie0   : 1;            /*!< [16..16] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTG0 toggles. 0/1: Disable / Enable
                                                     Interrupt                                                                 */
      __IOM uint32_t h2ltgie1   : 1;            /*!< [17..17] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTG1 toggles. 0/1: Disable / Enable
                                                     Interrupt                                                                 */
      __IOM uint32_t h2ltgie2   : 1;            /*!< [18..18] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTG2 toggles. 0/1: Disable / Enable
                                                     Interrupt                                                                 */
      __IOM uint32_t h2ltgie3   : 1;            /*!< [19..19] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTG3 toggles. 0/1: Disable / Enable
                                                     Interrupt                                                                 */
      __IOM uint32_t h2ltgies   : 1;            /*!< [20..20] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTGS toggles. 0/1: Disable/Enable Interrupt            */
    } hptgie_b;
  } ;
  
  union {
    __IOM uint32_t hptgis;                      /*!< (@ 0x00000004) HP Toggle Interrupt Status Register                        */
    
    struct {
      __IOM uint32_t hptgis0    : 1;            /*!< [0..0] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG0 toggles. This usually means the
                                                     HP CPU has updated the register HWLR0. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis1    : 1;            /*!< [1..1] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG1 toggles. This usually means the
                                                     HP CPU has updated the register HWLR1. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis2    : 1;            /*!< [2..2] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG2 toggles. This usually means the
                                                     HP CPU has updated the register HWLR2. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis3    : 1;            /*!< [3..3] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG3 toggles. This usually means the
                                                     HP CPU has updated the register HWLR3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis4    : 1;            /*!< [4..4] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG4 toggles. This usually means the
                                                     HP CPU has updated the register HWLR4. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis5    : 1;            /*!< [5..5] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG5 toggles. This usually means the
                                                     HP CPU has updated the register HWLR5. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis6    : 1;            /*!< [6..6] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG6 toggles. This usually means the
                                                     HP CPU has updated the register HWLR6. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t hptgis7    : 1;            /*!< [7..7] This bit is used to show the interrupt status which is
                                                     triggered by the HPTG7 toggles. This usually means the
                                                     HP CPU has updated the register HWLR7. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IM  uint32_t            : 8;
      __IOM uint32_t h2ltgis0   : 1;            /*!< [16..16] This bit is used to show the interrupt status which
                                                     is triggered by the H2LTG0 toggles. This usually means
                                                     the HP CPU has updated the register HLRW0. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t h2ltgis1   : 1;            /*!< [17..17] This bit is used to show the interrupt status which
                                                     is triggered by the H2LTG1 toggles. This usually means
                                                     the HP CPU has updated the register HLRW1. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t h2ltgis2   : 1;            /*!< [18..18] This bit is used to show the interrupt status which
                                                     is triggered by the H2LTG2 toggles. This usually means
                                                     the HP CPU has updated the register HLRW2. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t h2ltgis3   : 1;            /*!< [19..19] This bit is used to show the interrupt status which
                                                     is triggered by the H2LTG3 toggles. This usually means
                                                     the HP CPU has updated the register HLRW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t h2ltgiss   : 1;            /*!< [20..20] This bit is used to show the interrupt status which
                                                     is triggered by the H2LTGS toggles. This usually means
                                                     the HP CPU has updated the register REG_SEMA. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
    } hptgis_b;
  } ;
} ICC_L_Type;                                   /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose I/O (GPIO)
  */

typedef struct {                                /*!< (@ 0xA0001000) GPIO Structure                                             */
  
  union {
    __IM  uint32_t it_sts;                      /*!< (@ 0x00000000) GPIO interrupt type status Register                        */
    
    struct {
      __IM  uint32_t gpio_it_sts : 16;          /*!< [15..0] For each bit: 0: the specific GPIO pin is configured
                                                     to edge sensitive interrupt mode 1: the specific GPIO pin
                                                     is configured to levle sensitive interrupt mode.                          */
    } it_sts_b;
  } ;
  
  union {
    __IOM uint32_t ei_en;                       /*!< (@ 0x00000004) GPIO edge sensitive interrupt mode enable                  */
    
    struct {
      __IOM uint32_t ei_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as edge sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as zero.                                                       */
    } ei_en_b;
  } ;
  
  union {
    __IOM uint32_t li_en;                       /*!< (@ 0x00000008) GPIO level sensitive interrupt mode enable                 */
    
    struct {
      __IOM uint32_t li_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as level sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as 1.                                                          */
    } li_en_b;
  } ;
  
  union {
    __IM  uint32_t ip_sts;                      /*!< (@ 0x0000000C) GPIO interrupt polarity status                             */
    
    struct {
      __IM  uint32_t ip_sts0    : 2;            /*!< [1..0] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts1    : 2;            /*!< [3..2] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts2    : 2;            /*!< [5..4] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts3    : 2;            /*!< [7..6] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts4    : 2;            /*!< [9..8] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts5    : 2;            /*!< [11..10] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts6    : 2;            /*!< [13..12] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts7    : 2;            /*!< [15..14] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts8    : 2;            /*!< [17..16] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts9    : 2;            /*!< [19..18] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts10   : 2;            /*!< [21..20] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts11   : 2;            /*!< [23..22] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts12   : 2;            /*!< [25..24] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts13   : 2;            /*!< [27..26] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts14   : 2;            /*!< [29..28] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts15   : 2;            /*!< [31..30] The interrupt polarity status of GPIO15                          */
    } ip_sts_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ir_en;                       /*!< (@ 0x00000014) GPIO interrupt rising-edge enable                          */
    
    struct {
      __IOM uint32_t ir_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to rising-edge interrupt mode or
                                                     high-level mode (depends on REG_GPIO_IT_STS) and also cause
                                                     the corresponding bits of REG_GPIO_IP_STS to be read as
                                                     00b.                                                                      */
    } ir_en_b;
  } ;
  
  union {
    __IOM uint32_t if_en;                       /*!< (@ 0x00000018) GPIO interrupt falling-edge enable                         */
    
    struct {
      __IOM uint32_t if_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to falling-edge interrupt mode or
                                                     low-level interrupt mode (depends on REG_GPIO_IT_STS) and
                                                     cause the corresponding bits of REG_GPIO_IP_STS to be read
                                                     as 01b.                                                                   */
    } if_en_b;
  } ;
  
  union {
    __IOM uint32_t id_en;                       /*!< (@ 0x0000001C) GPIO interrupt dual-edge enable                            */
    
    struct {
      __IOM uint32_t id_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to dual-edge interrupt mode and
                                                     also cause the corresponding bits of REG_GPIO_IP_STS to
                                                     be read as 10b.                                                           */
    } id_en_b;
  } ;
  
  union {
    __IM  uint32_t ie_sts;                      /*!< (@ 0x00000020) GPIO interrupt enable status                               */
    
    struct {
      __IM  uint32_t ie_sts     : 16;           /*!< [15..0] For each bit: 0: the interrupt of the specific GPIO
                                                     pin is disabled 1: the interrupt of the specific GPIO pin
                                                     is enabled                                                                */
    } ie_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_en;                      /*!< (@ 0x00000024) GPIO interrupt enable                                      */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to enable the
                                                     specific GPIO INT and also cause the specified bit of REG_GPIO_IE_STS
                                                     to be read as ONE.                                                        */
    } int_en_b;
  } ;
  
  union {
    __IOM uint32_t int_dis;                     /*!< (@ 0x00000028) GPIO interrupt disable                                     */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to disable the
                                                     specified GPIO INT and also cause the specified bit of
                                                     REG_GPIO_IE_STS to be read as ZERO.                                       */
    } int_dis_b;
  } ;
  
  union {
    __IM  uint32_t int_raw_sts;                 /*!< (@ 0x0000002C) GPIO RAW interrupt status                                  */
    
    struct {
      __IM  uint32_t int_raw_sts : 16;          /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending
                                                     (permasking)                                                              */
    } int_raw_sts_b;
  } ;
  
  union {
    __IM  uint32_t int_sts;                     /*!< (@ 0x00000030) GPIO interrupt status                                      */
    
    struct {
      __IM  uint32_t int_sts    : 16;           /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending                */
    } int_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_clr;                     /*!< (@ 0x00000034) GPIO interrupt status clear                                */
    
    struct {
      __IOM uint32_t int_clr    : 16;           /*!< [15..0] For each bit writting: 0: No operation; 1: Clear edge
                                                     type pending interrupt of the conrtolled GPIO pin and clear
                                                     the specified bits of REG_GPIO_INT_STS as ZERO                            */
    } int_clr_b;
  } ;
  
  union {
    __IM  uint32_t int_func_en_sts;             /*!< (@ 0x00000038) GPIO interrupt function enable status                      */
    
    struct {
      __IM  uint32_t int_en_sts : 16;           /*!< [15..0] For each bit: 0: the specified GPIO INT is Disable 1:
                                                     the specified GPIO INT is Enable                                          */
    } int_func_en_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_func_en;                 /*!< (@ 0x0000003C) GPIO interrupt function enable                             */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is enabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ONE.                               */
    } int_func_en_b;
  } ;
  
  union {
    __IOM uint32_t int_func_dis;                /*!< (@ 0x00000040) GPIO interrupt function disable                            */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is disabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ZERO.                              */
    } int_func_dis_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t int0_sel;                    /*!< (@ 0x00000050) GPIO INT0 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT0                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT0                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int0_sel_b;
  } ;
  
  union {
    __IOM uint32_t int1_sel;                    /*!< (@ 0x00000054) GPIO INT1 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT1                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT1                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int1_sel_b;
  } ;
  
  union {
    __IOM uint32_t int2_sel;                    /*!< (@ 0x00000058) GPIO INT2 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT2                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT2                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int2_sel_b;
  } ;
  
  union {
    __IOM uint32_t int3_sel;                    /*!< (@ 0x0000005C) GPIO INT3 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT3                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT3                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int3_sel_b;
  } ;
  
  union {
    __IOM uint32_t int4_sel;                    /*!< (@ 0x00000060) GPIO INT4 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT4                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT4                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int4_sel_b;
  } ;
  
  union {
    __IOM uint32_t int5_sel;                    /*!< (@ 0x00000064) GPIO INT5 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT5                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT5                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int5_sel_b;
  } ;
  
  union {
    __IOM uint32_t int6_sel;                    /*!< (@ 0x00000068) GPIO INT6 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT6                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT6                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int6_sel_b;
  } ;
  
  union {
    __IOM uint32_t int7_sel;                    /*!< (@ 0x0000006C) GPIO INT7 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT7                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT7                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int7_sel_b;
  } ;
  
  union {
    __IOM uint32_t int8_sel;                    /*!< (@ 0x00000070) GPIO INT8 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT8                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT8                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int8_sel_b;
  } ;
  
  union {
    __IOM uint32_t int9_sel;                    /*!< (@ 0x00000074) GPIO INT9 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT9                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT9                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int9_sel_b;
  } ;
  
  union {
    __IOM uint32_t int10_sel;                   /*!< (@ 0x00000078) GPIO INT10 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT10                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT10                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int10_sel_b;
  } ;
  
  union {
    __IOM uint32_t int11_sel;                   /*!< (@ 0x0000007C) GPIO INT11 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT11                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT11                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int11_sel_b;
  } ;
  
  union {
    __IOM uint32_t int12_sel;                   /*!< (@ 0x00000080) GPIO INT12 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT12                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT12                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int12_sel_b;
  } ;
  
  union {
    __IOM uint32_t int13_sel;                   /*!< (@ 0x00000084) GPIO INT13 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT13                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT13                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int13_sel_b;
  } ;
  
  union {
    __IOM uint32_t int14_sel;                   /*!< (@ 0x00000088) GPIO INT14 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT14                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT14                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int14_sel_b;
  } ;
  
  union {
    __IOM uint32_t int15_sel;                   /*!< (@ 0x0000008C) GPIO INT15 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT15                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT15                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int15_sel_b;
  } ;
  __IM  uint32_t  RESERVED2[24];
  
  union {
    __IM  uint32_t deb_sts;                     /*!< (@ 0x000000F0) GPIO port debounce status                                  */
    
    struct {
      __IM  uint32_t deb_sts    : 16;           /*!< [15..0] For each bit: 0: the specific GPIO debounce pin is DISABLE
                                                     debounce 1: the specific GPIO debounce pin is ENABLE debounce             */
    } deb_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb_en;                      /*!< (@ 0x000000F4) GPIO debounce pin enable                                   */
    
    struct {
      __IOM uint32_t deb_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is enabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ONE.                                */
    } deb_en_b;
  } ;
  
  union {
    __IOM uint32_t deb_dis;                     /*!< (@ 0x000000F8) GPIO debounce pin disable                                  */
    
    struct {
      __IOM uint32_t deb_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is disabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ZERO.                               */
    } deb_dis_b;
  } ;
  
  union {
    __IM  uint32_t deb_dp_sts;                  /*!< (@ 0x000000FC) GPIO debounce data pin status                              */
    
    struct {
      __IM  uint32_t deb_dp_sts : 16;           /*!< [15..0] For each bit reading: read the signal level of the specified
                                                     pin after de-bounce                                                       */
    } deb_dp_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb0_sel;                    /*!< (@ 0x00000100) GPIO debounce0 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce0                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb0_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb1_sel;                    /*!< (@ 0x00000104) GPIO debounce1 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce1                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb1_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb2_sel;                    /*!< (@ 0x00000108) GPIO debounce2 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce2                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb2_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb3_sel;                    /*!< (@ 0x0000010C) GPIO debounce3 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce3                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb3_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb4_sel;                    /*!< (@ 0x00000110) GPIO debounce4 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce4                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb4_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb5_sel;                    /*!< (@ 0x00000114) GPIO debounce5 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce5                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb5_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb6_sel;                    /*!< (@ 0x00000118) GPIO debounce6 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce6                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb6_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb7_sel;                    /*!< (@ 0x0000011C) GPIO debounce7 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce7                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb7_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb8_sel;                    /*!< (@ 0x00000120) GPIO debounce8 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce8                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb8_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb9_sel;                    /*!< (@ 0x00000124) GPIO debounce9 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce9                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb9_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb10_sel;                   /*!< (@ 0x00000128) GPIO debounce10 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce10                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb10_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb11_sel;                   /*!< (@ 0x0000012C) GPIO debounce11 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce11                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb11_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb12_sel;                   /*!< (@ 0x00000130) GPIO debounce12 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce12                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb12_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb13_sel;                   /*!< (@ 0x00000134) GPIO debounce13 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce13                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb13_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb14_sel;                   /*!< (@ 0x00000138) GPIO debounce14 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce14                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb14_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb15_sel;                   /*!< (@ 0x0000013C) GPIO debounce15 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce15                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb15_sel_b;
  } ;
  __IM  uint32_t  RESERVED3[48];
  
  union {
    __IM  uint32_t port_a_dmd_sts;              /*!< (@ 0x00000200) GPIO port A data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_a_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_idm_en;               /*!< (@ 0x00000204) GPIO port A input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as zero.                                    */
    } port_a_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odm_en;               /*!< (@ 0x00000208) GPIO port A output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as one                                      */
    } port_a_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_od_sts;               /*!< (@ 0x0000020C) GPIO port A output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_a_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odl_en;               /*!< (@ 0x00000210) GPIO port A output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is zero.                               */
    } port_a_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odh_en;               /*!< (@ 0x00000214) GPIO port A output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is one.                                */
    } port_a_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odt_en;               /*!< (@ 0x00000218) GPIO port A output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_A_OD_STS
                                                     also will be toggled.                                                     */
    } port_a_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_dp_sts;               /*!< (@ 0x0000021C) GPIO port A data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port A.                                      */
    } port_a_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED4[8];
  
  union {
    __IM  uint32_t port_b_dmd_sts;              /*!< (@ 0x00000240) GPIO port B data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_b_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_idm_en;               /*!< (@ 0x00000244) GPIO port B input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as zero.                                    */
    } port_b_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odm_en;               /*!< (@ 0x00000248) GPIO port B output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as one                                      */
    } port_b_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_od_sts;               /*!< (@ 0x0000024C) GPIO port B output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_b_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odl_en;               /*!< (@ 0x00000250) GPIO port B output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is zero.                               */
    } port_b_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odh_en;               /*!< (@ 0x00000254) GPIO port B output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is one.                                */
    } port_b_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odt_en;               /*!< (@ 0x00000258) GPIO port B output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_B_OD_STS
                                                     also will be toggled.                                                     */
    } port_b_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_dp_sts;               /*!< (@ 0x0000025C) GPIO port B data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port B.                                      */
    } port_b_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED5[8];
  
  union {
    __IM  uint32_t port_c_dmd_sts;              /*!< (@ 0x00000280) GPIO port C data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_c_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_idm_en;               /*!< (@ 0x00000284) GPIO port C input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as zero.                                    */
    } port_c_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odm_en;               /*!< (@ 0x00000288) GPIO port C output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as one                                      */
    } port_c_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_od_sts;               /*!< (@ 0x0000028C) GPIO port C output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_c_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odl_en;               /*!< (@ 0x00000290) GPIO port C output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is zero.                               */
    } port_c_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odh_en;               /*!< (@ 0x00000294) GPIO port C output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is one.                                */
    } port_c_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odt_en;               /*!< (@ 0x00000298) GPIO port C output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_C_OD_STS
                                                     also will be toggled.                                                     */
    } port_c_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_dp_sts;               /*!< (@ 0x0000029C) GPIO port C data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port C.                                      */
    } port_c_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED6[8];
  
  union {
    __IM  uint32_t port_d_dmd_sts;              /*!< (@ 0x000002C0) GPIO port D data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_d_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_idm_en;               /*!< (@ 0x000002C4) GPIO port D input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as zero.                                    */
    } port_d_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odm_en;               /*!< (@ 0x000002C8) GPIO port D output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as one                                      */
    } port_d_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_od_sts;               /*!< (@ 0x000002CC) GPIO port D output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_d_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odl_en;               /*!< (@ 0x000002D0) GPIO port D output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is zero.                               */
    } port_d_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odh_en;               /*!< (@ 0x000002D4) GPIO port D output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is one.                                */
    } port_d_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odt_en;               /*!< (@ 0x000002D8) GPIO port D output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_D_OD_STS
                                                     also will be toggled.                                                     */
    } port_d_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_dp_sts;               /*!< (@ 0x000002DC) GPIO port D data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port D.                                      */
    } port_d_dp_sts_b;
  } ;
} GPIO_Type;                                    /*!< Size = 736 (0x2e0)                                                        */



/* =========================================================================================================================== */
/* ================                                            TG0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer Group Control (TG0)
  */

typedef struct {                                /*!< (@ 0xA0002000) TG0 Structure                                              */
  
  union {
    __IM  uint32_t ists;                        /*!< (@ 0x00000000) Timer Group interrupt status register                      */
    
    struct {
      __IM  uint32_t ists       : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt                             */
    } ists_b;
  } ;
  
  union {
    __IM  uint32_t raw_ists;                    /*!< (@ 0x00000004) Timer Group raw interrupt status register                  */
    
    struct {
      __IM  uint32_t rists      : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt (pre-masing)                */
    } raw_ists_b;
  } ;
  
  union {
    __IOM uint32_t tsel;                        /*!< (@ 0x00000008) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t tsel       : 3;            /*!< [2..0] The timer index in a timer group, to select the timer
                                                     for indirect read.                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Sync mode between Timer clock and APB clock 0: Freq.
                                                     of APB clock >> Freq. of Timer clock (about 10 times) 1:
                                                     others                                                                    */
      __IM  uint32_t            : 2;
      __IOM uint32_t poll       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by tsel. This bit is cleared by HW while
                                                     finishing read and indicate REG_TIMER_TC is ready                         */
    } tsel_b;
  } ;
  
  union {
    __IM  uint32_t tc;                          /*!< (@ 0x0000000C) Timer Group indirect read timer counter register           */
    
    struct {
      __IM  uint32_t timer_tc   : 32;           /*!< [31..0] Current counter value of the specifiied timer by register
                                                     tg_tsel.                                                                  */
    } tc_b;
  } ;
} TG0_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            TM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer0 (TM0)
  */

typedef struct {                                /*!< (@ 0xA0002040) TM0 Structure                                              */
  
  union {
    __IOM uint32_t lc;                          /*!< (@ 0x00000000) Timer load count register                                  */
    
    struct {
      __IOM uint32_t lc         : 32;           /*!< [31..0] The counter value to be loaded into the timer counter
                                                     when timer is enabled or reset. Min = 0, when prescaler
                                                     register > 0; otherwise Min = 1.                                          */
    } lc_b;
  } ;
  
  union {
    __IOM uint32_t tc;                          /*!< (@ 0x00000004) Timer current counter register                             */
    
    struct {
      __IOM uint32_t tc         : 32;           /*!< [31..0] Current counter value.                                            */
    } tc_b;
  } ;
  
  union {
    __IOM uint32_t pc;                          /*!< (@ 0x00000008) Timer prescaler counter register                           */
    
    struct {
      __IOM uint32_t pc         : 10;           /*!< [9..0] Pre-scaler counter will be increased every clock after
                                                     timer is enabled. When the prescaler counter is equal to
                                                     PR, the next clock increments (decrements) the TC and clears
                                                     the PC.                                                                   */
    } pc_b;
  } ;
  
  union {
    __IOM uint32_t pr;                          /*!< (@ 0x0000000C) Timer prescaler register                                   */
    
    struct {
      __IOM uint32_t pr         : 10;           /*!< [9..0] When the PC is equal to this value, the next clock increments
                                                     (decrements) the TC and clears the PC.                                    */
    } pr_b;
  } ;
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000010) Timer control register                                     */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Timer enable control: 0: Disable 1: Enable                         */
      __IOM uint32_t mod        : 1;            /*!< [1..1] Timer operation mode: 0: timer mode (periodical mode);
                                                     it reloads LC to TC and repeat the process according to
                                                     the setting when the timeout event occurred. 1: counter
                                                     mode (one-shot mode); only one time process.                              */
      __IOM uint32_t imr        : 1;            /*!< [2..2] Timer Interrupt mask: 0: disable interrupt 1: enable
                                                     interrupt                                                                 */
      __IOM uint32_t cnt_mod    : 1;            /*!< [3..3] Timer counting mode: 0: Up-counter 1: Down-counter                 */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x00000014) Timer0 interrupt status register                           */
    
    struct {
      __IOM uint32_t timeout    : 1;            /*!< [0..0] Timeout interrupt                                                  */
      __IOM uint32_t match_ev0  : 1;            /*!< [1..1] Counter value match event0 interrupt.                              */
      __IOM uint32_t match_ev1  : 1;            /*!< [2..2] Counter value match event1 interrupt.                              */
      __IOM uint32_t match_ev2  : 1;            /*!< [3..3] Counter value match event2 interrupt.                              */
      __IOM uint32_t match_ev3  : 1;            /*!< [4..4] Counter value match event3 interrupt.                              */
    } isr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t mectrl;                      /*!< (@ 0x0000001C) Timer match event control register                         */
    
    struct {
      __IOM uint32_t me0_en     : 1;            /*!< [0..0] Counter value match event0 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me1_en     : 1;            /*!< [1..1] Counter value match event1 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me2_en     : 1;            /*!< [2..2] Counter value match event2 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me3_en     : 1;            /*!< [3..3] Counter value match event3 enable control: 0: Disable
                                                     1: Enable                                                                 */
    } mectrl_b;
  } ;
  
  union {
    __IOM uint32_t me0;                         /*!< (@ 0x00000020) Timer match event0 counter register                        */
    
    struct {
      __IOM uint32_t me0        : 32;           /*!< [31..0] Timer counter value for metch event0.                             */
    } me0_b;
  } ;
  
  union {
    __IOM uint32_t me1;                         /*!< (@ 0x00000024) Timer match event1 counter register                        */
    
    struct {
      __IOM uint32_t me1        : 32;           /*!< [31..0] Timer counter value for metch event1.                             */
    } me1_b;
  } ;
  
  union {
    __IOM uint32_t me2;                         /*!< (@ 0x00000028) Timer match event2 counter register                        */
    
    struct {
      __IOM uint32_t me2        : 32;           /*!< [31..0] Timer counter value for metch event2.                             */
    } me2_b;
  } ;
  
  union {
    __IOM uint32_t me3;                         /*!< (@ 0x0000002C) Timer match event3 counter register                        */
    
    struct {
      __IOM uint32_t me3        : 32;           /*!< [31..0] Timer counter value for metch event3.                             */
    } me3_b;
  } ;
} TM0_Type;                                     /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                         PWM_COMM                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PWM Group Control (PWM_COMM)
  */

typedef struct {                                /*!< (@ 0xA0003000) PWM_COMM Structure                                         */
  
  union {
    __IM  uint32_t enable_status;               /*!< (@ 0x00000000) PWM enable status Register                                 */
    
    struct {
      __IM  uint32_t pwm_en_sts : 8;            /*!< [7..0] Each bit indicates the enabling status of corresponding
                                                     PWM: 0: the specific PWM is Disabled 1: the specific PWM
                                                     is Enabled                                                                */
    } enable_status_b;
  } ;
  
  union {
    __IOM uint32_t enable_ctrl;                 /*!< (@ 0x00000004) PWM enable Register                                        */
    
    struct {
      __IOM uint32_t pwm_en     : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the specific PWM is enabled
                                                     and the specific bit of REG_PWM_EN_STS is ONE.                            */
    } enable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t disable_ctrl;                /*!< (@ 0x00000008) PWM disable Register                                       */
    
    struct {
      __IOM uint32_t pwm_dis    : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the conrtolled PWM is disabled
                                                     and the specific bit of REG_PWM_EN_STS is ZERO.                           */
    } disable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t int_status;                  /*!< (@ 0x0000000C) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 8;       /*!< [7..0] To indicate the interrupt pending status for PWM 0 ~
                                                     7 duty auto-adjustment reaches the down-limit. Write 1
                                                     clear. Bit 0 for PWM0, bit 1 for PWM1, ...bit7 for PWM7.                  */
      __IM  uint32_t            : 8;
      __IOM uint32_t duty_adj_up_lim : 8;       /*!< [23..16] To indicate the interrupt pending status for PWM 0
                                                     ~ 7 duty auto-adjustment reaches the up-limit. Write 1
                                                     clear. Bit 16 for PWM0, bit 17 for PWM1, ...bit23 for PWM7.               */
      __IOM uint32_t period_end : 8;            /*!< [31..24] To indicate the interrupt pending status for PWM 0
                                                     ~7 period end. Write 1 clear. Bit 24 for PWM0, bit 25 for
                                                     PWM1, ...bit31 for PWM7.                                                  */
    } int_status_b;
  } ;
  
  union {
    __IOM uint32_t indread_idx;                 /*!< (@ 0x00000010) PWM Index of Indirect Read Register                        */
    
    struct {
      __IOM uint32_t pwm_sel    : 3;            /*!< [2..0] This field is used to assign the PWM index (0 ~ 7) for
                                                     the auto adjusted duty size indirect reading.                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Register sync mode selection for PWM clock and APB clock
                                                     0: Freq. of APB clock >> Freq. of PWM clock (about 10 times)
                                                     1: Freq. of PWM clock >= Freq. of APB clock                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t pool       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by BIT_PWM_INDREAD_IDX. This bit is cleared
                                                     by HW when reading is finished and indicates REG_PERI_PWM_INDREAD_DUTY
                                                     is ready.                                                                 */
    } indread_idx_b;
  } ;
  
  union {
    __IOM uint32_t indread_duty;                /*!< (@ 0x00000014) PWM Auto Adjusted Duty Indirect Read Register              */
    
    struct {
      __IOM uint32_t pwm_duty   : 12;           /*!< [11..0] This field is used to read the auto adjusted duty size
                                                     of the PWM which is assigned by the pwm_sel. The SW should
                                                     assign the PWM to read by write the pwm_sel and then read
                                                     this field to get the current duty size of the specified
                                                     PWM.                                                                      */
    } indread_duty_b;
  } ;
} PWM_COMM_Type;                                /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Width Modulation 0 (PWM0)
  */

typedef struct {                                /*!< (@ 0xA0003020) PWM0 Structure                                             */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) PWM Control Register                                       */
    
    struct {
      __IOM uint32_t duty       : 12;           /*!< [11..0] The on-duty duration of PWM pulse. The time unit is
                                                     configured by the GTIMER which is specified by clk_sel
                                                     field. It can be written at any time, but HW will apply
                                                     the changing at PWM enable time or at the end of PWM period.              */
      __IOM uint32_t clk_sel    : 4;            /*!< [15..12] The tick source selection, G-timer 0 ~ 7 or SClk: 0:
                                                     GTIMER 0 1: GTIMER 1 ... 7: GTIMER 7 8: sclk                              */
      __IM  uint32_t cur_duty   : 12;           /*!< [27..16] The current duty size which is adjusted by the duty
                                                     auto-adjustment HW. The SW can read this field to know
                                                     the current duty size. However, the latest duty size may
                                                     not be sync to this field on time or the value may transition
                                                     while the SW is reading this field. So use in-direct read
                                                     method to read the duty size is more save and is suggested.               */
      __IOM uint32_t period_ie  : 1;            /*!< [28..28] This bit control the PWM period end interrupt enable
                                                     (1) or disable (0). When the PWM period end interrupt is
                                                     enabled, the PWM HW will assert the interrupt on every
                                                     PWM period end time. This interrupt status can be read
                                                     from pwm_int_status.                                                      */
      __IM  uint32_t run_sts    : 1;            /*!< [29..29] The PWM output running status: 0: PWM output is paused
                                                     1: the PWM output is running.                                             */
      __IOM uint32_t pause      : 1;            /*!< [30..30] The paus control: 0: Normal running 1: To pause the
                                                     PWM out at current PWM period end. Since the PWM output
                                                     is not stopped immediately, the software can poll the BIT_PERI_PWMx_RUNST
                                                     to know the PWM out is still running or is paused.                        */
      __IOM uint32_t ctrl_set   : 1;            /*!< [31..31] SW can change setting only at ctrl_set = 0, and set
                                                     ctrl_set = 1 after changing PWM Ctrl. HW will clear ctrl_set
                                                     bit after changing PWM Ctrl. PS. If this PWM is disabled
                                                     (PWMx_EN=0), the HW will not clear this bit. PS. if this
                                                     bit is asserted and the duty auto adjustment is enabled,
                                                     when the PWM is enabled the HW will updates its duty at
                                                     the 1st PWM period and then start the duty adjustment at
                                                     2nd PWM period.                                                           */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t timing_ctrl;                 /*!< (@ 0x00000004) PWM Timing Control Register                                */
    
    struct {
      __IOM uint32_t period     : 12;           /*!< [11..0] The period of PWM pulse. The time unit is configured
                                                     by the GTIMER which is specified by the clk_sel field.
                                                     It can be written at any time, but the HW will apply the
                                                     changing at PWM enable time or at the end of PWM period.                  */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_start : 12;           /*!< [27..16] The start of ON duration of PWM pulse in the period.
                                                     The time unit is the same as PWM period. It can be written
                                                     at any time, but HW change setting only at PWM enable and
                                                     the end of period.                                                        */
    } timing_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_ctrl;               /*!< (@ 0x00000008) PWM Duty Auto Adjustment Control Register                  */
    
    struct {
      __IOM uint32_t duty_dec_step : 10;        /*!< [9..0] The Duty Decreasing Step size of the Duty Auto Adjustment.         */
      __IM  uint32_t            : 2;
      __IOM uint32_t duty_inc_step : 10;        /*!< [21..12] The Duty Increasing Step size of the Duty Auto Adjustment        */
      __IM  uint32_t            : 5;
      __IOM uint32_t duty_dn_lim_ie : 1;        /*!< [27..27] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Down Limit.                                                           */
      __IOM uint32_t duty_up_lim_ie : 1;        /*!< [28..28] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Up Limit.                                                             */
      __IOM uint32_t adj_loop_en : 1;           /*!< [29..29] This bit is used to enable the Duty Auto Adjustment
                                                     Loop mode. 0: Disable 1: Enable If the Loop Mode is enabled,
                                                     reverse the Duty Auto Adjustment direction when the adjusted
                                                     Duty reach the Up Limit or the Down Limit.                                */
      __IOM uint32_t adj_dir    : 1;            /*!< [30..30] This bit is used to set the Duty Ato Adjustment direction.
                                                     0: Decrease Duty 1: Increase Duty                                         */
      __IOM uint32_t adj_en     : 1;            /*!< [31..31] This bit is used to enable the Duty Ato Adjustment.
                                                     0: Disable 1: Enable PS. If this bit is 1, the duty of
                                                     the auto adjustment will override the duty setting in the
                                                     pwm_ctrl register.                                                        */
    } auto_adj_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_limit;              /*!< (@ 0x0000000C) PWM Duty Auto Adjustment Limit Register                    */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 12;      /*!< [11..0] The down limit (in ticks) of the duty period for the
                                                     duty ratio auto adjustment                                                */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_adj_up_lim : 12;      /*!< [27..16] The up limit of the duty period for the duty ratio
                                                     auto adjustment                                                           */
    } auto_adj_limit_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_cycle;              /*!< (@ 0x00000010) PWM Duty Auto Adjustment Cycle Count Register              */
    
    struct {
      __IOM uint32_t adj_cycles : 12;           /*!< [11..0] The Cycle Count of the Duty Auto Adjustment. The Duty
                                                     size will be increased/decreased with a step size every
                                                     Cycle Count of PWM period                                                 */
    } auto_adj_cycle_b;
  } ;
} PWM0_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief 10-channel ADC with 10-bit resolution (ADC)
  */

typedef struct {                                /*!< (@ 0xA0010000) ADC Structure                                              */
  
  union {
    __IOM uint32_t conf;                        /*!< (@ 0x00000000) ADC Configuration Register                                 */
    
    struct {
      __IOM uint32_t ref_in_sel : 1;            /*!< [0..0] ADC reference voltage input.                                       */
      __IOM uint32_t op_mod     : 3;            /*!< [3..1] ADC operation mode. This field is to control ADC operation
                                                     mode.                                                                     */
      __IOM uint32_t cvlist_len : 4;            /*!< [7..4] ADC conversion list length. This field defines the number
                                                     of items in ADC conversion channel list. 0 is for 1 item
                                                     in list. 1 is for 2 items in list.                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t en         : 1;            /*!< [9..9] ADC enable control. This bit is to control ADC is enable
                                                     or not.                                                                   */
    } conf_b;
  } ;
  
  union {
    __IOM uint32_t in_type;                     /*!< (@ 0x00000004) ADC Input Type Register                                    */
    
    struct {
      __IOM uint32_t ch0        : 1;            /*!< [0..0] ADC channel 0 input type.                                          */
      __IOM uint32_t ch1        : 1;            /*!< [1..1] ADC channel 1 input type.                                          */
      __IOM uint32_t ch2        : 1;            /*!< [2..2] ADC channel 2 input type.                                          */
      __IOM uint32_t ch3        : 1;            /*!< [3..3] ADC channel 3 input type.                                          */
      __IOM uint32_t ch4        : 1;            /*!< [4..4] ADC channel 4 input type.                                          */
      __IOM uint32_t ch5        : 1;            /*!< [5..5] ADC channel 5 input type.                                          */
      __IM  uint32_t ch6        : 1;            /*!< [6..6] ADC channel 6 input type.                                          */
      __IM  uint32_t ch7        : 1;            /*!< [7..7] ADC channel 7 input type.                                          */
      __IM  uint32_t ch8        : 1;            /*!< [8..8] ADC channel 8 input type.                                          */
      __IM  uint32_t ch9        : 1;            /*!< [9..9] ADC channel 9 input type.                                          */
    } in_type_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch0;                 /*!< (@ 0x00000008) ADC Channel 0 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 0 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 0 comparison high threshold.                         */
    } comp_th_ch0_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch1;                 /*!< (@ 0x0000000C) ADC Channel 1 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 1 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 1 comparison high threshold.                         */
    } comp_th_ch1_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch2;                 /*!< (@ 0x00000010) ADC Channel 2 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 2 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 2 comparison high threshold.                         */
    } comp_th_ch2_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch3;                 /*!< (@ 0x00000014) ADC Channel 3 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 3 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 3 comparison high threshold.                         */
    } comp_th_ch3_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch4;                 /*!< (@ 0x00000018) ADC Channel 4 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 4 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 4 comparison high threshold.                         */
    } comp_th_ch4_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch5;                 /*!< (@ 0x0000001C) ADC Channel 5 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 5 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 5 comparison high threshold.                         */
    } comp_th_ch5_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch6;                 /*!< (@ 0x00000020) ADC Channel 6 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 6 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 6 comparison high threshold.                         */
    } comp_th_ch6_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch7;                 /*!< (@ 0x00000024) ADC Channel 7 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 7 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 7 comparison high threshold.                         */
    } comp_th_ch7_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch8;                 /*!< (@ 0x00000028) ADC Channel 8 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 8 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 8 comparison high threshold.                         */
    } comp_th_ch8_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch9;                 /*!< (@ 0x0000002C) ADC Channel 9 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 10;           /*!< [9..0] ADC channel 9 comparison low threshold.                            */
      __IM  uint32_t            : 6;
      __IOM uint32_t th_h       : 10;           /*!< [25..16] ADC channel 9 comparison high threshold.                         */
    } comp_th_ch9_b;
  } ;
  
  union {
    __IOM uint32_t comp_ctrl;                   /*!< (@ 0x00000030) ADC Comparison Control Register                            */
    
    struct {
      __IOM uint32_t ch0        : 2;            /*!< [1..0] This field controls that ADC channel 0 comparison criterion.       */
      __IOM uint32_t ch1        : 2;            /*!< [3..2] This field controls that ADC channel 1 comparison criterion.       */
      __IOM uint32_t ch2        : 2;            /*!< [5..4] This field controls that ADC channel 2 comparison criterion.       */
      __IOM uint32_t ch3        : 2;            /*!< [7..6] This field controls that ADC channel 3 comparison criterion.       */
      __IOM uint32_t ch4        : 2;            /*!< [9..8] This field controls that ADC channel 4 comparison criterion.       */
      __IOM uint32_t ch5        : 2;            /*!< [11..10] This field controls that ADC channel 5 comparison criterion.     */
      __IOM uint32_t ch6        : 2;            /*!< [13..12] This field controls that ADC channel 6 comparison criterion.     */
      __IOM uint32_t ch7        : 2;            /*!< [15..14] This field controls that ADC channel 7 comparison criterion.     */
      __IOM uint32_t ch8        : 2;            /*!< [17..16] This field controls that ADC channel 8 comparison criterion.     */
      __IOM uint32_t ch9        : 2;            /*!< [19..18] This field controls that ADC channel 9 comparison criterion.     */
    } comp_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t comp_sts;                    /*!< (@ 0x00000034) ADC Comparison Status Register                             */
    
    struct {
      __IM  uint32_t ch0        : 2;            /*!< [1..0] This field reflects comparison result of chnnel 0 immediately.     */
      __IM  uint32_t ch1        : 2;            /*!< [3..2] This field reflects comparison result of chnnel 1 immediately.     */
      __IM  uint32_t ch2        : 2;            /*!< [5..4] This field reflects comparison result of chnnel 2 immediately.     */
      __IM  uint32_t ch3        : 2;            /*!< [7..6] This field reflects comparison result of chnnel 3 immediately.     */
      __IM  uint32_t ch4        : 2;            /*!< [9..8] This field reflects comparison result of chnnel 4 immediately.     */
      __IM  uint32_t ch5        : 2;            /*!< [11..10] This field reflects comparison result of chnnel 5 immediately.   */
      __IM  uint32_t ch6        : 2;            /*!< [13..12] This field reflects comparison result of chnnel 6 immediately.   */
      __IM  uint32_t ch7        : 2;            /*!< [15..14] This field reflects comparison result of chnnel 7 immediately.   */
      __IM  uint32_t ch8        : 2;            /*!< [17..16] This field reflects comparison result of chnnel 8 immediately.   */
      __IM  uint32_t ch9        : 2;            /*!< [19..18] This field reflects comparison result of chnnel 9 immediately.   */
    } comp_sts_b;
  } ;
  
  union {
    __IOM uint32_t chsw_list_0;                 /*!< (@ 0x00000038) ADC Channel Swtich List 0 Register                         */
    
    struct {
      __IOM uint32_t chsw_0     : 4;            /*!< [3..0] This field defines 1st channel in channel switch list.             */
      __IOM uint32_t chsw_1     : 4;            /*!< [7..4] This field defines 2nd channel in channel switch list.             */
      __IOM uint32_t chsw_2     : 4;            /*!< [11..8] This field defines 3rd channel in channel switch list.            */
      __IOM uint32_t chsw_3     : 4;            /*!< [15..12] This field defines 4th channel in channel switch list.           */
      __IOM uint32_t chsw_4     : 4;            /*!< [19..16] This field defines 5th channel in channel switch list.           */
      __IOM uint32_t chsw_5     : 4;            /*!< [23..20] This field defines 6th channel in channel switch list.           */
      __IOM uint32_t chsw_6     : 4;            /*!< [27..24] This field defines 7th channel in channel switch list.           */
      __IOM uint32_t chsw_7     : 4;            /*!< [31..28] This field defines 8th channel in channel switch list.           */
    } chsw_list_0_b;
  } ;
  
  union {
    __IOM uint32_t chsw_list_1;                 /*!< (@ 0x0000003C) ADC Channel Swtich List 1 Register                         */
    
    struct {
      __IOM uint32_t chsw_8     : 4;            /*!< [3..0] This field defines 9th channel in channel switch list.             */
      __IOM uint32_t chsw_9     : 4;            /*!< [7..4] This field defines 10th channel in channel switch list.            */
      __IOM uint32_t chsw_10    : 4;            /*!< [11..8] This field defines 11th channel in channel switch list.           */
      __IOM uint32_t chsw_11    : 4;            /*!< [15..12] This field defines 12th channel in channel switch list.          */
      __IOM uint32_t chsw_12    : 4;            /*!< [19..16] This field defines 13th channel in channel switch list.          */
      __IOM uint32_t chsw_13    : 4;            /*!< [23..20] This field defines 14th channel in channel switch list.          */
      __IOM uint32_t chsw_14    : 4;            /*!< [27..24] This field defines 15th channel in channel switch list.          */
      __IOM uint32_t chsw_15    : 4;            /*!< [31..28] This field defines 16th channel in channel switch list.          */
    } chsw_list_1_b;
  } ;
  
  union {
    __IOM uint32_t rst_list;                    /*!< (@ 0x00000040) ADC Reset List Register                                    */
    
    struct {
      __IOM uint32_t rst_list   : 1;            /*!< [0..0] This bit is to reset channel switch list or not.                   */
    } rst_list_b;
  } ;
  
  union {
    __IOM uint32_t auto_chsw_ctrl;              /*!< (@ 0x00000044) ADC Auto Channel Switch Control Register                   */
    
    struct {
      __IOM uint32_t auto_chsw_en : 1;          /*!< [0..0] This bit controls the automatic channel switch enabled
                                                     or not.                                                                   */
    } auto_chsw_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t sw_trig;                     /*!< (@ 0x00000048) ADC Software Trigger Register                              */
    
    struct {
      __IOM uint32_t sw_trig    : 1;            /*!< [0..0] This bit controls the ADC module to do a conersion.                */
    } sw_trig_b;
  } ;
  
  union {
    __IM  uint32_t last_item;                   /*!< (@ 0x0000004C) ADC Last Item Register                                     */
    
    struct {
      __IM  uint32_t last_item  : 4;            /*!< [3..0] This field records the last conversion list item that
                                                     a conversion is done for.                                                 */
    } last_item_b;
  } ;
  
  union {
    __IM  uint32_t sts;                         /*!< (@ 0x00000050) ADC Busy_Ready Status Register                             */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] This bit reflects the ADC is busy or not.                          */
      __IM  uint32_t full       : 1;            /*!< [1..1] This bit reflects the ADC FIFO is full or not.                     */
      __IM  uint32_t empty      : 1;            /*!< [2..2] This bit reflects the ADC FIFO is empty or not.                    */
    } sts_b;
  } ;
  
  union {
    __IOM uint32_t intr_ctrl;                   /*!< (@ 0x00000054) ADC Interrupt Control Register                             */
    
    struct {
      __IOM uint32_t it_cvlist_end_en : 1;      /*!< [0..0] This bit controls the interrupt is enbled or not when
                                                     a conversion of the last channel in the list is done.                     */
      __IOM uint32_t it_cv_end_en : 1;          /*!< [1..1] This bit controls the interrupt is enbled or not every
                                                     time a conversion is done.                                                */
      __IOM uint32_t it_chcv_end_en : 1;        /*!< [2..2] This bit controls the interrupt is enbled or not when
                                                     a particular channel conversion is done.                                  */
      __IOM uint32_t it_fifo_full_en : 1;       /*!< [3..3] This bit controls the interrupt is enabled or not when
                                                     a FIFO full state takes place.                                            */
      __IOM uint32_t it_fifo_over_en : 1;       /*!< [4..4] This bit controls the interrupt is enabled or not when
                                                     a FIFO overflow state takes place.                                        */
      __IOM uint32_t it_fifo_empty_en : 1;      /*!< [5..5] This bit controls the interrupt is enabled or not when
                                                     a FIFO empty state takes place.                                           */
      __IOM uint32_t it_dat_ovw_en : 1;         /*!< [6..6] This bit controls the interrupt is enabled or not when
                                                     a data overwritten situation takes place.                                 */
      __IOM uint32_t it_err_en  : 1;            /*!< [7..7] This bit controls the interrupt is enabled or not when
                                                     an error state takes place.                                               */
      __IOM uint32_t it_comp_ch0_en : 1;        /*!< [8..8] This bit controls the interrupt is enabled or not when
                                                     channel 0 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch1_en : 1;        /*!< [9..9] This bit controls the interrupt is enabled or not when
                                                     channel 1 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch2_en : 1;        /*!< [10..10] This bit controls the interrupt is enabled or not when
                                                     channel 2 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch3_en : 1;        /*!< [11..11] This bit controls the interrupt is enabled or not when
                                                     channel 3 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch4_en : 1;        /*!< [12..12] This bit controls the interrupt is enabled or not when
                                                     channel 4 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch5_en : 1;        /*!< [13..13] This bit controls the interrupt is enabled or not when
                                                     channel 5 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch6_en : 1;        /*!< [14..14] This bit controls the interrupt is enabled or not when
                                                     channel 6 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch7_en : 1;        /*!< [15..15] This bit controls the interrupt is enabled or not when
                                                     channel 7 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch8_en : 1;        /*!< [16..16] This bit controls the interrupt is enabled or not when
                                                     channel 8 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch9_en : 1;        /*!< [17..17] This bit controls the interrupt is enabled or not when
                                                     channel 9 comparison criterion matches.                                   */
    } intr_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t intr_raw_sts;                /*!< (@ 0x00000058) ADC Interrupt RAW Status Register                          */
    
    struct {
      __IM  uint32_t it_cvlist_end : 1;         /*!< [0..0] This bit is the raw status of channel conversion list
                                                     end interrupt.                                                            */
      __IM  uint32_t it_cv_end  : 1;            /*!< [1..1] This bit is the raw status of each conversion end interrupt.       */
      __IM  uint32_t it_chcv_end : 1;           /*!< [2..2] This bit is the raw status of particular channel conversion
                                                     end interrupt.                                                            */
      __IM  uint32_t it_fifo_full : 1;          /*!< [3..3] This bit is the raw status of FIFO full interrupt.                 */
      __IM  uint32_t it_fifo_over : 1;          /*!< [4..4] This bit is the raw status of FIFO overflow interrupt.             */
      __IM  uint32_t it_fifo_empty : 1;         /*!< [5..5] This bit is the raw status of FIFO empty interrupt.                */
      __IM  uint32_t it_dat_ovw : 1;            /*!< [6..6] This bit is the raw status of global data register overwritten
                                                     interrupt.                                                                */
      __IM  uint32_t it_err     : 1;            /*!< [7..7] This bit is the raw status of error interrupt.                     */
      __IM  uint32_t it_comp_ch0 : 1;           /*!< [8..8] This bit is the raw status of channel 0 comparison interrupt.      */
      __IM  uint32_t it_comp_ch1 : 1;           /*!< [9..9] This bit is the raw status of channel 1 comparison interrupt.      */
      __IM  uint32_t it_comp_ch2 : 1;           /*!< [10..10] This bit is the raw status of channel 2 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch3 : 1;           /*!< [11..11] This bit is the raw status of channel 3 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch4 : 1;           /*!< [12..12] This bit is the raw status of channel 4 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch5 : 1;           /*!< [13..13] This bit is the raw status of channel 5 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch6 : 1;           /*!< [14..14] This bit is the raw status of channel 6 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch7 : 1;           /*!< [15..15] This bit is the raw status of channel 7 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch8 : 1;           /*!< [16..16] This bit is the raw status of channel 8 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch9 : 1;           /*!< [17..17] This bit is the raw status of channel 9 comparison
                                                     interrupt.                                                                */
    } intr_raw_sts_b;
  } ;
  
  union {
    __IOM uint32_t intr_sts;                    /*!< (@ 0x0000005C) ADC Interrupt Status Register                              */
    
    struct {
      __IOM uint32_t it_cvlist_end : 1;         /*!< [0..0] This bit is the status of channel conversion list end
                                                     interrupt.                                                                */
      __IOM uint32_t it_cv_end  : 1;            /*!< [1..1] This bit is the status of each conversion end interrupt.           */
      __IOM uint32_t it_chcv_end : 1;           /*!< [2..2] This bit is the status of particular channel conversion
                                                     end interrupt.                                                            */
      __IOM uint32_t it_fifo_full : 1;          /*!< [3..3] This bit is the status of FIFO full interrupt.                     */
      __IOM uint32_t it_fifo_over : 1;          /*!< [4..4] This bit is the status of FIFO overflow interrupt.                 */
      __IOM uint32_t it_fifo_empty : 1;         /*!< [5..5] This bit is the status of FIFO empty interrupt.                    */
      __IOM uint32_t it_dat_ovw : 1;            /*!< [6..6] This bit is the status of global data register overwritten
                                                     interrupt.                                                                */
      __IOM uint32_t it_err     : 1;            /*!< [7..7] This bit is the status of error interrupt.                         */
      __IOM uint32_t it_comp_ch0 : 1;           /*!< [8..8] This bit is the status of channel 0 comparison interrupt.          */
      __IOM uint32_t it_comp_ch1 : 1;           /*!< [9..9] This bit is the status of channel 1 comparison interrupt.          */
      __IOM uint32_t it_comp_ch2 : 1;           /*!< [10..10] This bit is the status of channel 2 comparison interrupt.        */
      __IOM uint32_t it_comp_ch3 : 1;           /*!< [11..11] This bit is the status of channel 3 comparison interrupt.        */
      __IOM uint32_t it_comp_ch4 : 1;           /*!< [12..12] This bit is the status of channel 4 comparison interrupt.        */
      __IOM uint32_t it_comp_ch5 : 1;           /*!< [13..13] This bit is the status of channel 5 comparison interrupt.        */
      __IOM uint32_t it_comp_ch6 : 1;           /*!< [14..14] This bit is the status of channel 6 comparison interrupt.        */
      __IOM uint32_t it_comp_ch7 : 1;           /*!< [15..15] This bit is the status of channel 7 comparison interrupt.        */
      __IOM uint32_t it_comp_ch8 : 1;           /*!< [16..16] This bit is the status of channel 8 comparison interrupt.        */
      __IOM uint32_t it_comp_ch9 : 1;           /*!< [17..17] This bit is the status of channel 9 comparison interrupt.        */
    } intr_sts_b;
  } ;
  
  union {
    __IOM uint32_t it_chno_con;                 /*!< (@ 0x00000060) ADC Conversion Interrupt Channel Number Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t it_chno_con : 4;           /*!< [3..0] This field defines that ADC module should send interrupt
                                                     signal to system when a conversion which of channel number
                                                     is the same as this field. This register is only valid
                                                     when BIT_ADC_IT_CHCV_END_EN is set.                                       */
    } it_chno_con_b;
  } ;
  
  union {
    __IOM uint32_t full_lvl;                    /*!< (@ 0x00000064) ADC FIFO Full Level Register                               */
    
    struct {
      __IOM uint32_t full_lvl   : 6;            /*!< [5..0] This field defines the FIFO full entry threshold level
                                                     and it is used for FIFO full interrupt. It should be set
                                                     according to ADC FIFO depth.                                              */
    } full_lvl_b;
  } ;
  
  union {
    __IOM uint32_t trig_timer_sel;              /*!< (@ 0x00000068) ADC Trigger Timer Select Register                          */
    
    struct {
      __IOM uint32_t trig_timer_sel : 3;        /*!< [2..0] This field defines which timer channel would be used
                                                     to make ADC module do a conversion.                                       */
    } trig_timer_sel_b;
  } ;
  
  union {
    __IOM uint32_t dat_global;                  /*!< (@ 0x0000006C) ADC Global Data Register                                   */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of a conversion
                                                     channel in the list.                                                      */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in BIT_ADC_DATA_GLOBAL takes place.                             */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_glb.                                             */
      __IOM uint32_t ch         : 4;            /*!< [21..18] This field indicates which channel data is in dat_glb            */
    } dat_global_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch0;                     /*!< (@ 0x00000070) ADC Channel 0 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     0.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch0 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch0.                                             */
    } dat_ch0_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch1;                     /*!< (@ 0x00000074) ADC Channel 1 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     1.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch1 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch1.                                             */
    } dat_ch1_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch2;                     /*!< (@ 0x00000078) ADC Channel 2 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     2.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch2 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch2.                                             */
    } dat_ch2_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch3;                     /*!< (@ 0x0000007C) ADC Channel 3 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     3.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch3 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch3.                                             */
    } dat_ch3_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch4;                     /*!< (@ 0x00000080) ADC Channel 4 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     4.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch4 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch4.                                             */
    } dat_ch4_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch5;                     /*!< (@ 0x00000084) ADC Channel 5 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     5.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch5 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch5.                                             */
    } dat_ch5_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch6;                     /*!< (@ 0x00000088) ADC Channel 6 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     6.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch6 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch6.                                             */
    } dat_ch6_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch7;                     /*!< (@ 0x0000008C) ADC Channel 7 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     7.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch7 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch7.                                             */
    } dat_ch7_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch8;                     /*!< (@ 0x00000090) ADC Channel 8 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     8.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch8 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch8.                                             */
    } dat_ch8_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch9;                     /*!< (@ 0x00000094) ADC Channel 9 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 10;           /*!< [9..0] This field contains the newest conversion data of channel
                                                     9.                                                                        */
      __IM  uint32_t            : 6;
      __IOM uint32_t ovw        : 1;            /*!< [16..16] This bit indicates that there is a data overwritten
                                                     situation in dat_ch9 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [17..17] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch9.                                             */
    } dat_ch9_b;
  } ;
  
  union {
    __IOM uint32_t dma_con;                     /*!< (@ 0x00000098) ADC DMA Control Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] This bit controls that DMA function of ADC is enabled
                                                     or not.                                                                   */
      __IM  uint32_t            : 7;
      __IOM uint32_t lvl        : 6;            /*!< [13..8] This field defines the FIFO threshold level that ADC
                                                     module should make a DMA request to DMA module.                           */
    } dma_con_b;
  } ;
  
  union {
    __IOM uint32_t flr;                         /*!< (@ 0x0000009C) ADC FIFO Level Register                                    */
    
    struct {
      __IOM uint32_t flr        : 7;            /*!< [6..0] This field records the current ADC FIFO entry number.              */
    } flr_b;
  } ;
  
  union {
    __IOM uint32_t clr_fifo;                    /*!< (@ 0x000000A0) ADC Clear FIFO Register                                    */
    
    struct {
      __IOM uint32_t clr_fifo   : 1;            /*!< [0..0] This bit is used to clear FIFO contents and makes it
                                                     to the default status.                                                    */
    } clr_fifo_b;
  } ;
  
  union {
    __IOM uint32_t clk_div;                     /*!< (@ 0x000000A4) ADC Clock Division Register                                */
    
    struct {
      __IOM uint32_t clk_div    : 3;            /*!< [2..0] This field defines clock divider level of ADC module.              */
    } clk_div_b;
  } ;
  
  union {
    __IOM uint32_t dly_cnt;                     /*!< (@ 0x000000A8) ADC Delay Couont Register                                  */
    
    struct {
      __IOM uint32_t dly_cnt    : 4;            /*!< [3..0] This field defines channel switch delay count.                     */
    } dly_cnt_b;
  } ;
  
  union {
    __IOM uint32_t pwr_ctrl;                    /*!< (@ 0x000000AC) ADC Power Control Register                                 */
    
    struct {
      __IOM uint32_t pwr_ctrl   : 1;            /*!< [0..0] This field is used to power control.                               */
    } pwr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ana_ctrl;                    /*!< (@ 0x000000B0) ADC Analog Control Register                                */
    
    struct {
      __IOM uint32_t pwr_cut    : 1;            /*!< [0..0] This field is for analog usage.                                    */
      __IOM uint32_t pwr        : 1;            /*!< [1..1] This field is for analog usage.                                    */
      __IOM uint32_t pwr_ref    : 1;            /*!< [2..2] This field is for analog usage.                                    */
      __IOM uint32_t ck         : 1;            /*!< [3..3] This field is for analog usage.                                    */
      __IOM uint32_t dly        : 1;            /*!< [4..4] This field is for analog usage.                                    */
      __IOM uint32_t vref_sel   : 2;            /*!< [6..5] This field is for analog usage.                                    */
      __IOM uint32_t revckda    : 1;            /*!< [7..7] This field is for analog usage.                                    */
      __IOM uint32_t mpdec      : 2;            /*!< [9..8] This field is for analog usage.                                    */
      __IOM uint32_t meta       : 1;            /*!< [10..10] This field is for analog usage.                                  */
      __IOM uint32_t ch0_sel    : 2;            /*!< [12..11] This field is for analog usage.                                  */
      __IOM uint32_t ch1_sel    : 2;            /*!< [14..13] This field is for analog usage.                                  */
      __IOM uint32_t ch2_sel    : 2;            /*!< [16..15] This field is for analog usage.                                  */
      __IOM uint32_t ch3_sel    : 2;            /*!< [18..17] This field is for analog usage.                                  */
    } ana_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ana_sd;                      /*!< (@ 0x000000B4) ADC Signal Detect Register                                 */
    
    struct {
      __IOM uint32_t pwr_sd     : 1;            /*!< [0..0] This field is for analog usage.                                    */
      __IOM uint32_t sd_pse_edge : 1;           /*!< [1..1] This field is for analog usage.                                    */
      __IOM uint32_t sel_vrefh  : 5;            /*!< [6..2] This field is for analog usage.                                    */
      __IOM uint32_t sel_vrefl  : 5;            /*!< [11..7] This field is for analog usage.                                   */
      __IOM uint32_t pwr_bg     : 1;            /*!< [12..12] This field is for analog usage.                                  */
      __IOM uint32_t pwr_i      : 1;            /*!< [13..13] This field is for analog usage.                                  */
      __IOM uint32_t pwr_mbias  : 1;            /*!< [14..14] This field is for analog usage.                                  */
    } ana_sd_b;
  } ;
} ADC_Type;                                     /*!< Size = 184 (0xb8)                                                         */



/* =========================================================================================================================== */
/* ================                                           COMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief 4-channel comparator (COMP)
  */

typedef struct {                                /*!< (@ 0xA0010700) COMP Structure                                             */
  
  union {
    __IOM uint32_t ref_ch0;                     /*!< (@ 0x00000000) Comparator Channel 0 Reference Volatage Register           */
    
    struct {
      __IOM uint32_t ref0       : 8;            /*!< [7..0] This bit controls the comparator channel 0 internal reference
                                                     voltage 0.                                                                */
      __IM  uint32_t            : 8;
      __IOM uint32_t ref1       : 8;            /*!< [23..16] This bit controls the comparator channel 0 internal
                                                     reference voltage 1.                                                      */
    } ref_ch0_b;
  } ;
  
  union {
    __IOM uint32_t ref_ch1;                     /*!< (@ 0x00000004) Comparator Channel 1 Reference Volatage Register           */
    
    struct {
      __IOM uint32_t ref0       : 8;            /*!< [7..0] This bit controls the comparator channel 1 internal reference
                                                     voltage 0.                                                                */
      __IM  uint32_t            : 8;
      __IOM uint32_t ref1       : 8;            /*!< [23..16] This bit controls the comparator channel 1 internal
                                                     reference voltage 1.                                                      */
    } ref_ch1_b;
  } ;
  
  union {
    __IOM uint32_t ref_ch2;                     /*!< (@ 0x00000008) Comparator Channel 2 Reference Volatage Register           */
    
    struct {
      __IOM uint32_t ref0       : 8;            /*!< [7..0] This bit controls the comparator channel 2 internal reference
                                                     voltage 0.                                                                */
      __IM  uint32_t            : 8;
      __IOM uint32_t ref1       : 8;            /*!< [23..16] This bit controls the comparator channel 2 internal
                                                     reference voltage 1.                                                      */
    } ref_ch2_b;
  } ;
  
  union {
    __IOM uint32_t ref_ch3;                     /*!< (@ 0x0000000C) Comparator Channel 3 Reference Volatage Register           */
    
    struct {
      __IOM uint32_t ref0       : 8;            /*!< [7..0] This bit controls the comparator channel 3 internal reference
                                                     voltage 0.                                                                */
      __IM  uint32_t            : 8;
      __IOM uint32_t ref1       : 8;            /*!< [23..16] This bit controls the comparator channel 3 internal
                                                     reference voltage 1.                                                      */
    } ref_ch3_b;
  } ;
  
  union {
    __IOM uint32_t intr_ctrl;                   /*!< (@ 0x00000010) Comparator Interrupt Control Register                      */
    
    struct {
      __IOM uint32_t wk_adc_en_0 : 1;           /*!< [0..0] This bit controls whether the comparator channel 0 sends
                                                     wakeup signal or not when the criterion of wk_adc_ctrl_0
                                                     matches.                                                                  */
      __IOM uint32_t wk_adc_ctrl_0 : 2;         /*!< [2..1] This field defines the criterion of when comparator channel
                                                     0 should wake up ADC.                                                     */
      __IOM uint32_t wk_adc_en_1 : 1;           /*!< [3..3] This bit controls whether the comparator channel 1 sends
                                                     wakeup signal or not when the criterion of wk_adc_ctrl_1
                                                     matches.                                                                  */
      __IOM uint32_t wk_adc_ctrl_1 : 2;         /*!< [5..4] This field defines the criterion of when comparator channel
                                                     1 should wake up ADC.                                                     */
      __IOM uint32_t wk_adc_en_2 : 1;           /*!< [6..6] This bit controls whether the comparator channel 2 sends
                                                     wakeup signal or not when the criterion of wk_adc_ctrl_2
                                                     matches.                                                                  */
      __IOM uint32_t wk_adc_ctrl_2 : 2;         /*!< [8..7] This field defines the criterion of when comparator channel
                                                     2 should wake up ADC.                                                     */
      __IOM uint32_t wk_adc_en_3 : 1;           /*!< [9..9] This bit controls whether the comparator channel 3 sends
                                                     wakeup signal or not when the criterion of wk_adc_ctrl_3
                                                     matches.                                                                  */
      __IOM uint32_t wk_adc_ctrl_3 : 2;         /*!< [11..10] This field defines the criterion of when comparator
                                                     channel 3 should wake up ADC.                                             */
      __IM  uint32_t            : 4;
      __IOM uint32_t wk_sys_en_0 : 1;           /*!< [16..16] This bit controls whether the comparator channel 0
                                                     sends interrupt (wake up) signal or not when the criterion
                                                     of wk_sys_ctrl_3 matches.                                                 */
      __IOM uint32_t wk_sys_ctrl_0 : 2;         /*!< [18..17] This bit defines the criterion of when comparator channel
                                                     0 should interrupts (wake up) system.                                     */
      __IOM uint32_t wk_sys_en_1 : 1;           /*!< [19..19] This bit controls whether the comparator channel 1
                                                     sends interrupt (wake up) signal or not when the criterion
                                                     of wk_sys_ctrl_1 matches.                                                 */
      __IOM uint32_t wk_sys_ctrl_1 : 2;         /*!< [21..20] This bit defines the criterion of when comparator channel
                                                     1 should interrupts (wake up) system.                                     */
      __IOM uint32_t wk_sys_en_2 : 1;           /*!< [22..22] This bit controls whether the comparator channel 2
                                                     sends interrupt (wake up) signal or not when the criterion
                                                     of wk_sys_ctrl_2 matches.                                                 */
      __IOM uint32_t wk_sys_ctrl_2 : 2;         /*!< [24..23] This bit defines the criterion of when comparator channel
                                                     2 should interrupts (wake up) system.                                     */
      __IOM uint32_t wk_sys_en_3 : 1;           /*!< [25..25] This bit controls whether the comparator channel 3
                                                     sends interrupt (wake up) signal or not when the criterion
                                                     of wk_sys_ctrl_3 matches.                                                 */
      __IOM uint32_t wk_sys_ctrl_3 : 2;         /*!< [27..26] This bit defines the criterion of when comparator channel
                                                     3 should interrupts (wake up) system.                                     */
    } intr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t intr_sts;                    /*!< (@ 0x00000014) Comparator Interrupt Status Register                       */
    
    struct {
      __IOM uint32_t wk_adc_sts_0 : 1;          /*!< [0..0] This bit reflects if channle 0 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_adc_sts_1 : 1;          /*!< [3..3] This bit reflects if channle 1 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_adc_sts_2 : 1;          /*!< [6..6] This bit reflects if channle 2 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_adc_sts_3 : 1;          /*!< [9..9] This bit reflects if channle 3 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 6;
      __IOM uint32_t wk_sys_sts_0 : 1;          /*!< [16..16] This bit reflects if channle 0 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_sys_sts_1 : 1;          /*!< [19..19] This bit reflects if channle 1 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_sys_sts_2 : 1;          /*!< [22..22] This bit reflects if channle 2 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IOM uint32_t wk_sys_sts_3 : 1;          /*!< [25..25] This bit reflects if channle 3 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
    } intr_sts_b;
  } ;
  
  union {
    __IM  uint32_t intr_raw_sts;                /*!< (@ 0x00000018) Comparator Interrupt RAW Status Register                   */
    
    struct {
      __IM  uint32_t wk_adc_sts_0 : 1;          /*!< [0..0] This bit reflects if channle 0 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_adc_sts_1 : 1;          /*!< [3..3] This bit reflects if channle 1 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_adc_sts_2 : 1;          /*!< [6..6] This bit reflects if channle 2 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_adc_sts_3 : 1;          /*!< [9..9] This bit reflects if channle 3 of comparator module sent
                                                     a wake-up signal to ADC or not.                                           */
      __IM  uint32_t            : 6;
      __IM  uint32_t wk_sys_sts_0 : 1;          /*!< [16..16] This bit reflects if channle 0 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_sys_sts_1 : 1;          /*!< [19..19] This bit reflects if channle 1 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_sys_sts_2 : 1;          /*!< [22..22] This bit reflects if channle 2 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
      __IM  uint32_t            : 2;
      __IM  uint32_t wk_sys_sts_3 : 1;          /*!< [25..25] This bit reflects if channle 3 of comparator module
                                                     sent a interrupt (wake-up) signal to system or not.                       */
    } intr_raw_sts_b;
  } ;
  
  union {
    __IOM uint32_t chsw_list;                   /*!< (@ 0x0000001C) Comparator Channel Switch List Register                    */
    
    struct {
      __IOM uint32_t chsw_0     : 4;            /*!< [3..0] These bits defines the 1st channel to do a comparison
                                                     when the start-compare event takes place.                                 */
      __IOM uint32_t chsw_1     : 4;            /*!< [7..4] These bits defines the 2nd channel to do a comparison
                                                     when the start-compare event takes place.                                 */
      __IOM uint32_t chsw_2     : 4;            /*!< [11..8] These bits defines the 3rd channel to do a comparison
                                                     when the start-compare event takes place.                                 */
      __IOM uint32_t chsw_3     : 4;            /*!< [15..12] These bits defines the 4th channel to do a comparison
                                                     when the start-compare event takes place.                                 */
    } chsw_list_b;
  } ;
  
  union {
    __IOM uint32_t last_ch;                     /*!< (@ 0x00000020) Comparator Last Channel Register                           */
    
    struct {
      __IOM uint32_t last_ch    : 2;            /*!< [1..0] These bits reflects the last used channel.                         */
    } last_ch_b;
  } ;
  
  union {
    __IM  uint32_t busy;                        /*!< (@ 0x00000024) Comparator Busy Status Register                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] This bit reflects the comparator is busy or not.                   */
    } busy_b;
  } ;
  
  union {
    __IM  uint32_t ch_sts;                      /*!< (@ 0x00000028) Comparator Channel Status Register                         */
    
    struct {
      __IM  uint32_t ch_sts_0   : 2;            /*!< [1..0] This bit reflects the channel 0 comparison result.                 */
      __IM  uint32_t ch_sts_1   : 2;            /*!< [3..2] This bit reflects the channel 1 comparison result.                 */
      __IM  uint32_t ch_sts_2   : 2;            /*!< [5..4] This bit reflects the channel 2 comparison result.                 */
      __IM  uint32_t ch_sts_3   : 2;            /*!< [7..6] This bit reflects the channel 3 comparison result.                 */
    } ch_sts_b;
  } ;
  
  union {
    __IOM uint32_t auto_shut;                   /*!< (@ 0x0000002C) Comparator Auto Shutdown Register                          */
    
    struct {
      __IOM uint32_t auto_shut  : 1;            /*!< [0..0] This bit controls the comparator to disable the analog
                                                     module and mux automatically or not after the analog conversion
                                                     is done.                                                                  */
    } auto_shut_b;
  } ;
  
  union {
    __IOM uint32_t wk_timer;                    /*!< (@ 0x00000030) Comparator Wake Timer Control Reigster                     */
    
    struct {
      __IOM uint32_t wk_timer   : 1;            /*!< [0..0] This bit controls the external trigger source of general
                                                     timer enabled or not.                                                     */
    } wk_timer_b;
  } ;
  
  union {
    __IOM uint32_t wk_timer_sel;                /*!< (@ 0x00000034) Comparator Wake Timer Select Reigster                      */
    
    struct {
      __IOM uint32_t wk_timer_sel : 2;          /*!< [1..0] This three bits defines which timer channel would be
                                                     used to wake up the comparator.                                           */
    } wk_timer_sel_b;
  } ;
  
  union {
    __IOM uint32_t rst_list;                    /*!< (@ 0x00000038) Comparator Rest List Register                              */
    
    struct {
      __IOM uint32_t rst_list   : 1;            /*!< [0..0] This bit controls to reset the channel switch to default
                                                     state or not.                                                             */
    } rst_list_b;
  } ;
  
  union {
    __IOM uint32_t auto_sw_en;                  /*!< (@ 0x0000003C) Comparator Auto Channel Switch Enable Reigster             */
    
    struct {
      __IOM uint32_t auto_sw_en : 1;            /*!< [0..0] This bit controls the automatic channel swtich enabled
                                                     or disabled.                                                              */
    } auto_sw_en_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x00000040) Comparator Enable Control Register                         */
    
    struct {
      __IOM uint32_t enable     : 1;            /*!< [0..0] This bit is for comparator enable control.                         */
      __IOM uint32_t trig_en    : 1;            /*!< [1..1] This bit is a mulitple trigger control source. For software
                                                     trigger (when comparator auto channel switch register (offset:
                                                     0x3C) is NOT set and wake timer control is NOT set), this
                                                     bit is used to be a software trigger source. Each time
                                                     this bit is set to 1 from 0, it drives comparator to do
                                                     a channel comparison. For auto trigger, this bit is used
                                                     to drive comparator to start the auto channel switch operation.           */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t wk_shut_cnt;                 /*!< (@ 0x00000044) Comparator Shutdown Counter Register                       */
    
    struct {
      __IOM uint32_t wk_shut_cnt : 8;           /*!< [7..0] This eight bits defines how long to disable comparator
                                                     analog module when an external trigger event is sent to
                                                     the comparator. The count must include the comparator response
                                                     time to get a correct compare result.                                     */
    } wk_shut_cnt_b;
  } ;
} COMP_Type;                                    /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART port, 7/8 bit frame, 1/2 stop bit, up to 115200 baud rate (UART0)
  */

typedef struct {                                /*!< (@ 0xA0040000) UART0 Structure                                            */
  
  union {
    __IOM uint32_t dll;                         /*!< (@ 0x00000000) Divisor Latch (LS) Register                                */
    
    struct {
      __IOM uint32_t dll        : 8;            /*!< [7..0] Baud rate divisor-low register, accessable only when
                                                     DLAB = 1                                                                  */
    } dll_b;
  } ;
  
  union {
    union {
      __IOM uint32_t dlm;                       /*!< (@ 0x00000004) Divisor Latch (MS) Register                                */
      
      struct {
        __IOM uint32_t dlm      : 8;            /*!< [7..0] Baud rate divisor-high register, accessable only when
                                                     DLAB = 1                                                                  */
      } dlm_b;
    } ;
    
    union {
      __IOM uint32_t ier;                       /*!< (@ 0x00000004) Interrupt Enable Register                                  */
      
      struct {
        __IOM uint32_t erbi     : 1;            /*!< [0..0] Enable Received Data Available Interrupt (ERBFI) (rx
                                                     trigger)                                                                  */
        __IOM uint32_t etbei    : 1;            /*!< [1..1] Enable Transmitter FIFO Empty interrupt (ETBEI) (tx fifo
                                                     empty)                                                                    */
        __IOM uint32_t elsi     : 1;            /*!< [2..2] Enable Receiver Line Status Interrupt (ELSI) (receiver
                                                     line status)                                                              */
        __IOM uint32_t edssi    : 1;            /*!< [3..3] Enable Modem Status Interrupt (EDSSI) (modem status transition)    */
      } ier_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t iir;                       /*!< (@ 0x00000008) Interrupt Identification Register                          */
      
      struct {
        __IM  uint32_t int_pend : 1;            /*!< [0..0] Indicates that an interrupt is pending when it's logic
                                                     0. When it is 1, no interrupt is pending                                  */
        __IM  uint32_t int_id   : 3;            /*!< [3..1] Bit1 and Bit2 the two bits of the IIR are used to identify
                                                     the highest priority interrupt pending as indicated in
                                                     the following table Bit3: In the FIFO mode this bit is
                                                     set along with bit 2 when a timeout interrupt is pending.                 */
      } iir_b;
    } ;
    
    union {
      __IOM uint32_t fcr;                       /*!< (@ 0x00000008) FIFO Control Register                                      */
      
      struct {
        __OM  uint32_t en_rxfifo_err : 1;       /*!< [0..0] Set as 1 to enable the report of Error in RCVR FIFO field
                                                     in LSR bit [7]                                                            */
        __OM  uint32_t clear_rxfifo : 1;        /*!< [1..1] Writing a Logic 1 to Bit 1 clears the Receiver FIFO and
                                                     resets its logic. But it doesn't clear the shift register.
                                                     The 1 that is written to this bit position is self-clearing.              */
        __OM  uint32_t clear_txfifo : 1;        /*!< [2..2] Write 1 to this bit clears the Transmitter FIFO and resets
                                                     its logic. But the shift register is not cleared, The 1
                                                     that is written to this bit position is self-clearing.                    */
        __OM  uint32_t dma_mode : 1;            /*!< [3..3] Support DMA mode. (cooperate with DW DDMA in the data
                                                     path)                                                                     */
        __IM  uint32_t          : 1;
        __IOM uint32_t txfifo_low_level : 1;    /*!< [5..5] Define the Transmission FIFO Low Water Level Interrupt
                                                     trigger. 0: 4 byte 1: 8 bytes                                             */
        __IOM uint32_t rxfifo_trigger_level : 2;/*!< [7..6] Define the 32-entries Receiver FIFO Interrupt trigger
                                                     level 0~31 bytes 00: 1 byte 01: 8 bytes 10: 16 bytes 11:
                                                     30 bytes (for some device detect RTS de-assertion slower,
                                                     reserve more RX FIFO space to prevent RX FIFO overflow
                                                     )                                                                         */
      } fcr_b;
    } ;
  };
  
  union {
    __IOM uint32_t lcr;                         /*!< (@ 0x0000000C) Line Control Register                                      */
    
    struct {
      __IOM uint32_t wls0       : 1;            /*!< [0..0] Word length selection,                                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t stb        : 1;            /*!< [2..2] This bit specifies the number of Stop bits transmitted
                                                     and received in each serial character. 0: 1 stop bit. 1:
                                                     2 stop bits. Note that the receiver always checks the first
                                                     stop bit only.                                                            */
      __IOM uint32_t parity_en  : 1;            /*!< [3..3] Parity Enable                                                      */
      __IOM uint32_t even_parity_sel : 1;       /*!< [4..4] Even Parity select                                                 */
      __IOM uint32_t stick_parity_en : 1;       /*!< [5..5] Stick Parity enable control. LCR[5:4]: 00: Odd Parity
                                                     01: Even Parity 10: Stick Parity as 0 11: Stick Parity
                                                     as 1                                                                      */
      __IOM uint32_t break_ctrl : 1;            /*!< [6..6] Break Control bit. Break control bit causes a break condition
                                                     to be transmitted to the receiving UART.                                  */
      __IOM uint32_t dlab       : 1;            /*!< [7..7] Divisor Latch Access bit Note: DLL/DLM only can be access
                                                     when dlab bit = 1, IER only can be access when dlab bit
                                                     = 0. THR/RBR don't care about dlab bit value                              */
    } lcr_b;
  } ;
  
  union {
    __IOM uint32_t mcr;                         /*!< (@ 0x00000010) Modem Control Register                                     */
    
    struct {
      __IOM uint32_t dtr        : 1;            /*!< [0..0] Data Terminal Ready (DTR) signal control 0::DTR is logic
                                                     1 1::DTR is logic 0                                                       */
      __IOM uint32_t rts        : 1;            /*!< [1..1] Request to Send (RTS) signal control 0: RTS is logic
                                                     1 1: RTS is logic 0 The RTS output is controlled as following
                                                     equation: RTS_output = rts_en ? (~rts|FIFO_FlowCtrl):~rts                 */
      __IOM uint32_t out1       : 1;            /*!< [2..2] This bit controls the Output 1 (OUT1_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t out2       : 1;            /*!< [3..3] This bit controls the output 2 (OUT2_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t loopback_en : 1;           /*!< [4..4] LoopBack mode. This bit provides a local loopback feature
                                                     for diagnostic testing of the UART.                                       */
      __IOM uint32_t cts_en     : 1;            /*!< [5..5] CTS flow control enable (CTSE) This Bit (CTSE) is the
                                                     auto CTS flow control enable. When set (1), the auto CTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t rts_en     : 1;            /*!< [6..6] RTS flow control enable (RTSE) This Bit (RTSE) is the
                                                     auto RTS flow control enables. When set (1), the auto RTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t sw_cts     : 1;            /*!< [7..7] Software controlled CTS. The software can use this bit
                                                     to pause the UART transmission, just like the HW flow control.This
                                                     bit setting will effects the CTS flow-control: CTS = cts_en
                                                     ? (sw_cts | CTS_input) : sw_cts                                           */
    } mcr_b;
  } ;
  
  union {
    __IM  uint32_t lsr;                         /*!< (@ 0x00000014) Line Status Register                                       */
    
    struct {
      __IM  uint32_t rxfifo_datardy : 1;        /*!< [0..0] Data Ready (DR) indicator This bit is 1 when at least
                                                     one character has been received and transferred into the
                                                     FIFO. It be reset to logic 0 by reading all of the data
                                                     in the Receiver Buffer Register or the RX FIFO.                           */
      __IM  uint32_t overrun_err : 1;           /*!< [1..1] Overrun Error (OE) indicator. This bit is set (1) to
                                                     indicates that data in the RX FIFO was not read by the
                                                     CPU before the next character was transferred into the
                                                     RX FIFO,                                                                  */
      __IM  uint32_t parity_err : 1;            /*!< [2..2] Parity Error (PE) indicator. This bit is set to indicates
                                                     that the received data character does not have the correct
                                                     even or odd parity, as selected by the even-parity-select
                                                     bit.                                                                      */
      __IM  uint32_t framing_err : 1;           /*!< [3..3] Framing Error (FE) indicator. This bit is set when the
                                                     received character at the top of the FIFO did not have
                                                     a valid stop bit.                                                         */
      __IM  uint32_t break_err_int : 1;         /*!< [4..4] Break Interrupt (BI) indicator. This bit is set to logic
                                                     1 whenever the received data input is held in the Spacing
                                                     (logic 0) state for a longer than a full word transmission
                                                     time.                                                                     */
      __IM  uint32_t txfifo_empty : 1;          /*!< [5..5] TXFIFO empty indicator. It indicates that the Transmitter
                                                     FIFO is empty. This bit is set when the Transmitter FIFO
                                                     is empty; it is cleared when at least 1 byte is written
                                                     to the Transmitter FIFO.                                                  */
      __IM  uint32_t            : 1;
      __IM  uint32_t rxfifo_err : 1;            /*!< [7..7] Uart_rx_error. This bit is set when there is at least
                                                     on parity error, framing error or break indication in the
                                                     FIFO. It is clear when the CPU reads the LSR, if there
                                                     are no subsequent errors in the FIFO                                      */
    } lsr_b;
  } ;
  
  union {
    __IM  uint32_t msr;                         /*!< (@ 0x00000018) Modem Status Register                                      */
    
    struct {
      __IM  uint32_t d_cts      : 1;            /*!< [0..0] Delta Clear to Send (DCTS) indicator                               */
      __IM  uint32_t d_dsr      : 1;            /*!< [1..1] Delta Data Set Ready (DDSR) indicator                              */
      __IM  uint32_t teri       : 1;            /*!< [2..2] Trailing Edge of Ring Indicator (TERI) detector. The
                                                     RI line has changed its state from low to high state.                     */
      __IM  uint32_t d_dcd      : 1;            /*!< [3..3] Delta Data Carrier Detect (DDCD) indicator.                        */
      __IM  uint32_t r_cts      : 1;            /*!< [4..4] Complement of the CTS input or equals to RTS in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dsr      : 1;            /*!< [5..5] Complement of the DSR input or equals to DTR in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_ri       : 1;            /*!< [6..6] Complement of the RI input or equals to Out1 in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dcd      : 1;            /*!< [7..7] Complement of the DCD input or equals to Out2 in loopback
                                                     mode.                                                                     */
    } msr_b;
  } ;
  
  union {
    __IOM uint32_t scr;                         /*!< (@ 0x0000001C) Scratch Pad Register                                       */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t pin_lb_test : 1;           /*!< [3..3] For uart IP txd/rxd/rts/cts pin loopback test                      */
      __IM  uint32_t fl_frame_err : 1;          /*!< [4..4] Frame error flag                                                   */
      __IM  uint32_t fl_set_bi_err : 1;         /*!< [5..5] set_bi_err flag                                                    */
      __IOM uint32_t rx_break_int_en : 1;       /*!< [6..6] Rx break signal interrupt enable                                   */
      __IOM uint32_t rx_break_int_sts : 1;      /*!< [7..7] Rx break signal interrupt status, write 1 to this bit
                                                     will clear the interrupt pending status                                   */
      __IOM uint32_t dbg_sel    : 4;            /*!< [11..8] Debug port selection                                              */
      __IM  uint32_t            : 4;
      __IOM uint32_t xfactor_adj : 11;          /*!< [26..16] The ovsr_adj, one of factors of baud rate calculation            */
    } scr_b;
  } ;
  
  union {
    __IOM uint32_t stsr;                        /*!< (@ 0x00000020) STS Register                                               */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t reset_rcv  : 1;            /*!< [3..3] Reset Uart Receiver                                                */
      __IOM uint32_t xfactor    : 4;            /*!< [7..4] Factor of Baud rate calculation, the ovsr[3:0]                     */
      __IM  uint32_t            : 16;
      __IM  uint32_t dma_mode   : 1;            /*!< [24..24] dma_mode field of FCR bit[3]                                     */
      __IM  uint32_t fifo_en    : 1;            /*!< [25..25] fifo_en field of FCR bit[0]                                      */
      __IM  uint32_t txfifo_low_level : 1;      /*!< [26..26] txfifo_low_level in FCR bit[5], Define the Transmission
                                                     FIFO Low Water Level Interrupt trigger. 0: 4 byte 1: 8
                                                     bytes                                                                     */
      __IM  uint32_t rxfifo_trigger_level : 2;  /*!< [28..27] rxfifo_trigger_level in FCR bit[7:6], Define the 32-entries
                                                     Receiver FIFO Interrupt trigger level 0~31 bytes 00: 1
                                                     byte 01: 8 bytes 10: 16 bytes 11: 28 bytes (for some device
                                                     detect RTS de-assertion slower, reserve more RX FIFO space
                                                     to prevent RX FIFO overflow )                                             */
    } stsr_b;
  } ;
  
  union {
    union {
      __IM  uint32_t rbr;                       /*!< (@ 0x00000024) Receiver Buffer Register                                   */
      
      struct {
        __IM  uint32_t rxdata   : 8;            /*!< [7..0] Rx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially received.                                              */
      } rbr_b;
    } ;
    
    union {
      __OM  uint32_t thr;                       /*!< (@ 0x00000024) Transmitter Holder Register                                */
      
      struct {
        __OM  uint32_t txdata   : 8;            /*!< [7..0] Tx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially transmitted.                                           */
      } thr_b;
    } ;
  };
  
  union {
    __IOM uint32_t miscr;                       /*!< (@ 0x00000028) MISC Control Register                                      */
    
    struct {
      __IOM uint32_t irda_enable : 1;           /*!< [0..0] IRDA mode enable control. When set this bit as 1, the
                                                     UART is co-work with IRDA SIR mode. i.e., txd/rxd are irda
                                                     signals.                                                                  */
      __IOM uint32_t txdma_en   : 1;            /*!< [1..1] TX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t rxdma_en   : 1;            /*!< [2..2] RX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t txdma_burstsize : 5;       /*!< [7..3] Txdma burstsize                                                    */
      __IOM uint32_t rxdma_burstsize : 6;       /*!< [13..8] Rxdma burstsize                                                   */
      __IOM uint32_t irda_tx_inv : 1;           /*!< [14..14] Invert irda_tx_o when this bit is 1.                             */
      __IOM uint32_t irda_rx_inv : 1;           /*!< [15..15] Invert irda_rx_i when this bit is 1.                             */
      __IOM uint32_t tx_en      : 1;            /*!< [16..16] The UART TX function.enable control                              */
    } miscr_b;
  } ;
  
  union {
    __IOM uint32_t txplsr;                      /*!< (@ 0x0000002C) IRDA SIR TX Pulse Width Control 0 Register                 */
    
    struct {
      __IOM uint32_t txpulse_lowbound_shiftval : 15;/*!< [14..0] The shift value of SIR tx pulse's left edge position.         */
      __IOM uint32_t lowbound_shiftright : 1;   /*!< [15..15] SIR TX pulse lower bond shift control.                           */
      __IOM uint32_t txpulse_upperbound_shiftval : 15;/*!< [30..16] The shift value of SIR tx pulse's right edge position.     */
      __IOM uint32_t Upperbound_shiftright : 1; /*!< [31..31] SIR TX pulse upper bond shift control.                           */
    } txplsr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t baudmonr;                    /*!< (@ 0x00000034) Baud Monitor Register                                      */
    
    struct {
      __IM  uint32_t min_fall_space : 12;       /*!< [11..0] Min_fall_space                                                    */
      __IM  uint32_t min_low_period : 12;       /*!< [23..12] Min_low_period                                                   */
      __IOM uint32_t falling_thresh : 6;        /*!< [29..24] Falling_thresh                                                   */
      __IM  uint32_t mon_data_vld : 1;          /*!< [30..30] The monitor data valid indication                                */
      __IOM uint32_t toggle_mon_en : 1;         /*!< [31..31] Baud monitor toggle bit enable.                                  */
    } baudmonr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t dbg2;                        /*!< (@ 0x0000003C) Debug Register                                             */
    
    struct {
      __IM  uint32_t dbg_uart   : 32;           /*!< [31..0] The debug port output value, depend on dbg_sel value
                                                     in SCR[2:0].                                                              */
    } dbg2_b;
  } ;
  
  union {
    __IOM uint32_t rfcr;                        /*!< (@ 0x00000040) RX Filter Control Register                                 */
    
    struct {
      __IOM uint32_t rf_len     : 1;            /*!< [0..0] Set the length of received data to be check. 0/1 = 1bytes/2bytes   */
      __IOM uint32_t rf_mask_en : 1;            /*!< [1..1] Enable the mask operation for received data.                       */
      __IOM uint32_t rf_cmp_op  : 2;            /*!< [3..2] Set the RX filter comparing rule. The matched condition
                                                     is listed as following table: RF_LEN = 0: RF_CMP_OP = 0
                                                     (AND) 1st byte = Magic Pattern1 1 (OR) (1st byte = Magic
                                                     Pattern1) OR (1st byte = Magic Pattern2) 2 (XOR) (1st byte
                                                     != Magic Pattern1) AND (1st byte != Magic Pattern2) RF_LEN
                                                     = 1: RF_CMP_OP = 0 (AND) (1st byte = Magic Pattern1) AND
                                                     (2nd byte = Magic Pattern2) 1 (OR) (2nd byte = Magic Pattern1)
                                                     OR (2nd byte = Magic Pattern2) 2 (XOR) (1st byte != Magic
                                                     Pattern1) AND (2nd byte != Magic Patte                                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t rf_en      : 1;            /*!< [7..7] RX Filter enable control                                           */
    } rfcr_b;
  } ;
  
  union {
    __IOM uint32_t rfmpr;                       /*!< (@ 0x00000044) RX Filter Magic Pattern Register                           */
    
    struct {
      __IOM uint32_t rf_mp1     : 8;            /*!< [7..0] The magic pattern1 for the 1st received byte checking.             */
      __IOM uint32_t rf_mp2     : 8;            /*!< [15..8] The magic pattern2 for the 2nd received byte checking.            */
    } rfmpr_b;
  } ;
  
  union {
    __IOM uint32_t rfmvr;                       /*!< (@ 0x00000048) RX Filter Mask Value Register                              */
    
    struct {
      __IOM uint32_t rf_mv1     : 8;            /*!< [7..0] The mask value for the 1st received byte.                          */
      __IOM uint32_t rf_mv2     : 8;            /*!< [15..8] The mask value for the 2nd received byte.                         */
    } rfmvr_b;
  } ;
  
  union {
    __IOM uint32_t rftor;                       /*!< (@ 0x0000004C) RX Filter Timeout Register                                 */
    
    struct {
      __IOM uint32_t rf_timeout : 20;           /*!< [19..0] Set the timeout value of the RX filter idle detection.
                                                     This value is number of ticks. A tick time is equal to
                                                     a UART bit time.                                                          */
    } rftor_b;
  } ;
  
  union {
    __IOM uint32_t rflvr;                       /*!< (@ 0x00000050) RX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t rx_fifo_lv : 6;            /*!< [5..0] The level of the RX FIFO. This value indicates the number
                                                     of data bytes in the RX FIFO.                                             */
    } rflvr_b;
  } ;
  
  union {
    __IOM uint32_t tflvr;                       /*!< (@ 0x00000054) TX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t tx_fifo_lv : 5;            /*!< [4..0] The level of the TX FIFO. This value indicates the number
                                                     of data bytes in the TX FIFO.                                             */
    } tflvr_b;
  } ;
  
  union {
    __IOM uint32_t visr;                        /*!< (@ 0x00000058) Vendor Interrupt Status Register                           */
    
    struct {
      __IOM uint32_t rf_match_patt : 1;         /*!< [0..0] The interrupt status of RX filter pattern checking matched.
                                                     Write 1 to clear this interrupt status. 0: Interrupt is
                                                     not pending. 1: Interrupt is pending.                                     */
      __IOM uint32_t rf_timeout : 1;            /*!< [1..1] This bit indicates the interrupt pending status of the
                                                     RX filter timeout occurred. The RX idle detection mechanism
                                                     is used to check whether the receiving is in idle state
                                                     for re-aquire pattern matching. This mechanism uses a timer
                                                     to monitor new data receiving. This timer will reload the
                                                     initial value whenever a new byte is received. If the timeout
                                                     occurred (timer value countdown to 0), the RX filter will
                                                     be reset to the initialed state and restart the first received
                                                     1 or 2 bytes checking.                                                    */
      __IOM uint32_t tx_fifo_lv : 1;            /*!< [2..2] This bit indicates the interrupt pending status of the
                                                     TX FIFO water level equal to the level setting. The software
                                                     can use this interrupt to know the TX FIFO water level
                                                     is low and refill the TX FIFO. To enable this interrupt,
                                                     IER bit[5] should be written as 1. Write 1 to this bit
                                                     will clear the pending status.                                            */
      __IOM uint32_t rx_idle_timeout : 1;       /*!< [3..3] This bit indicate the receiver idle timeout interrupt
                                                     pending status. Write 1 to this bit will clear the pending
                                                     status.                                                                   */
    } visr_b;
  } ;
  
  union {
    __IOM uint32_t vier;                        /*!< (@ 0x0000005C) Vendor Interrupt Enabling Control Register                 */
    
    struct {
      __IOM uint32_t rf_match_int_en : 1;       /*!< [0..0] The Rx filter pattern matched interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t rf_timeout_int_en : 1;     /*!< [1..1] The Rx filter idle timeout interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t tx_fifo_lv_int_en : 1;     /*!< [2..2] The TX FIFO water level interrupt enabling control: 1:
                                                     enable 0: disable                                                         */
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [3..3] The RX idle timeout interrupt enabling control: 1: enable
                                                     0: disable                                                                */
    } vier_b;
  } ;
  
  union {
    __IOM uint32_t ritor;                       /*!< (@ 0x00000060) RX Idle Timeout Register                                   */
    
    struct {
      __IOM uint32_t rxidle_timeout_value : 4;  /*!< [3..0] Time unit is the duration of a UART bit, depends on the
                                                     baud-rate setting. Default 0. 0: 8 bit time. (1*8) 1: 16
                                                     bit time. (2*8) 2: 32 bit time. (2^2*8) 3: 64 bit time.
                                                     (2^3*8) 4: 128 bit time. (2^4*8) 5: 256 bit time. (2^5*8)
                                                     6: 512 bit time. (2^6*8) 7: 1024 bit time. (2^7*8) 8: 2048
                                                     bit time. (2^8*8) 9: 4096 bit time. (2^9*8) 10: 8192 bit
                                                     time. (2^10*8) 11: 16384 bit time. (2^11*8) 12: 32768 bit
                                                     time. (2^12*8) 13: 65535 bit time. (2^13*8) 14: 131072
                                                     bit time. (2^14*8) 15: 262144 bit time. (2^15*8)                          */
      __IM  uint32_t            : 27;
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [31..31] RX idle timeout enable, default 0.                               */
    } ritor_b;
  } ;
} UART0_Type;                                   /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                            I2C                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C with 7-bit/10-bit SS/FS mode in master and slave mode transmission (I2C)
  */

typedef struct {                                /*!< (@ 0xA0044000) I2C Structure                                              */
  
  union {
    __IOM uint32_t con;                         /*!< (@ 0x00000000) I2C Control Register                                       */
    
    struct {
      __IOM uint32_t mst_mod    : 1;            /*!< [0..0] This bit controls whether the I2C Module master is enabled.        */
      __IOM uint32_t spd        : 2;            /*!< [2..1] These bits control at which speed the I2C Module operates.         */
      __IOM uint32_t slv_10bit_addr : 1;        /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     I2C Module responds to 7- or 10-bit addresses.                            */
      __IOM uint32_t mst_10bit_addr : 1;        /*!< [4..4] This bit controls whether the I2C Module starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.                  */
      __IOM uint32_t rstrt_en   : 1;            /*!< [5..5] This bit determines whether RESTART conditions may be
                                                     sent when acting as a master.                                             */
      __IOM uint32_t slv_dis    : 1;            /*!< [6..6] This bit controls whether I2C has its slave 0 disabled.            */
      __IOM uint32_t slv_dis_1  : 1;            /*!< [7..7] This bit controls whether I2C has its slave 1 disabled.            */
    } con_b;
  } ;
  
  union {
    __IOM uint32_t tar;                         /*!< (@ 0x00000004) I2C Target Address Register                                */
    
    struct {
      __IOM uint32_t tar        : 10;           /*!< [9..0] This is the target address for any master transaction.             */
      __IOM uint32_t gc_start_byte : 1;         /*!< [10..10] If bit 11 (SPECIAL) is set to 1, then this bit indicates
                                                     whether a General Call or START byte command is to be performed
                                                     by the I2C Module. 0: General Call 1: START BYTE                          */
      __IOM uint32_t spec       : 1;            /*!< [11..11] This bit indicates whether software performs a General
                                                     Call or START BYTE command.                                               */
      __IOM uint32_t tar_10bit_addr : 1;        /*!< [12..12] This bit controls whether the I2C Module starts its
                                                     transfers in 7-or 10-bit addressing mode when acting as
                                                     a master.                                                                 */
    } tar_b;
  } ;
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t sar        : 10;           /*!< [9..0] The sar holds the slave address when the I2C is operating
                                                     as a slave.                                                               */
    } sar_b;
  } ;
  
  union {
    __IOM uint32_t hs_maddr;                    /*!< (@ 0x0000000C) I2C High Speed Master Code Address Register                */
    
    struct {
      __IOM uint32_t hs_maddr   : 3;            /*!< [2..0] This bit field holds the value of the I2C HS mode master
                                                     code                                                                      */
    } hs_maddr_b;
  } ;
  
  union {
    __IOM uint32_t dat_cmd;                     /*!< (@ 0x00000010) I2C Data Buffer and Command Register                       */
    
    struct {
      __IOM uint32_t dat        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus.                                                  */
      __OM  uint32_t cmd        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.          */
      __OM  uint32_t stp        : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __OM  uint32_t rstrt      : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.                                             */
      __OM  uint32_t null_dat   : 1;            /*!< [11..11] This bit controls whether to transfer slave address
                                                     only.                                                                     */
    } dat_cmd_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_hcnt;                 /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     standard speed.                                                           */
    } ss_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_lcnt;                 /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     standard speed.                                                           */
    } ss_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_hcnt;                 /*!< (@ 0x0000001C) Fast Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     fast speed.                                                               */
    } fs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_lcnt;                 /*!< (@ 0x00000020) Fast Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     fast speed.                                                               */
    } fs_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_hcnt;                 /*!< (@ 0x00000024) High Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high period count for
                                                     high speed.                                                               */
    } hs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_lcnt;                 /*!< (@ 0x00000028) High Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     high speed.                                                               */
    } hs_scl_lcnt_b;
  } ;
  
  union {
    __IM  uint32_t intr_stat;                   /*!< (@ 0x0000002C) I2C Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t intr_msk;                    /*!< (@ 0x00000030) I2C Interrupt Mask Register                                */
    
    struct {
      __IOM uint32_t rx_under   : 1;            /*!< [0..0] Correspond to intr_sts                                             */
      __IOM uint32_t rx_over    : 1;            /*!< [1..1] Correspond to intr_sts                                             */
      __IOM uint32_t rx_full    : 1;            /*!< [2..2] Correspond to intr_sts                                             */
      __IOM uint32_t tx_over    : 1;            /*!< [3..3] Correspond to intr_sts                                             */
      __IOM uint32_t tx_empty   : 1;            /*!< [4..4] Correspond to intr_sts                                             */
      __IOM uint32_t rd_req     : 1;            /*!< [5..5] Correspond to intr_sts                                             */
      __IOM uint32_t tx_abrt    : 1;            /*!< [6..6] Correspond to intr_sts                                             */
      __IOM uint32_t rx_done    : 1;            /*!< [7..7] Correspond to intr_sts                                             */
      __IOM uint32_t act        : 1;            /*!< [8..8] Correspond to intr_sts                                             */
      __IOM uint32_t stp_det    : 1;            /*!< [9..9] Correspond to intr_sts                                             */
      __IOM uint32_t strt_det   : 1;            /*!< [10..10] Correspond to intr_sts                                           */
      __IOM uint32_t gen_call   : 1;            /*!< [11..11] Correspond to intr_sts                                           */
      __IOM uint32_t addr0_match : 1;           /*!< [12..12] Correspond to intr_sts                                           */
      __IOM uint32_t addr1_match : 1;           /*!< [13..13] Correspond to intr_sts                                           */
      __IOM uint32_t ms_code_det : 1;           /*!< [14..14] Correspond to intr_sts                                           */
      __IOM uint32_t dma_i2c_done : 1;          /*!< [15..15] Correspond to intr_sts                                           */
    } intr_msk_b;
  } ;
  
  union {
    __IM  uint32_t raw_intr_stat;               /*!< (@ 0x00000034) I2C Raw Interrupt Status Register                          */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } raw_intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t rx_tl;                       /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t rx_tl      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
    } rx_tl_b;
  } ;
  
  union {
    __IOM uint32_t tx_tl;                       /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t tx_tl      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
    } tx_tl_b;
  } ;
  
  union {
    __IOM uint32_t clr_intr;                    /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t clr_intr   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the TX_ABRT_SOURCE register.                   */
    } clr_intr_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_under;                /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_rx_under : 1;          /*!< [0..0] Read this register to clear the rx_under interrupt (bit
                                                     0) of the raw_intr_stat register                                          */
    } clr_rx_under_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_over;                 /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_over : 1;           /*!< [0..0] Read this register to clear the rx_over interrupt (bit
                                                     1) of the raw_intr_stat register                                          */
    } clr_rx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_over;                 /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_over : 1;           /*!< [0..0] Read this register to clear the tx_over interrupt (bit
                                                     3) of the raw_intr_stat register.                                         */
    } clr_tx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_rd_req;                  /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t clr_rd_req : 1;            /*!< [0..0] Read this register to clear the rd_req interrupt (bit
                                                     5) of the raw_intr_stat register                                          */
    } clr_rd_req_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_abrt;                 /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_abrt : 1;           /*!< [0..0] Read this register to clear the tx_abrt interrupt (bit
                                                     6) of the raw_intr_stat register, and the tx_abrt_src register.This
                                                     also releases the tx fifo from the flushed/reset state,
                                                     allowing more writes to the TX FIFO. Refer to Bit 9 of
                                                     the tx_abrt_src register for an exception to clearing tx_abrt_src.        */
    } clr_tx_abrt_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_done;                 /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_done : 1;           /*!< [0..0] Read this register to clear the rx_done interrupt (bit
                                                     7) of the raw_intr_stat register                                          */
    } clr_rx_done_b;
  } ;
  
  union {
    __IOM uint32_t clr_act;                     /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_act    : 1;            /*!< [0..0] Reading this register clears the activity interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the activity interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the activity interrupt (bit 8) of the raw_intr_stat
                                                     register.                                                                 */
    } clr_act_b;
  } ;
  
  union {
    __IOM uint32_t clr_stp_det;                 /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_stp_det : 1;           /*!< [0..0] Read this register to clear the stop_det interrupt (bit
                                                     9) of the raw_intr_stat register.                                         */
    } clr_stp_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_strt_det;                /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t clr_strt_det : 1;          /*!< [0..0] Read this register to clear the start_det interrupt (bit
                                                     10) of the raw_intr_stat register.                                        */
    } clr_strt_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_gen_call;                /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_gen_call : 1;          /*!< [0..0] Read this register to clear the gen_call interrupt (bit
                                                     11) of raw_intr_stat register                                             */
    } clr_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Controls whether the I2C Module is enabled.                        */
      __IOM uint32_t abrt       : 1;            /*!< [1..1] Abort I2C current transfer is done w/o flush Tx/Rx FIFO            */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t sts;                         /*!< (@ 0x00000070) I2C Status Reigster                                        */
    
    struct {
      __IM  uint32_t act        : 1;            /*!< [0..0] I2C Activity Status.                                               */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full.                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or morevalid entries, this bit is cleared. This bit
                                                     field does not request an interrupt.                                      */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty.                                                    */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO CompletelyFull. When the receive FIFO iscompletely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared.                              */
      __IM  uint32_t mst_act    : 1;            /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t slv_act    : 1;            /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t mst_hold_tx_empty : 1;     /*!< [7..7] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in master mode.                                          */
      __IM  uint32_t mst_hold_rx_full : 1;      /*!< [8..8] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in master mode.                                           */
      __IM  uint32_t slv_hold_tx_empty : 1;     /*!< [9..9] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in slave mode.                                           */
      __IM  uint32_t slv_hold_rx_full : 1;      /*!< [10..10] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in slave mode.                                            */
      __IOM uint32_t bus_sts    : 2;            /*!< [12..11] Show current I2C bus status                                      */
    } sts_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000074) I2C Transmit FIFO Level Register                           */
    
    struct {
      __IM  uint32_t txflr      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000078) I2C Receive FIFO Level Register                            */
    
    struct {
      __IM  uint32_t rxflr      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IOM uint32_t sda_hold;                    /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register                          */
    
    struct {
      __IOM uint32_t sda_hold   : 16;           /*!< [15..0] Sets the required SDA hold timein units of clk period.            */
    } sda_hold_b;
  } ;
  
  union {
    __IOM uint32_t tx_abrt_src;                 /*!< (@ 0x00000080) I2C Transmit Abort Source Register                         */
    
    struct {
      __IM  uint32_t addr_7bit_nack : 1;        /*!< [0..0] 1: Master is in 7-bit addressing mode and the address
                                                     sent was not acknowledged by any slave.                                   */
      __IM  uint32_t addr1_10bit_nack : 1;      /*!< [1..1] 1: Master is in 10-bit address mode and the first 10-bit
                                                     address byte was not acknowledged by any slave.                           */
      __IM  uint32_t addr2_10bit_nack : 1;      /*!< [2..2] 1: Master is in 10-bit address mode and the second address
                                                     byte of the 10-bit address was not acknowledged by any
                                                     slave.                                                                    */
      __IM  uint32_t txdat_nack : 1;            /*!< [3..3] 1: This is a master-mode only bit. Master has received
                                                     an acknowledgement for the address, but when it sent data
                                                     byte(s) following the address, it did not receive an acknowledge
                                                     from the remote slave(s).                                                 */
      __IM  uint32_t gcall_nack : 1;            /*!< [4..4] 1: I2C Module in master mode sent a General Call and
                                                     no slave on the bus acknowledged the General Call.                        */
      __IM  uint32_t gcall_rd   : 1;            /*!< [5..5] 1: I2C Module in master mode sent a General Call but
                                                     the user programmed the byte following the General Call
                                                     to be a read from the bus (dat_cmd[9] is set to 1).                       */
      __IM  uint32_t hs_ackdet  : 1;            /*!< [6..6] 1: Master is in High Speed mode and the High Speed Master
                                                     code was acknowledged (wrong behavior).                                   */
      __IM  uint32_t sbyte_ackdet : 1;          /*!< [7..7] 1: Master has sent a START Byte and the START Byte was
                                                     acknowledged (wrong behavior).                                            */
      __IM  uint32_t norstrt_hs : 1;            /*!< [8..8] 1: The restart is disabled (rstrt_en bit (con[5]) = 0)
                                                     and the user is trying to use the master to transfer data
                                                     in High Speed mode.                                                       */
      __IM  uint32_t norstrt_sbyte : 1;         /*!< [9..9] 1: The restart is disabled (rstrt bit con[5]) = 0) and
                                                     the user is trying to send a START Byte.                                  */
      __IM  uint32_t norstrt_10bit_rd : 1;      /*!< [10..10] 1: The restart is disabled (rstrt_en bit (con[5]) =
                                                     0) and the master sends a read command in 10-bit addressing
                                                     mode.                                                                     */
      __IM  uint32_t mst_dis    : 1;            /*!< [11..11] 1: User tries to initiate a Master operation with the
                                                     Master mode disabled.                                                     */
      __IM  uint32_t arb_lost   : 1;            /*!< [12..12] 1: Master has lost arbitration, or if tx_abrt_src[14]
                                                     is also set, then the slave transmitter has lost arbitration.             */
      __IM  uint32_t slvflush_txfifo : 1;       /*!< [13..13] 1: Slave has received a read command and some data
                                                     exists in the TX FIFO so the slave issues a tx_abrt interrupt
                                                     to flush old data in TX FIFO.                                             */
      __IM  uint32_t slv_arblost : 1;           /*!< [14..14] 1: Slave lost the bus while transmitting data to a
                                                     remote master. Tx_abrt_src[12] is set at the same time.                   */
      __IM  uint32_t slvrd_intx : 1;            /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in cmd(bit 8) of dat_cmd register.                        */
    } tx_abrt_src_b;
  } ;
  
  union {
    __IOM uint32_t slv_dat_nack;                /*!< (@ 0x00000084) I2C Generate Slave Data NACK Register                      */
    
    struct {
      __IOM uint32_t slv_dat_nack : 1;          /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     I2C Module is a slavereceiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria.                                   */
    } slv_dat_nack_b;
  } ;
  
  union {
    __IOM uint32_t dma_cr;                      /*!< (@ 0x00000088) I2C DMA Control Reigster                                   */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel.                                                         */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel.                                                         */
    } dma_cr_b;
  } ;
  
  union {
    __IOM uint32_t dma_tdlr;                    /*!< (@ 0x0000008C) I2C DMA Transmit Data Level Register                       */
    
    struct {
      __IOM uint32_t tdlr       : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tdmae= 1.                                                             */
    } dma_tdlr_b;
  } ;
  
  union {
    __IOM uint32_t dma_rdlr;                    /*!< (@ 0x00000090) I2C DMA Receive Data Level Register                        */
    
    struct {
      __IOM uint32_t rdlr       : 4;            /*!< [3..0] Receive Data Level.                                                */
    } dma_rdlr_b;
  } ;
  
  union {
    __IOM uint32_t sda_setup;                   /*!< (@ 0x00000094) I2C SDA Setup Register                                     */
    
    struct {
      __IOM uint32_t sda_setup  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an clk frequency of 10 MHz, sda_setup
                                                     should be programmed to a value of 11. sda_setup must be
                                                     programmed with a minimum value of 2.                                     */
    } sda_setup_b;
  } ;
  
  union {
    __IOM uint32_t ack_gen_call;                /*!< (@ 0x00000098) I2C ACK General Call Register                              */
    
    struct {
      __IOM uint32_t ack_gen_call : 1;          /*!< [0..0] ACK General Call. When set to 1, I2C Module responds
                                                     with a ACK (by asserting data_oe) when it receives a General
                                                     Call. When set to 0, the I2C Module does not generate General
                                                     Call interrupts.                                                          */
    } ack_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t en_sts;                      /*!< (@ 0x0000009C) I2C Enable Status Register                                 */
    
    struct {
      __IM  uint32_t en         : 1;            /*!< [0..0] Enable Status.                                                     */
      __IM  uint32_t slv_dis_in_busy : 1;       /*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting of the ENABLE register
                                                     from 1 to 0.                                                              */
      __IM  uint32_t slv_rx_dat_lost : 1;       /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting of enable
                                                     from 1 to 0.                                                              */
      __IM  uint32_t dma_dis_sts : 2;           /*!< [4..3] DMA_DISABLE_WHILE_BUSY. 00: No ill disable event is active
                                                     01: I2C is disable while busy in legacy mode 10: I2C is
                                                     disable while busy in DMA mode 11: I2C is disable while
                                                     busy in Descriptor mode                                                   */
    } en_sts_b;
  } ;
  
  union {
    __IOM uint32_t dma_cmd;                     /*!< (@ 0x000000A0) I2C DMA Command Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Set to enable DMA mode.                                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t cmd        : 1;            /*!< [5..5] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the I2C Module
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. 1 = Read 0 = Write                                      */
      __IOM uint32_t stp        : 1;            /*!< [6..6] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __IOM uint32_t rstrt      : 1;            /*!< [7..7] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received when DMA mode is enabled.                    */
    } dma_cmd_b;
  } ;
  
  union {
    __IOM uint32_t dma_len;                     /*!< (@ 0x000000A4) I2C DMA Transfer Data Length Register                      */
    
    struct {
      __IOM uint32_t len        : 16;           /*!< [15..0] DMA transfer data length(R/W)                                     */
      __IM  uint32_t tr_len     : 16;           /*!< [31..16] DMA mode transfer bytes(Read only)                               */
    } dma_len_b;
  } ;
  
  union {
    __IOM uint32_t dma_mod;                     /*!< (@ 0x000000A8) I2C DMA Mode Register                                      */
    
    struct {
      __IOM uint32_t dma_mod    : 2;            /*!< [1..0] DMA operation mode                                                 */
    } dma_mod_b;
  } ;
  
  union {
    __IOM uint32_t slp;                         /*!< (@ 0x000000AC) I2C Sleep Control Register                                 */
    
    struct {
      __IOM uint32_t clk_ctrl   : 1;            /*!< [0..0] I2C clock control, write 1 controller would gate I2C
                                                     clock until I2C slave is enable and reset synchronized
                                                     register procedure is done                                                */
      __IM  uint32_t slp_clk_gated : 1;         /*!< [1..1] I2C clock has been gated (Read Only)                               */
    } slp_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t dat_fltr_rsts_l;             /*!< (@ 0x000000B8) Data Filter Resistor Low Register                          */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_l : 20;      /*!< [19..0] Data Filter Resistor Low                                          */
    } dat_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_rsts_m;             /*!< (@ 0x000000BC) Data Filter Resistor Main Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_m : 20;      /*!< [19..0] Data Filter Resistor Main                                         */
    } dat_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_l;             /*!< (@ 0x000000C0) Clock Filter Resistor Low Register                         */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_l : 20;      /*!< [19..0] Clock Filter Resistor Low                                         */
    } clk_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_m;             /*!< (@ 0x000000C4) Clock Filter Resistor Main Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_m : 20;      /*!< [19..0] Clock Filter Resistor Main                                        */
    } clk_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_l;              /*!< (@ 0x000000C8) Data Filter Capacitor Low Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_cap_l : 20;       /*!< [19..0] Data Filter Capacitor Low                                         */
    } dat_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_m;              /*!< (@ 0x000000CC) Data Filter Capacitor Main Register                        */
    
    struct {
      __IOM uint32_t dat_fltr_cap_m : 5;        /*!< [4..0] Data Filter Capacitor Main                                         */
    } dat_fltr_cap_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_l;              /*!< (@ 0x000000D0) Clock Filter Capacitor Low Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_cap_l : 20;       /*!< [19..0] Clock Filter Capacitor Low                                        */
    } clk_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_m;              /*!< (@ 0x000000D4) Clock Filter Capacitor Main Register                       */
    
    struct {
      __IOM uint32_t clk_fltr_cap_m : 5;        /*!< [4..0] Clock Filter Capacitor Main                                        */
    } clk_fltr_cap_m_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t clr_addr_match;              /*!< (@ 0x000000E4) Clear I2C ADDR_MATCH Interrupt Register                    */
    
    struct {
      __IOM uint32_t clr_addr_match : 1;        /*!< [0..0] Clear address match interrupts raw status, and it's read
                                                     clear.                                                                    */
    } clr_addr_match_b;
  } ;
  
  union {
    __IOM uint32_t clr_dma_done;                /*!< (@ 0x000000E8) Clear I2C DMA_DONE Interrupt Register                      */
    
    struct {
      __IOM uint32_t clr_dma_done : 1;          /*!< [0..0] Clear dma_i2c_done_intr interrupts raw status, and it's
                                                     read clear.                                                               */
    } clr_dma_done_b;
  } ;
  
  union {
    __IOM uint32_t fltr;                        /*!< (@ 0x000000EC) I2C Bus Filter Register                                    */
    
    struct {
      __IOM uint32_t dig_fltr_deg : 4;          /*!< [3..0] I2C module digital filter degree                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t dig_fltr_en : 1;           /*!< [8..8] I2C module digital filter slection (enable)                        */
    } fltr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t sar1;                        /*!< (@ 0x000000F4) I2C Slave Address 1 Register                               */
    
    struct {
      __IOM uint32_t sar1       : 7;            /*!< [6..0] I2C Second Slave Address                                           */
    } sar1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t ver;                         /*!< (@ 0x000000FC) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t ver        : 32;           /*!< [31..0] I2C module version number                                         */
    } ver_b;
  } ;
} I2C_Type;                                     /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           SGPIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial General Purpose Input / Output (SGPIO)
  */

typedef struct {                                /*!< (@ 0xA0046000) SGPIO Structure                                            */
  
  union {
    __IOM uint32_t rxtmr_ctrl;                  /*!< (@ 0x00000000) RX Timer Control Register                                  */
    
    struct {
      __IOM uint32_t rxtmr_cen  : 1;            /*!< [0..0] 0: Disabled. The counters are disabled. 1: Enabled. RXTC
                                                     and RXPRTC are enabled.                                                   */
      __IOM uint32_t rxtmr_crst : 1;            /*!< [1..1] RXTC and RXPRTC are synchronously reset on the next positive
                                                     edge of PCLK. The counters remain reset until RXTMR_CEN
                                                     is returned to zero. 0: Disabled. Do nothing. 1: Enabled.                 */
      __IM  uint32_t            : 6;
      __IOM uint32_t rxtmredge_sel : 2;         /*!< [9..8] RXTC will start and RXTMR_CEN will be set according to
                                                     receiving the trigger. 00: Disabled. Do nothing. 01: Receive
                                                     rising edges. 02: Receive falling edges. 03: Receive both
                                                     edges.                                                                    */
    } rxtmr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rxprval;                     /*!< (@ 0x00000004) RX Maximum Prescale Register                               */
    
    struct {
      __IOM uint32_t rxprval    : 16;           /*!< [15..0] Maximum value for the RX Prescale Counter                         */
    } rxprval_b;
  } ;
  
  union {
    __IOM uint32_t rxprtc;                      /*!< (@ 0x00000008) RX Timer Prescale Register                                 */
    
    struct {
      __IOM uint32_t rxprtc     : 16;           /*!< [15..0] RX Prescale Counter value.                                        */
    } rxprtc_b;
  } ;
  
  union {
    __IOM uint32_t rxtc;                        /*!< (@ 0x0000000C) RX Timer Counter Register                                  */
    
    struct {
      __IOM uint32_t rxtc       : 16;           /*!< [15..0] RX Timer Counter value.                                           */
    } rxtc_b;
  } ;
  
  union {
    __IOM uint32_t rxmc;                        /*!< (@ 0x00000010) Position Counter Register                                  */
    
    struct {
      __IOM uint32_t rx_mr0i_en : 1;            /*!< [0..0] Generate an interrupt when RXMR0 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr0rst_en : 1;          /*!< [1..1] Reset RXTC when RXMR0 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr0stop_en : 1;         /*!< [2..2] RXTC will stop and RXTMR_CEN will be cleared if RXMR0
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr0sclk_en : 1;         /*!< [3..3] Generate a shift clock for RX Data Register when RXMR0
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr1i_en : 1;            /*!< [4..4] Generate an interrupt when RXMR1 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr1rst_en : 1;          /*!< [5..5] Reset RXTC when RXMR1 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr1stop_en : 1;         /*!< [6..6] RXTC will stop and RXTMR_CEN will be cleared if RXMR1
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr1sclk_en : 1;         /*!< [7..7] Generate a shift clock for RX Data Register when RXMR1
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr2i_en : 1;            /*!< [8..8] Generate an interrupt when RXMR2 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr2rst_en : 1;          /*!< [9..9] Reset RXTC when RXMR2 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr2stop_en : 1;         /*!< [10..10] RXTC will stop and RXTMR_CEN will be cleared if RXMR2
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr2sclk_en : 1;         /*!< [11..11] Generate a shift clock for RX Data Register when RXMR2
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr0mulrst_en : 1;       /*!< [12..12] Reset MULTC when RXMR0 matches RXTC. 0: Disable 1:
                                                     Enable                                                                    */
      __IOM uint32_t rx_mr0mulstop_en : 1;      /*!< [13..13] MULTC will stop and MULTMR_CEN will be cleared if RXMR0
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_posrst_en : 1;          /*!< [14..14] Reset RXTC when each time RXPOSTC reaches 0x0.                   */
      __IOM uint32_t rx_posstop_en : 1;         /*!< [15..15] RXTC will stop and RXTMR_CEN will be cleared when each
                                                     time RXPOSTC reaches 0x0.                                                 */
    } rxmc_b;
  } ;
  
  union {
    __IOM uint32_t rxmr0;                       /*!< (@ 0x00000014) RX Match Register 0                                        */
    
    struct {
      __IOM uint32_t rxmr0      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr0_b;
  } ;
  
  union {
    __IOM uint32_t rxmr1;                       /*!< (@ 0x00000018) RX Match Register 1                                        */
    
    struct {
      __IOM uint32_t rxmr1      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr1_b;
  } ;
  
  union {
    __IOM uint32_t rxmr2;                       /*!< (@ 0x0000001C) RX Match Register 2                                        */
    
    struct {
      __IOM uint32_t rxmr2      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr2_b;
  } ;
  
  union {
    __IOM uint32_t cap_ctrl;                    /*!< (@ 0x00000020) Capture Control Register                                   */
    
    struct {
      __IOM uint32_t cap_en     : 1;            /*!< [0..0] CAPR is loaded with the value of RXTC when there is an
                                                     event on the input. 0: Disable 1: Enable.                                 */
      __IOM uint32_t capi_en    : 1;            /*!< [1..1] The capture load event generates an interrupt. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t capsrc_sel : 1;            /*!< [2..2] Select the capture trigger source. 0: RX input trigger
                                                     event 1: Multiple Counter match event                                     */
      __IOM uint32_t capfe_en   : 1;            /*!< [3..3] Capture on falling edge: a sequence of 1 then 0 causes
                                                     CAPR to be loaded with the contents of RXTC. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t capre_en   : 1;            /*!< [4..4] Capture on rising edge: a sequence of 0 then 1 causes
                                                     CAPR to be loaded with the contents of RXTC. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t cap_rxtcrst_en : 1;        /*!< [5..5] Reset RXTC when the capture trigger event happens. 0:
                                                     Disable 1: Enable                                                         */
      __IOM uint32_t cap_rxtcstop_en : 1;       /*!< [6..6] RXTC will stop and RXTMR_CEN will be cleared if the capture
                                                     trigger event happens. 0: Disable 1: Enable                               */
      __IOM uint32_t cap_cmpval_sel : 1;        /*!< [7..7] RXDATA receives value when CAPR is bigger than CAP_CMPVAL.
                                                     0: RXDATA receives 0 1: RXDATA receives 1                                 */
      __IOM uint32_t capvalid_en : 1;           /*!< [8..8] The valid match needs that RXTMR_CEN is enabled. 0: Need
                                                     to enable RXTMR_CEN. 1: Do not need to enable RXTMR_CEN.                  */
      __IM  uint32_t            : 7;
      __IOM uint32_t cap_cmpval : 16;           /*!< [31..16] Compare this value with CAPR                                     */
    } cap_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t capr;                        /*!< (@ 0x00000024) Capture Register                                           */
    
    struct {
      __IM  uint32_t capr       : 16;           /*!< [15..0] RX timer counter capture value                                    */
    } capr_b;
  } ;
  
  union {
    __IOM uint32_t multmr_ctrl;                 /*!< (@ 0x00000028) Multiple Timer Control Register                            */
    
    struct {
      __IOM uint32_t multmr_cen : 1;            /*!< [0..0] 0: Disabled. The counters are disabled. 1: Enabled. MULTC
                                                     and MULPRTC are enabled.                                                  */
      __IOM uint32_t multmr_crst : 1;           /*!< [1..1] The Timer Counter and the Prescale Counter are synchronously
                                                     reset on the next positive edge of PCLK. The counters remain
                                                     reset until MULTMR_CEN is returned to zero. 0: Disabled.
                                                     Do nothing. 1: Enabled.                                                   */
      __IM  uint32_t            : 6;
      __IOM uint32_t mulmode_en : 2;            /*!< [9..8] Counter/Timer Mode This field selects which rising PCLK
                                                     edges can increment MULPRTC or clear MULPRTC and increment
                                                     MULTC. Timer Mode: MULTC is incremented when MULPRTC matches
                                                     MULPRVAL. Before change this mode, need to check that MUTMR_CEN
                                                     is 0. 00: Timer Mode. Incremented every rising PCLK edge.
                                                     01: Counter Mode rising edge. MULTC is incremented on rising
                                                     edges on the input. 02: Counter Mode falling edge. MULTC
                                                     is incremented on falling edges on the input. 03: Counter
                                                     Mode both edge. MULTC is incremented                                      */
    } multmr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t mulprval;                    /*!< (@ 0x0000002C) Multiple Maximum Prescale Register                         */
    
    struct {
      __IOM uint32_t mulprval   : 16;           /*!< [15..0] Maximum value for the Multiple Prescale Counter                   */
    } mulprval_b;
  } ;
  
  union {
    __IOM uint32_t mulprtc;                     /*!< (@ 0x00000030) Multiple Timer Prescale Register                           */
    
    struct {
      __IOM uint32_t mulprtc    : 16;           /*!< [15..0] Multiple Prescale Counter value.                                  */
    } mulprtc_b;
  } ;
  
  union {
    __IOM uint32_t multc;                       /*!< (@ 0x00000034) Multiple Timer Counter Register                            */
    
    struct {
      __IOM uint32_t multc      : 16;           /*!< [15..0] Multiple Timer Counter value.                                     */
    } multc_b;
  } ;
  
  union {
    __IOM uint32_t mulmc;                       /*!< (@ 0x00000038) Multiple Match Control Register                            */
    
    struct {
      __IOM uint32_t mul_mr0i_en : 1;           /*!< [0..0] Generate an interrupt when BIT_PERI_MULMR0_GP0 or BIT_PERI_MULMR0_GP1
                                                     match the value in the BIT_PERI_MULTC. 0: Disable 1: Enable               */
      __IOM uint32_t mul_mr0rst_en : 1;         /*!< [1..1] Reset BIT_PERI_MULTC when BIT_PERI_MULMR0_GP0 or BIT_PERI_MULMR0_GP1
                                                     match BIT_PERI_MULTC. 0: Disable 1: Enable                                */
      __IOM uint32_t mul_mr0stop_en : 1;        /*!< [2..2] MULTC will stop and MULTMR_CEN will be cleared if MULMR0_GP0
                                                     or MULMR0_GP1 match MULTC. 0: Disable 1: Enable                           */
      __IOM uint32_t mul_mr0sclk_en : 1;        /*!< [3..3] Generate a shift clock for Multiple Data Register when
                                                     MULMR0_GP0 or MULMR0_GP1 match the value in the MULTC.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mul_mr0rxrst_en : 1;       /*!< [4..4] Reset RXTC when MULMR0_GP0 or MULMR0_GP1 match MULTC.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mul_mr0rxstop_en : 1;      /*!< [5..5] RXTC will stop and RXTMR_CEN will be cleared if MULMR0_GP0
                                                     or MULMR0_GP1 match MULTC. 0: Disable 1: Enable                           */
      __IOM uint32_t mul_mr0capsrc_en : 1;      /*!< [6..6] Change the capture trigger source. When match MULTC,
                                                     generate the Multiple Counter match event to make that
                                                     CAPR is loaded with the value of RXTC. 0: Disable 1: Enable               */
      __IOM uint32_t mul_mr0mcnt_en : 1;        /*!< [7..7] Let MUL_MCNT counts down when MULMR0_GP0 or MULMR0_GP1
                                                     match the value in the MULTC. 0: Disable 1: Enable                        */
      __IOM uint32_t mul_mcnti_en : 1;          /*!< [8..8] Generate an interrupt when MUL_MCNT reaches zero.                  */
      __IOM uint32_t mul_mcntrst_en : 1;        /*!< [9..9] Reset MULTC when each time MUL_MCNT reaches zero. 0:
                                                     Disable 1: Enable                                                         */
      __IOM uint32_t mul_mcntstop_en : 1;       /*!< [10..10] MULTC will stop and MULTMR_CEN will be cleared if each
                                                     time MUL_MCNT reaches zero. 0: Disable 1: Enable                          */
      __IOM uint32_t mul_fmode_en : 1;          /*!< [11..11] The match value of multiple match control is according
                                                     to multiple match FIFO. This mode only changes match values.
                                                     The match control is the same. 1->0 reset all FIFO logic
                                                     to initial state. 0: Disable 1: Enable                                    */
      __IOM uint32_t mul_dma_en : 1;            /*!< [12..12] Use DMA mode to write the match value of FIFO. Need
                                                     to set FMODE. 0: Disable 1: Enable                                        */
      __IOM uint32_t mul_dma_start : 1;         /*!< [13..13] When set DMA register and complete data prepartion,
                                                     set this bit in order to trigger that mutiple match FIFO
                                                     is loaded with data for the first time. 0: Disabled. Do
                                                     nothing. 1: Trigger DMA. Automatically change from 1 to
                                                     0.                                                                        */
      __IOM uint32_t mul_dma_unfli_en : 1;      /*!< [14..14] Generate an interrupt when multiple match FIFO is underflow
                                                     in the DMA mode. (MUL_DMA_EN = 1)                                         */
    } mulmc_b;
  } ;
  
  union {
    __IOM uint32_t mulmr01gp0;                  /*!< (@ 0x0000003C) Multiple Match Register 0 & 1 For Group 0                  */
    
    struct {
      __IOM uint32_t mulmr0_gp0 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
      __IOM uint32_t mulmr1_gp0 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
    } mulmr01gp0_b;
  } ;
  
  union {
    __IOM uint32_t mulmr23gp0;                  /*!< (@ 0x00000040) Multiple Match Register 2 & 3 For Group 0                  */
    
    struct {
      __IOM uint32_t mulmr2_gp0 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
      __IOM uint32_t mulmr3_gp0 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
    } mulmr23gp0_b;
  } ;
  
  union {
    __IOM uint32_t mulmr01gp1;                  /*!< (@ 0x00000044) Multiple Match Register 0 & 1 For Group 1                  */
    
    struct {
      __IOM uint32_t mulmr0_gp1 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
      __IOM uint32_t mulmr1_gp1 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
    } mulmr01gp1_b;
  } ;
  
  union {
    __IOM uint32_t mulmr23gp1;                  /*!< (@ 0x00000048) Multiple Match Register 2 & 3 For Group 1                  */
    
    struct {
      __IOM uint32_t mulmr2_gp1 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
      __IOM uint32_t mulmr3_gp1 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
    } mulmr23gp1_b;
  } ;
  
  union {
    __IOM uint32_t mul_mcnt;                    /*!< (@ 0x0000004C) Multiple Match Counter Register                            */
    
    struct {
      __IOM uint32_t mul_mcnt   : 8;            /*!< [7..0] When MULMR0_GP0 or MULMR0_GP1 match MULTC, MUL_MCNT counts
                                                     down. Counting to zero can stop and reset the multiple
                                                     counter by multiple match control register.                               */
    } mul_mcnt_b;
  } ;
  
  union {
    __IOM uint32_t mulemr;                      /*!< (@ 0x00000050) External Match Control Register                            */
    
    struct {
      __IOM uint32_t mulemc1    : 2;            /*!< [1..0] When MULMR1_GP0 or MULMR1_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t mulemc2    : 2;            /*!< [3..2] When MULMR2_GP0 or MULMR2_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t mulemc3    : 2;            /*!< [5..4] When MULMR3_GP0 or MULMR3_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t rxemc0     : 2;            /*!< [7..6] When RXMR0 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IOM uint32_t rxemc1     : 2;            /*!< [9..8] When RXMR1 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IOM uint32_t rxemc2     : 2;            /*!< [11..10] When RXMR2 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t biout      : 1;            /*!< [16..16] Send TX to bi-direction open-drain output. When disable
                                                     output, bi-direction open-drain output is high. 0: Disable
                                                     output 1: Enable output                                                   */
    } mulemr_b;
  } ;
  
  union {
    __IOM uint32_t data_ctrl;                   /*!< (@ 0x00000054) Data Control Register                                      */
    
    struct {
      __IOM uint32_t rxsft_ie   : 1;            /*!< [0..0] Enable generating an interrupt when have a shift clock
                                                     for RX Data Register. 0: Disable 1: Enable                                */
      __IOM uint32_t mulsft_ie  : 1;            /*!< [1..1] Enable generating an interrupt when have a shift clock
                                                     for Multiple Data Register. 0: Disable 1: Enable                          */
      __IOM uint32_t rxload_ie  : 1;            /*!< [2..2] When RXDATA_DP is loaded with RXDATA, generate an interrupt.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mulload_ie : 1;            /*!< [3..3] When MULDATA_DP is loaded with MULDATA, generate an interrupt.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t rxdatasrc_sel : 1;         /*!< [4..4] Select RXDATA input source. 0: External input 1: Capture
                                                     comparison                                                                */
      __IOM uint32_t pattern_match_mode : 1;    /*!< [5..5] Filter receving data. RXDATA_DP is programmed with the
                                                     pattern to be matched. RXDATA_DP is not loaded with RXDATA.
                                                     0: Do not match data 1: Match dat                                         */
      __IOM uint32_t pattern_match_ie : 1;      /*!< [6..6] When RXDATA_DP is equal to RXDATA & RXDATAMASK, generate
                                                     an interrupt. E.g. when looking for pattern 0x12XX XX34,
                                                     then RXDATA should be set to 0x12XX XX34 and RXDATAMASK
                                                     to 0xFF00 00FF. 0: Disable 1: Enable                                      */
      __IOM uint32_t rxdata_dir : 1;            /*!< [7..7] Select the input direction of the RXDATA 0: Input data
                                                     from MSB 1: Input data from LSB                                           */
      __IOM uint32_t txdata_dir : 1;            /*!< [8..8] Select the output direction of the TXDATA 0: Output data
                                                     from LSB 1: Output data from MSB                                          */
    } data_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rxdata;                      /*!< (@ 0x00000058) RX Data Register                                           */
    
    struct {
      __IOM uint32_t rxdata     : 32;           /*!< [31..0] The register shifts right at each active shift clock;
                                                     loading RXDATA[31] with data captured from input.                         */
    } rxdata_b;
  } ;
  
  union {
    __IOM uint32_t rxdata_dp;                   /*!< (@ 0x0000005C) RX Data Duplicate Register                                 */
    
    struct {
      __IOM uint32_t rxdata_dp  : 32;           /*!< [31..0] When each time RXPOSTC reaches 0x0, RXDATA_DP is loaded
                                                     with RXDATA.                                                              */
    } rxdata_dp_b;
  } ;
  
  union {
    __IOM uint32_t rxposr;                      /*!< (@ 0x00000060) RX Position Register                                       */
    
    struct {
      __IOM uint32_t rxpostc    : 5;            /*!< [4..0] When generate a shift clock for RX Data Register, RXPOSTC
                                                     counts down                                                               */
      __IM  uint32_t            : 3;
      __IOM uint32_t rxposrst   : 5;            /*!< [12..8] Reload value for RXPOSTC after RXPOSTC reaches 0x0.               */
    } rxposr_b;
  } ;
  
  union {
    __IOM uint32_t rxdatamask;                  /*!< (@ 0x00000064) RX Data Mask Register                                      */
    
    struct {
      __IOM uint32_t rxdatamask : 32;           /*!< [31..0] Mask for pattern match function.                                  */
    } rxdatamask_b;
  } ;
  
  union {
    __IOM uint32_t muldata;                     /*!< (@ 0x00000068) Multiple Data Register                                     */
    
    struct {
      __IOM uint32_t muldata    : 32;           /*!< [31..0] The register shifts right at each active shift clock;
                                                     output is set to MULDATA [0].                                             */
    } muldata_b;
  } ;
  
  union {
    __IOM uint32_t muldata_dp;                  /*!< (@ 0x0000006C) Multiple Data Duplicate Register                           */
    
    struct {
      __IOM uint32_t muldata_dp : 32;           /*!< [31..0] When each time MULPOSTC reaches 0x0, MULDATA_DP is loaded
                                                     with MULDATA.                                                             */
    } muldata_dp_b;
  } ;
  
  union {
    __IOM uint32_t mulposr;                     /*!< (@ 0x00000070) Multiple Position Register                                 */
    
    struct {
      __IOM uint32_t mulpostc   : 5;            /*!< [4..0] When generate a shift clock for Multiple Data Register,
                                                     MULPOSTC counts down.                                                     */
      __IM  uint32_t            : 3;
      __IOM uint32_t mulposrst  : 5;            /*!< [12..8] Reload value for MULPOSTC after MULPOSTC reaches 0x0.             */
    } mulposr_b;
  } ;
  
  union {
    __OM  uint32_t mulfdata;                    /*!< (@ 0x00000074) Multiple FIFO Data Register                                */
    
    struct {
      __OM  uint32_t mulfdata   : 32;           /*!< [31..0] Write the match value (FMR1, FMR0) or (FMR3, FMR2) to
                                                     FIFO.                                                                     */
    } mulfdata_b;
  } ;
  
  union {
    __IOM uint32_t is;                          /*!< (@ 0x00000078) SGPIO Interrupt Status Register                            */
    
    struct {
      __IOM uint32_t rx_mr0i_is : 1;            /*!< [0..0] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rx_mr1i_is : 1;            /*!< [1..1] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rx_mr2i_is : 1;            /*!< [2..2] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mul_mr0i_is : 1;           /*!< [3..3] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t capi_is    : 1;            /*!< [4..4] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rxsft_is   : 1;            /*!< [5..5] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulsft_is  : 1;            /*!< [6..6] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rxload_is  : 1;            /*!< [7..7] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulload_is : 1;            /*!< [8..8] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t pattern_match_is : 1;      /*!< [9..9] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulmcnt_is : 1;            /*!< [10..10] Interrupt raw status 0: No Interrupt. 1: Interrupt
                                                     requirement met. Clear Interrupts; write 1 to clear.                      */
      __IOM uint32_t mul_dma_unfl_is : 1;       /*!< [11..11] Interrupt raw status 0: No Interrupt. 1: Interrupt
                                                     requirement met. Clear Interrupts; write 1 to clear.                      */
    } is_b;
  } ;
  
  union {
    __IOM uint32_t gf;                          /*!< (@ 0x0000007C) SGPIO Glitch Filter Register                               */
    
    struct {
      __IOM uint32_t gf         : 8;            /*!< [7..0] This register can enable or disable digital glitch filtering.
                                                     0: Disable 1: delay 1T clock 2: delay 2T clock etc. 255:
                                                     delay 255T clock                                                          */
    } gf_b;
  } ;
  
  union {
    __IOM uint32_t output;                      /*!< (@ 0x00000080) SGPIO Output Register                                      */
    
    struct {
      __IOM uint32_t output     : 1;            /*!< [0..0] This bit will act according to MULEMC1~3 and RXEMC0~2
                                                     bits. Drive the state of output by setting this bit. 0:
                                                     Output is low 1: Output is high                                           */
    } output_b;
  } ;
  
  union {
    __IOM uint32_t im;                          /*!< (@ 0x00000084) SGPIO Interrupt Mask Register                              */
    
    struct {
      __IOM uint32_t rx_mr0i_im : 1;            /*!< [0..0] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rx_mr1i_im : 1;            /*!< [1..1] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rx_mr2i_im : 1;            /*!< [2..2] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mul_mr0i_im : 1;           /*!< [3..3] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t capi_im    : 1;            /*!< [4..4] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rxsft_im   : 1;            /*!< [5..5] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulsft_im  : 1;            /*!< [6..6] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rxload_im  : 1;            /*!< [7..7] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulload_im : 1;            /*!< [8..8] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t pattern_match_im : 1;      /*!< [9..9] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulmcnt_im : 1;            /*!< [10..10] interrupt mask: 0: un-mask 1: mask                               */
      __IOM uint32_t mul_dma_unfl_im : 1;       /*!< [11..11] interrupt mask: 0: un-mask 1: mask                               */
    } im_b;
  } ;
} SGPIO_Type;                                   /*!< Size = 136 (0x88)                                                         */



/* =========================================================================================================================== */
/* ================                                           QDEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature decoder (QDEC)
  */

typedef struct {                                /*!< (@ 0xA0046800) QDEC Structure                                             */
  
  union {
    __IOM uint32_t clksel;                      /*!< (@ 0x00000000) Clock Configuration Register                               */
    
    struct {
      __IOM uint32_t dbn_tm     : 11;           /*!< [10..0] De-bounce timer configuration.                                    */
      __IM  uint32_t            : 1;
      __IOM uint32_t smp_div    : 5;            /*!< [16..12] Divider for input signal sampling clock Sampling Clock
                                                     = source-clock/(smp_div+1)                                                */
    } clksel_b;
  } ;
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000004) Control Register                                           */
    
    struct {
      __IOM uint32_t ini_phase  : 2;            /*!< [1..0] The manual initial phase state of the quadrature decoder:(valid
                                                     only mnu_ini = 1) 00: Phase state of (A, B) is (0, 0) 01:
                                                     Phase state of (A, B) is (0, 1) 10: Phase state of (A,
                                                     B) is (1, 0) 11: Phase state of (A, B) is (1, 1)                          */
      __IOM uint32_t mnu_ini    : 1;            /*!< [2..2] Initial the phase state of the quadrature decoder: 1
                                                     : manual set 0 : auto load                                                */
      __IOM uint32_t pchg_lv    : 2;            /*!< [4..3] Position changed interrupt trigger level. 00: +/- 1 01:
                                                     +/- 2 10: +/- 4 11: reserved                                              */
      __IM  uint32_t            : 7;
      __IOM uint32_t dbn_en     : 1;            /*!< [12..12] Input signal (PHA, PHB & IDX) de-bouncing enable control:
                                                     1 : enable de-bounce 0 : disable de-bounce                                */
      __IOM uint32_t cnt_sc     : 1;            /*!< [13..13] The position accumulation counter to be increased/decreased
                                                     by: 0: 1 phase 1: 2 phases. Only phase A edges are counted.               */
      __IOM uint32_t il_int_en  : 1;            /*!< [14..14] Illegal-state detected interrupt enable control: 1
                                                     : enable interrupt 0 : disable interrupt                                  */
      __IOM uint32_t uf_int_en  : 1;            /*!< [15..15] Position counter value underflow interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t of_int_en  : 1;            /*!< [16..16] Position counter value overflow interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t ct_int_en  : 1;            /*!< [17..17] Position counter value changed interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t dr_int_en  : 1;            /*!< [18..18] Movement direction changed interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t pc_int_en  : 1;            /*!< [19..19] Position counter comparing interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t rof_int_en : 1;            /*!< [20..20] Rotation counter overflow interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t ruf_int_en : 1;            /*!< [21..21] Rotation counter underflow interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IOM uint32_t idx_int_en : 1;            /*!< [22..22] Index pulse signal interrupt enable control: 1 : enable
                                                     interrupt 0 : disable interrupt                                           */
      __IOM uint32_t pce_int_en : 1;            /*!< [23..23] Position counter error interrupt enable control: 1
                                                     : enable interrupt 0 : disable interrupt This interrupt
                                                     will be asserted when the index pulse signal is detected
                                                     but the position counter is not equal to 0.                               */
      __IOM uint32_t rc_int_en  : 1;            /*!< [24..24] Rotation counter comparing interrupt enable control:
                                                     1 : enable interrupt 0 : disable interrupt                                */
      __IM  uint32_t            : 2;
      __IOM uint32_t qall_rst   : 1;            /*!< [27..27] Quadrature decoder all reset: 0 : quadrature decoder
                                                     is not in reset. 1 : write 1 to this bit will reset the
                                                     state machine and all functions                                           */
      __IOM uint32_t rc_mod     : 1;            /*!< [28..28] Rotation counter mode: 0 : the rotation counter is
                                                     used to accumulate the number of index event occurred with
                                                     direction(+/-). The index event is the same condition as
                                                     the index reset according to auto reset or index reset
                                                     setting. 1 : the rotation counter is used to accumulate
                                                     the number of the position counter overflow(+)/underflow(-).              */
      __IOM uint32_t rc_rst     : 1;            /*!< [29..29] Rotation counter reset: 0 : rotation counter is not
                                                     in reset 1 : write 1 to this bit will reset the rotation
                                                     counter to 0 The rotation counter reset only can be performed
                                                     when this quadrature decoder is disabled (axis_en = 0).                   */
      __IOM uint32_t pc_rst     : 1;            /*!< [30..30] Position counter reset: 0 : position counter is not
                                                     in reset (normal active) 1 : write 1 to this bit will reset
                                                     the position counter to 0 The position counter reset only
                                                     can be performed when this quadrature decoder is disabled
                                                     (axis_en = 0).                                                            */
      __IOM uint32_t axis_en    : 1;            /*!< [31..31] Quadrature decoder enable control: 1 : enable 0 : disable
                                                     When the CPU write 0(disable) to this bit, the HW should
                                                     do: 1. source clock is gated 2. Clear all interrupt status                */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t mpc;                         /*!< (@ 0x00000008) Max Position Counter Register                              */
    
    struct {
      __IOM uint32_t mpc        : 16;           /*!< [15..0] The maximum value of the position counter.                        */
      __IOM uint32_t pcc        : 16;           /*!< [31..16] The value to be compared with the position counter.              */
    } mpc_b;
  } ;
  
  union {
    __IOM uint32_t rc;                          /*!< (@ 0x0000000C) Rotation Compare Register                                  */
    
    struct {
      __IOM uint32_t rcc        : 12;           /*!< [11..0] The value to be compared with the rotation counter.               */
    } rc_b;
  } ;
  
  union {
    __IM  uint32_t pc;                          /*!< (@ 0x00000010) Position Counter Register                                  */
    
    struct {
      __IM  uint32_t pc         : 16;           /*!< [15..0] The position accumulation counter.                                */
      __IM  uint32_t dir        : 1;            /*!< [16..16] The movement direction. 0 : decrease 1 : increase                */
      __IM  uint32_t als        : 1;            /*!< [17..17] The status of auto load to set initial phase 1 : auto
                                                     load done 0 : auto load on-going                                          */
      __IM  uint32_t sta        : 2;            /*!< [19..18] The quadrature decoder phase state.Current state of
                                                     (A, B) phase.                                                             */
      __IM  uint32_t rc         : 12;           /*!< [31..20] The rotation counter.                                            */
    } pc_b;
  } ;
  
  union {
    __IOM uint32_t isc;                         /*!< (@ 0x00000014) Index Signal Configuration Register                        */
    
    struct {
      __IOM uint32_t pos_rst_phb : 1;           /*!< [0..0] To assign the state of the phase_B signal for the accumulation
                                                     position counter reseting. When cnt_sc is 1, this setting
                                                     is invalid. (pos_rst_pha, pos_rst_phb) = (0, 0) : Reset
                                                     when phase_A signal is 0 and phase_B signale is 0 (pos_rst_pha,
                                                     pos_rst_phb) = (0, 1) : Reset when phase_A signal is 0
                                                     and phase_B signale is 1 (pos_rst_pha, pos_rst_phb) = (1,
                                                     1) : Reset when phase_A signal is 1 and phase_B signale
                                                     is 1 (pos_rst_pha, pos_rst_phb) = (1, 0) : Reset when phase_A
                                                     signal is 1 and phase_B signale is 0                                      */
      __IOM uint32_t pos_rst_pha : 1;           /*!< [1..1] To assign the state of the phase_A signal for the accumulation
                                                     counter reseting. When cnt_sc is 1, the reset is only according
                                                     to pos_rst_pha.                                                           */
      __IM  uint32_t            : 1;
      __IOM uint32_t pos_rst_en : 2;            /*!< [4..3] Enable the accumulation position counter to be reset
                                                     by the Index pulse signal with a given phase_A and/or phase_B
                                                     state. 00: Disabled, no position counter reset on the index
                                                     pulse signal 01: Reset the position counter on the 1st
                                                     index pulse signal only. 10: Reset the position counter
                                                     on every index pulse signal. 11: Reserved                                 */
      __IOM uint32_t idx_inv    : 1;            /*!< [5..5] Inverse the index pulse input signal. 0: no inverse 1:
                                                     inverse the index pulse signal input                                      */
      __IOM uint32_t idx_auto_en : 1;           /*!< [6..6] Auto-index mechanism. 0: Disable. 1: Enable. When enable
                                                     this function, ignore the setting pos_rst_pha, and pos_rst_phb.           */
      __IM  uint32_t            : 24;
      __IOM uint32_t idx_en     : 1;            /*!< [31..31] Enable the index pulse detection. 0: Disable. The index
                                                     pulse signal detection is disabled, all index pulse signal
                                                     related configurations should be ignored. 1: Enable.                      */
    } isc_b;
  } ;
  
  union {
    __IOM uint32_t vctrl;                       /*!< (@ 0x00000018) Velocity Control Register                                  */
    
    struct {
      __IOM uint32_t vmuc_en    : 1;            /*!< [0..0] The velocity measurement unit of measuring the velocity
                                                     counter enable control: 0: disable 1: enable                              */
      __IOM uint32_t vmut_en    : 1;            /*!< [1..1] The velocity measurement unit of measuring the edge time
                                                     enable control: 0: disable 1: enable                                      */
      __IOM uint32_t vmuc_rst   : 1;            /*!< [2..2] Reset the velocity measurement unit of measuring the
                                                     velocity counter: 0: it is not in reset 1: write 1 to this
                                                     bit will reset this unit. Reset the velocity counter, reset
                                                     the velocity counter capture register, and reload the velocity
                                                     timer.                                                                    */
      __IOM uint32_t vmut_rst   : 1;            /*!< [3..3] Reset the velocity measurement unit of measuring the
                                                     edge time: 0: it is not in reset 1: write 1 to this bit
                                                     will reset this unit. Reset the edge timer to zero, reset
                                                     the edge timer capture register, and the prescale edge
                                                     clk restarts to count.                                                    */
      __IOM uint32_t vccap_int_en : 1;          /*!< [4..4] Velocity counter capture interrupt enable control: 0:
                                                     disable interrupt 1: enable interrupt When the velocity
                                                     timer reaches zero, the velocity counter register and the
                                                     position counter are captured in capture registers.                       */
      __IOM uint32_t etcap_int_en : 1;          /*!< [5..5] Edge timer capture interrupt enable control: 0: disable
                                                     interrupt 1: enable interrupt When generate the edge prescale
                                                     event, the edge timer register is captured in the edge
                                                     timer capture register.                                                   */
      __IOM uint32_t vlowlmt_int_en : 1;        /*!< [6..6] Velocity lower limit interrupt enable control: 0: disable
                                                     interrupt 1: enable interrupt                                             */
      __IOM uint32_t vuplmt_int_en : 1;         /*!< [7..7] Velocity upper limit interrupt enable control: 0: disable
                                                     interrupt 1: enable interrupt                                             */
      __IOM uint32_t eterr_int_en : 1;          /*!< [8..8] Edge Timer error interrupt enable control: 0: disable
                                                     interrupt 1: enable interrupt When the edge timer is overflow,
                                                     this interrupt will be asserted.                                          */
      __IOM uint32_t vmuc_mode  : 1;            /*!< [9..9] The velocity measurement unit of measuring the velocity
                                                     counter mode control: 0: the counter value uses the absolute
                                                     value from the decoder 1: the counter value uses the same
                                                     value of the position counter                                             */
      __IM  uint32_t            : 6;
      __IOM uint32_t vt_div     : 8;            /*!< [23..16] Divider for the velocity timer clock Velocity Timer
                                                     Clock = source-clock/(vt_div+1)                                           */
      __IM  uint32_t            : 4;
      __IOM uint32_t eclk_div   : 4;            /*!< [31..28] Edge clock prescale control: 0000: edge prescale event
                                                     = Eclk / 1; 0001: edge prescale event = Eclk / 2; etc.
                                                     1011: edge prescale event = Eclk / 2048; others reserved                  */
    } vctrl_b;
  } ;
  
  union {
    __IOM uint32_t vc;                          /*!< (@ 0x0000001C) Velocity Counter Register                                  */
    
    struct {
      __IM  uint32_t vc         : 16;           /*!< [15..0] This velocity counter will be increased or decreased
                                                     (depends on the direction) by one for every 1 or 2 (depends
                                                     on cnt_sc) phase state changed.                                           */
    } vc_b;
  } ;
  
  union {
    __IOM uint32_t vccap;                       /*!< (@ 0x00000020) Velocity Counter Capture Register                          */
    
    struct {
      __IM  uint32_t vc_cap     : 16;           /*!< [15..0] When the velocity timer reaches zero, the velocity counter
                                                     register is captured in the velocity counter capture register.            */
    } vccap_b;
  } ;
  
  union {
    __IOM uint32_t pccap;                       /*!< (@ 0x00000024) Position Counter Capture Register                          */
    
    struct {
      __IM  uint32_t pc_cap     : 16;           /*!< [15..0] When the velocity timer reaches zero, the position counter
                                                     register is captured in the position counter capture register.            */
    } pccap_b;
  } ;
  
  union {
    __IOM uint32_t vtrld;                       /*!< (@ 0x00000028) Velocity Time Reload Register                              */
    
    struct {
      __IOM uint32_t vtrld      : 16;           /*!< [15..0] When the velocity timer reaches zero, the velocity timer
                                                     register reloads this value.                                              */
    } vtrld_b;
  } ;
  
  union {
    __IOM uint32_t vt;                          /*!< (@ 0x0000002C) Velocity Timer Register                                    */
    
    struct {
      __IM  uint32_t vt         : 16;           /*!< [15..0] This is the velocity timer value of the down counter              */
    } vt_b;
  } ;
  
  union {
    __IOM uint32_t vcomp;                       /*!< (@ 0x00000030) Velocity Compare Register                                  */
    
    struct {
      __IOM uint32_t vlowlmt    : 16;           /*!< [15..0] This is the velocity lower limit value                            */
      __IOM uint32_t vuplmt     : 16;           /*!< [31..16] This is the velocity upper limit value                           */
    } vcomp_b;
  } ;
  
  union {
    __IOM uint32_t et;                          /*!< (@ 0x00000034) Edge Timer Register                                        */
    
    struct {
      __IM  uint32_t et         : 16;           /*!< [15..0] This is the edge timer value of the up counter                    */
    } et_b;
  } ;
  
  union {
    __IOM uint32_t etcap;                       /*!< (@ 0x00000038) Edge Timer Capture Register                                */
    
    struct {
      __IM  uint32_t et_cap     : 16;           /*!< [15..0] When happen the edge clock capture event, the edge timer
                                                     register is captured in the edge timer capture register.                  */
    } etcap_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x0000003C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t ct_int_m   : 1;            /*!< [0..0] Counter value changed interrupt mask: 0: un-mask 1: mask           */
      __IOM uint32_t of_int_m   : 1;            /*!< [1..1] Position counter overflow interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t uf_int_m   : 1;            /*!< [2..2] Position counter underflow interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t il_int_m   : 1;            /*!< [3..3] Illegal state interrupt mask: 0: un-mask 1: mask                   */
      __IOM uint32_t dr_int_m   : 1;            /*!< [4..4] Direction changed interrupt mask: 0: un-mask 1: mask               */
      __IOM uint32_t pc_int_m   : 1;            /*!< [5..5] Position counter comparing interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t rof_int_m  : 1;            /*!< [6..6] Rotation counter overflow interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t ruf_int_m  : 1;            /*!< [7..7] Rotation counter underflow interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t idx_int_m  : 1;            /*!< [8..8] Index pulse signal interrupt mask: 0: un-mask 1: mask
                                                     This interrupt will be asserted when the index pulse signal
                                                     present.                                                                  */
      __IOM uint32_t pce_int_m  : 1;            /*!< [9..9] Position counter error interrupt mask: 0: un-mask 1:
                                                     mask                                                                      */
      __IOM uint32_t vccap_int_m : 1;           /*!< [10..10] Velocity counter capture interrupt mask: 0: un-mask
                                                     1: mask                                                                   */
      __IOM uint32_t etcap_int_m : 1;           /*!< [11..11] Edge timer capture interrupt mask: 0: un-mask 1: mask            */
      __IOM uint32_t vlowlmt_int_m : 1;         /*!< [12..12] Velocity lower limit interrupt mask: 0: un-mask 1:
                                                     mask                                                                      */
      __IOM uint32_t vuplmt_int_m : 1;          /*!< [13..13] Velocity upper limit interrupt mask: 0: un-mask 1:
                                                     mask                                                                      */
      __IOM uint32_t eterr_int_m : 1;           /*!< [14..14] Edge Timer error interrupt mask: 0: un-mask 1: mask
                                                     When the edge timer is overflow, this interrupt will be
                                                     asserted.                                                                 */
      __IOM uint32_t rc_int_m   : 1;            /*!< [15..15] Rotation counter comparing interrupt mask: 0: un-mask
                                                     1: mask This interrupt will be asserted when the rotation
                                                     counter is equal to the value of rcc.                                     */
    } imr_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x00000040) Interrupt Status Register                                  */
    
    struct {
      __IOM uint32_t ct_int_s   : 1;            /*!< [0..0] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t of_int_s   : 1;            /*!< [1..1] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t uf_int_s   : 1;            /*!< [2..2] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t il_int_s   : 1;            /*!< [3..3] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t dr_int_s   : 1;            /*!< [4..4] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t pc_int_s   : 1;            /*!< [5..5] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t rof_int_s  : 1;            /*!< [6..6] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t ruf_int_s  : 1;            /*!< [7..7] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t idx_int_s  : 1;            /*!< [8..8] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t pce_int_s  : 1;            /*!< [9..9] 0: no interrupt 1: interrupt pending                               */
      __IOM uint32_t vccap_int_s : 1;           /*!< [10..10] 0: no interrupt 1: interrupt pending                             */
      __IOM uint32_t etcap_int_s : 1;           /*!< [11..11] 0: no interrupt 1: interrupt pending                             */
      __IOM uint32_t vlowlmt_int_s : 1;         /*!< [12..12] 0: no interrupt 1: interrupt pending                             */
      __IOM uint32_t vuplmt_int_s : 1;          /*!< [13..13] 0: no interrupt 1: interrupt pending                             */
      __IOM uint32_t eterr_int_s : 1;           /*!< [14..14] 0: no interrupt 1: interrupt pending                             */
      __IOM uint32_t rc_int_s   : 1;            /*!< [15..15] 0: no interrupt 1: interrupt pending                             */
    } isr_b;
  } ;
} QDEC_Type;                                    /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                            CIR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief CIR TX and RX with carrier or no carrier (CIR)
  */

typedef struct {                                /*!< (@ 0xA0047000) CIR Structure                                              */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) CIR Control Register                                       */
    
    struct {
      __IOM uint32_t tdiv       : 8;            /*!< [7..0] RX input sampling and trigger tick event. RX input sampling
                                                     clock = SCLK/(TDIV+1). Tick period (sec) = (TDIV+1)/SCLK.                 */
      __IM  uint32_t            : 20;
      __IOM uint32_t txen       : 1;            /*!< [28..28] 1: TX output enable 0: TX output disable                         */
      __IOM uint32_t rxen       : 1;            /*!< [29..29] 1: RX input enable. Can receive the RX event. 0: RX
                                                     input disable. Receive the RX event is invalid.                           */
      __IOM uint32_t txrst      : 1;            /*!< [30..30] 1: reset enabled 0: reset released (normal works)                */
      __IOM uint32_t rxrst      : 1;            /*!< [31..31] 1: reset enabled 0: reset released (normal works)                */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t cgen;                        /*!< (@ 0x00000004) Carrier Generator Register                                 */
    
    struct {
      __IOM uint32_t cdiv       : 8;            /*!< [7..0] Carrier tick period (sec) = (CDIV+1)/SCLK.                         */
      __IOM uint32_t cltick     : 5;            /*!< [12..8] The freq. of the carrier clock = SCLK/(((CHTICK+1)+(CLTICK+1))
                                                     x (CDIV+1)).                                                              */
      __IM  uint32_t            : 3;
      __IOM uint32_t chtick     : 5;            /*!< [20..16] The freq. of the carrier clock = SCLK/(((CHTICK+1)+(CLTICK+1))
                                                     x (CDIV+1)).                                                              */
    } cgen_b;
  } ;
  
  union {
    __IM  uint32_t fsts;                        /*!< (@ 0x00000008) FIFO Status Register                                       */
    
    struct {
      __IM  uint32_t rxrdy      : 1;            /*!< [0..0] 1: At least 1 bytes of RX code in the RX FIFO. 0: No
                                                     data in the RX FIFO.                                                      */
      __IM  uint32_t txfull     : 1;            /*!< [1..1] 1: At least 1 bytes of space in the TX FIFO. 0: No space
                                                     in the TX FIFO (TX FIFO is full).                                         */
      __IM  uint32_t tx2emp     : 1;            /*!< [2..2] 1: At least 2 bytes of space in the TX FIFO. 0: one or
                                                     no space in the TX FIFO.                                                  */
    } fsts_b;
  } ;
  
  union {
    __IM  uint32_t rxrd;                        /*!< (@ 0x0000000C) RX Code Read Register                                      */
    
    struct {
      __IM  uint32_t rxrd       : 8;            /*!< [7..0] Read this register will get 1 byte of IR RX symbol code
                                                     from the RX FIFO.                                                         */
    } rxrd_b;
  } ;
  
  union {
    __OM  uint32_t txwr;                        /*!< (@ 0x00000010) TX Code Write Register                                     */
    
    struct {
      __OM  uint32_t txwr       : 8;            /*!< [7..0] Write this register will put 1 byte of TX IR code to
                                                     the TX FIFO.                                                              */
    } txwr_b;
  } ;
  
  union {
    __IOM uint32_t irt;                         /*!< (@ 0x00000014) IR RX Timeout Register                                     */
    
    struct {
      __IOM uint32_t idto       : 16;           /*!< [15..0] IR RX idle timeout.                                               */
      __IOM uint32_t csto       : 8;            /*!< [23..16] IR RX Carrier clock sense timeout.                               */
    } irt_b;
  } ;
  
  union {
    __IOM uint32_t symcfg0;                     /*!< (@ 0x00000018) IR RX Symbol Configuration 0 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg0_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt0;                     /*!< (@ 0x0000001C) IR RX Symbol Time 0 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt0_b;
  } ;
  
  union {
    __IOM uint32_t symcfg1;                     /*!< (@ 0x00000020) IR RX Symbol Configuration 1 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg1_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt1;                     /*!< (@ 0x00000024) IR RX Symbol Time 1 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt1_b;
  } ;
  
  union {
    __IOM uint32_t symcfg2;                     /*!< (@ 0x00000028) IR RX Symbol Configuration 2 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg2_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt2;                     /*!< (@ 0x0000002C) IR RX Symbol Time 2 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt2_b;
  } ;
  
  union {
    __IOM uint32_t symcfg3;                     /*!< (@ 0x00000030) IR RX Symbol Configuration 3 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg3_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt3;                     /*!< (@ 0x00000034) IR RX Symbol Time 3 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt3_b;
  } ;
  
  union {
    __IOM uint32_t symcfg4;                     /*!< (@ 0x00000038) IR RX Symbol Configuration 4 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg4_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt4;                     /*!< (@ 0x0000003C) IR RX Symbol Time 4 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt4_b;
  } ;
  
  union {
    __IOM uint32_t symcfg5;                     /*!< (@ 0x00000040) IR RX Symbol Configuration 5 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg5_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt5;                     /*!< (@ 0x00000044) IR RX Symbol Time 5 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt5_b;
  } ;
  
  union {
    __IOM uint32_t symcfg6;                     /*!< (@ 0x00000048) IR RX Symbol Configuration 6 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg6_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt6;                     /*!< (@ 0x0000004C) IR RX Symbol Time 6 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt6_b;
  } ;
  
  union {
    __IOM uint32_t symcfg7;                     /*!< (@ 0x00000050) IR RX Symbol Configuration 7 Register                      */
    
    struct {
      __IOM uint32_t symccc_db  : 12;           /*!< [11..0] This filed define the down bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symccc_ub  : 12;           /*!< [23..12] This filed define the up bond of the valid carrier
                                                     clock cycles of the symbol.                                               */
      __IOM uint32_t symtyp     : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:
                                                     Space symbol with low level: RX input signal level keeps
                                                     low for a given period. 1: Space symbol with high level:
                                                     RX input signal level keeps high for a given period. 2:
                                                     Carrier symbol: carrier clock continuously present on the
                                                     RX input signal for a given period.                                       */
      __IM  uint32_t            : 5;
      __IOM uint32_t symen      : 1;            /*!< [31..31] To control the enable of this IR symbol. 1: Enable
                                                     0: Disable                                                                */
    } symcfg7_b;
  } ;
  
  union {
    __IOM uint32_t rxsymt7;                     /*!< (@ 0x00000054) IR RX Symbol Time 7 Register                               */
    
    struct {
      __IOM uint32_t symt_db    : 16;           /*!< [15..0] This filed define the down bond of the period of the
                                                     symbol.                                                                   */
      __IOM uint32_t symt_ub    : 16;           /*!< [31..16] This filed define the up bond of the period of the
                                                     symbol.                                                                   */
    } rxsymt7_b;
  } ;
  
  union {
    __IOM uint32_t rxsymchg;                    /*!< (@ 0x00000058) RX Symbol Change Register                                  */
    
    struct {
      __IOM uint32_t rxsymcode0 : 4;            /*!< [3..0] The symbol code RXSYMCODE0 is replaced with RXSYM0L_PRDC
                                                     and RXSYM0H_PRDC. When the value is zero, this is inactive.               */
      __IM  uint32_t            : 4;
      __IOM uint32_t rxsym0l_prdc : 4;          /*!< [11..8] This is the low symbol code for replacing RXSYMCODE0.When
                                                     the value is zero, this is inactive.                                      */
      __IOM uint32_t rxsym0h_prdc : 4;          /*!< [15..12] This is the high symbol code for replacing RXSYMCODE0.When
                                                     the value is zero, this is inactive.                                      */
      __IOM uint32_t rxsymcode1 : 4;            /*!< [19..16] The symbol code RXSYMCODE1 is replaced with RXSYM1L_PRDC
                                                     and RXSYM1H_PRDC. When the value is zero, this is inactive.               */
      __IM  uint32_t            : 4;
      __IOM uint32_t rxsym1l_prdc : 4;          /*!< [27..24] This is the low symbol code for replacing RXSYMCODE1.When
                                                     the value is zero, this is inactive.                                      */
      __IOM uint32_t rxsym1h_prdc : 4;          /*!< [31..28] This is the high symbol code for replacing RXSYMCODE1.When
                                                     the value is zero, this is inactive.                                      */
    } rxsymchg_b;
  } ;
  
  union {
    __IOM uint32_t rxdcctrl;                    /*!< (@ 0x0000005C) RX Decode Control Register                                 */
    
    struct {
      __IOM uint32_t rxdc_en    : 1;            /*!< [0..0] If RXDC_EN is disable, RX start match is not valid and
                                                     the decode process is inactive. 0: Disable. 1: Enable                     */
      __IOM uint32_t rxfifodis  : 1;            /*!< [1..1] 0: RX FIFO can receive the RX symbol code. 1: RX FIFO
                                                     cannot receive the RX symbol code                                         */
      __IOM uint32_t monitor_en : 1;            /*!< [2..2] Make the monitor match and make MONITOR_EN return to
                                                     0. That monitor the number of bits is MONICNT. 0: Disable.
                                                     1: Enable                                                                 */
      __IM  uint32_t            : 21;
      __IOM uint32_t monicnt    : 5;            /*!< [28..24] When MONITOR_EN is enable, monitor t bits is 0~31:
                                                     monitor 1~32 bit                                                          */
    } rxdcctrl_b;
  } ;
  
  union {
    __IOM uint32_t rxsymdc;                     /*!< (@ 0x00000060) RX Symbol Decode Register                                  */
    
    struct {
      __IOM uint32_t rxsym0l_bit0 : 4;          /*!< [3..0] If decode symbols match (RXSYM0H_BIT0, RXSYM0L_BIT0),
                                                     RX data will receive bit 0. When RXSYM0L_BIT0 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym0h_bit0 : 4;          /*!< [7..4] If decode symbols match (RXSYM0H_BIT0, RXSYM0L_BIT0),
                                                     RX data will receive bit 0. When RXSYM0L_BIT0 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym1l_bit0 : 4;          /*!< [11..8] If decode symbols match (RXSYM1H_BIT0, RXSYM1L_BIT0),
                                                     RX data will receive bit 0. When RXSYM1L_BIT0 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym1h_bit0 : 4;          /*!< [15..12] If decode symbols match (RXSYM1H_BIT0, RXSYM1L_BIT0),
                                                     RX data will receive bit 0. When RXSYM1L_BIT0 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym0l_bit1 : 4;          /*!< [19..16] If decode symbols match (RXSYM0H_BIT1, RXSYM0L_BIT1),
                                                     RX data will receive bit 1. When RXSYM0L_BIT1 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym0h_bit1 : 4;          /*!< [23..20] If decode symbols match (RXSYM0H_BIT1, RXSYM0L_BIT1),
                                                     RX data will receive bit 1. When RXSYM0L_BIT1 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym1l_bit1 : 4;          /*!< [27..24] If decode symbols match (RXSYM1H_BIT1, RXSYM1L_BIT1),
                                                     RX data will receive bit 1. When RXSYM1L_BIT1 is not zero,
                                                     this match is valid.                                                      */
      __IOM uint32_t rxsym1h_bit1 : 4;          /*!< [31..28] If decode symbols match (RXSYM1H_BIT1, RXSYM1L_BIT1),
                                                     RX data will receive bit 1. When RXSYM1L_BIT1 is not zero,
                                                     this match is valid.                                                      */
    } rxsymdc_b;
  } ;
  
  union {
    __IOM uint32_t rxsymstrm;                   /*!< (@ 0x00000064) RX Symbol Start Match Register                             */
    
    struct {
      __IOM uint32_t rxsym0strm_l : 4;          /*!< [3..0] If decode symbols match (RXSYM0STRM_H, RXSYM0STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM0STRM_H,
                                                     RXSYM0STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym0strm_h : 4;          /*!< [7..4] If decode symbols match (RXSYM0STRM_H, RXSYM0STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM0STRM_H,
                                                     RXSYM0STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym1strm_l : 4;          /*!< [11..8] If decode symbols match (RXSYM1STRM_H, RXSYM1STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM1STRM_H,
                                                     RXSYM1STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym1strm_h : 4;          /*!< [15..12] If decode symbols match (RXSYM1STRM_H, RXSYM1STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM1STRM_H,
                                                     RXSYM1STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym2strm_l : 4;          /*!< [19..16] If decode symbols match (RXSYM2STRM_H, RXSYM2STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM2STRM_H,
                                                     RXSYM2STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym2strm_h : 4;          /*!< [23..20] If decode symbols match (RXSYM2STRM_H, RXSYM2STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM2STRM_H,
                                                     RXSYM2STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym3strm_l : 4;          /*!< [27..24] If decode symbols match (RXSYM3STRM_H, RXSYM3STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM3STRM_H,
                                                     RXSYM3STRM_L) is zero, this match is inactive.                            */
      __IOM uint32_t rxsym3strm_h : 4;          /*!< [31..28] If decode symbols match (RXSYM3STRM_H, RXSYM3STRM_L),
                                                     RX start decoding from this pattern. When (RXSYM3STRM_H,
                                                     RXSYM3STRM_L) is zero, this match is inactive.                            */
    } rxsymstrm_b;
  } ;
  
  union {
    __IOM uint32_t rxdatacnt;                   /*!< (@ 0x00000068) RX Data Count Register                                     */
    
    struct {
      __IM  uint32_t rxdatacnt  : 7;            /*!< [6..0] This register is used to count the decode number.                  */
    } rxdatacnt_b;
  } ;
  
  union {
    __IOM uint32_t rxdcdata;                    /*!< (@ 0x0000006C) RX Decode Data Register                                    */
    
    struct {
      __IOM uint32_t rxdcdata   : 32;           /*!< [31..0] When RX receives the end symbol or gets 32 bits, RXDCDATA
                                                     is updated. Receive the data from LSB.                                    */
    } rxdcdata_b;
  } ;
  
  union {
    __IOM uint32_t rxdcdata_dp;                 /*!< (@ 0x00000070) RX Decode Data Duplicate Register                          */
    
    struct {
      __IOM uint32_t rxdcdata_dp : 32;          /*!< [31..0] If RXDCDATA receives 32 bits, RXDCDATA_DP is loaded
                                                     with RXDCDATA. In the monitor mode, write the monitor data
                                                     in this register.                                                         */
    } rxdcdata_dp_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg0;                   /*!< (@ 0x00000074) IR TX Symbol Configuration 0 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg0_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg1;                   /*!< (@ 0x00000078) IR TX Symbol Configuration 1 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg1_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg2;                   /*!< (@ 0x0000007C) IR TX Symbol Configuration 2 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg2_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg3;                   /*!< (@ 0x00000080) IR TX Symbol Configuration 3 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg3_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg4;                   /*!< (@ 0x00000084) IR TX Symbol Configuration 4 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg4_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg5;                   /*!< (@ 0x00000088) IR TX Symbol Configuration 5 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg5_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg6;                   /*!< (@ 0x0000008C) IR TX Symbol Configuration 6 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg6_b;
  } ;
  
  union {
    __IOM uint32_t txsymcfg7;                   /*!< (@ 0x00000090) IR TX Symbol Configuration 7 Register                      */
    
    struct {
      __IOM uint32_t symtccc    : 16;           /*!< [15..0] The symbol type is Carrier symbol: defines the carrier
                                                     clock cycles of the symbol The symbol type is Space symbol:
                                                     defines the period of the symbol                                          */
      __IM  uint32_t            : 8;
      __IOM uint32_t txsymtyp   : 2;            /*!< [25..24] This field is used to configure the symbol type. 0:Space
                                                     symbol with low level: TX output signal level keeps low
                                                     for a given period. 1:Space symbol with high level: TX
                                                     output signal level keeps high for a given period. 2:Carrier
                                                     symbol: carrier clock cycles continuously present on the
                                                     TX output signal.                                                         */
    } txsymcfg7_b;
  } ;
  
  union {
    __IOM uint32_t ier;                         /*!< (@ 0x00000094) Interrupt Enable Register                                  */
    
    struct {
      __IOM uint32_t ie_rxrdy   : 1;            /*!< [0..0] Enable the interrupt of data ready in the RX FIFO. 1:
                                                     Enable 0: Disable                                                         */
      __IOM uint32_t ie_rxhf    : 1;            /*!< [1..1] Enable the interrupt of the RX FIFO is half full. 1:
                                                     Enable 0: Disable                                                         */
      __IOM uint32_t ie_rxaf    : 1;            /*!< [2..2] Enable the interrupt of the RX FIFO is full. 1: Enable
                                                     0: Disable                                                                */
      __IOM uint32_t ie_rxftr   : 1;            /*!< [3..3] Enable the interrupt of the RX filter pattern matched.
                                                     1: Enable 0: Disable                                                      */
      __IOM uint32_t ie_txemp   : 1;            /*!< [4..4] Enable the interrupt of the TX FIFO is empty. 1: Enable
                                                     0: Disable                                                                */
      __IOM uint32_t ie_tx2emp  : 1;            /*!< [5..5] When the TX FIFO is at least 2 bytes of space, this interrupt
                                                     will be asserted. 1: Enable 0: Disable                                    */
      __IOM uint32_t ie_txhe    : 1;            /*!< [6..6] Enable the interrupt of the TX FIFO is half empty. 1:
                                                     Enable 0: Disable                                                         */
      __IOM uint32_t ie_rxld_end : 1;           /*!< [7..7] RXDCDATA is loaded because RX receives the end symbol.
                                                     Enable this interrupt. 1: Enable 0: Disable                               */
      __IOM uint32_t ie_rxld_full : 1;          /*!< [8..8] RXDCDATA_DP is loaded because RXDCDATA gets 32 bits.
                                                     Enable this interrupt. 1: Enable 0: Disable                               */
      __IOM uint32_t ie_rxsym0strm : 1;         /*!< [9..9] When decode symbols match (RXSYM0STRM_H, RXSYM0STRM_L),
                                                     generate an interrupt. 1: Enable 0: Disable                               */
      __IOM uint32_t ie_rxsym1strm : 1;         /*!< [10..10] When decode symbols match (RXSYM1STRM_H, RXSYM1STRM_L),
                                                     generate an interrupt. 1: Enable 0: Disable                               */
      __IOM uint32_t ie_monitor : 1;            /*!< [11..11] When the monitor value of RXDCDATA_DP is equal to the
                                                     monitor value of RXDCDATA in the RX monitor mode, it can
                                                     generate an interrupt. 1: Enable 0: Disable                               */
    } ier_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x00000098) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t im_rxrdy   : 1;            /*!< [0..0] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxhf    : 1;            /*!< [1..1] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxaf    : 1;            /*!< [2..2] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxftr   : 1;            /*!< [3..3] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_txemp   : 1;            /*!< [4..4] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_tx2emp  : 1;            /*!< [5..5] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_txhe    : 1;            /*!< [6..6] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxld_end : 1;           /*!< [7..7] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxld_full : 1;          /*!< [8..8] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxsym0strm : 1;         /*!< [9..9] 1: Mask the interrupt 0: Un-Mask                                   */
      __IOM uint32_t im_rxsym1strm : 1;         /*!< [10..10] 1: Mask the interrupt 0: Un-Mask                                 */
      __IOM uint32_t im_monitor : 1;            /*!< [11..11] 1: Mask the interrupt 0: Un-Mask                                 */
    } imr_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x0000009C) Interrupt Status Register                                  */
    
    struct {
      __IOM uint32_t is_rxrdy   : 1;            /*!< [0..0] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxhf    : 1;            /*!< [1..1] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxaf    : 1;            /*!< [2..2] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxftr   : 1;            /*!< [3..3] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_txemp   : 1;            /*!< [4..4] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_tx2emp  : 1;            /*!< [5..5] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_txhe    : 1;            /*!< [6..6] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxld_end : 1;           /*!< [7..7] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxld_full : 1;          /*!< [8..8] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxsym0strm : 1;         /*!< [9..9] 1: interrupt is pending 0: no interrupt Write 1 to this
                                                     bit will clear this interrupt status.                                     */
      __IOM uint32_t is_rxsym1strm : 1;         /*!< [10..10] 1: interrupt is pending 0: no interrupt Write 1 to
                                                     this bit will clear this interrupt status.                                */
      __IOM uint32_t is_monitor : 1;            /*!< [11..11] 1: interrupt is pending 0: no interrupt Write 1 to
                                                     this bit will clear this interrupt status.                                */
    } isr_b;
  } ;
  
  union {
    __IOM uint32_t rfc;                         /*!< (@ 0x000000A0) IR RX Filter Control Register                              */
    
    struct {
      __IOM uint32_t rfsn       : 4;            /*!< [3..0] This field define the number of patterns should be used
                                                     to check the IR RX received symbol codes.                                 */
      __IM  uint32_t            : 4;
      __IOM uint32_t rfto       : 16;           /*!< [23..8] This field defines a timeout value for the waiting of
                                                     a new RX symbol code to be shifted into the IR RX filter.                 */
      __IM  uint32_t            : 5;
      __IOM uint32_t rftoen     : 1;            /*!< [29..29] This bit is used to control the IR RX filter timeout
                                                     function enabling. 0: no timeout (timeout function is disabled).
                                                     1: timeout function is enabled.                                           */
      __IOM uint32_t rfrst      : 1;            /*!< [30..30] This bit is used to reset the IR RX filter. 0: reset
                                                     signal is released, normal works 1: reset the RX filter                   */
      __IOM uint32_t rfen       : 1;            /*!< [31..31] This bit is used to control the IR RX filter function
                                                     enabling. 0: IR RX filter function is disabled 1: IR RX
                                                     filter function is enabled                                                */
    } rfc_b;
  } ;
  
  union {
    __IOM uint32_t rfpat0;                      /*!< (@ 0x000000A4) IR RX Filter Pattern 0 Register                            */
    
    struct {
      __IOM uint32_t rfpt0      : 4;            /*!< [3..0] The pattern to compare with the IR RX symbol code                  */
      __IOM uint32_t rfpt1      : 4;            /*!< [7..4] The pattern to compare with the IR RX symbol code                  */
      __IOM uint32_t rfpt2      : 4;            /*!< [11..8] The pattern to compare with the IR RX symbol code                 */
      __IOM uint32_t rfpt3      : 4;            /*!< [15..12] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt4      : 4;            /*!< [19..16] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt5      : 4;            /*!< [23..20] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt6      : 4;            /*!< [27..24] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt7      : 4;            /*!< [31..28] The pattern to compare with the IR RX symbol code                */
    } rfpat0_b;
  } ;
  
  union {
    __IOM uint32_t rfpat1;                      /*!< (@ 0x000000A8) IR RX Filter Pattern 0 Register                            */
    
    struct {
      __IOM uint32_t rfpt8      : 4;            /*!< [3..0] The pattern to compare with the IR RX symbol code                  */
      __IOM uint32_t rfpt9      : 4;            /*!< [7..4] The pattern to compare with the IR RX symbol code                  */
      __IOM uint32_t rfpt10     : 4;            /*!< [11..8] The pattern to compare with the IR RX symbol code                 */
      __IOM uint32_t rfpt11     : 4;            /*!< [15..12] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt12     : 4;            /*!< [19..16] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt13     : 4;            /*!< [23..20] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt14     : 4;            /*!< [27..24] The pattern to compare with the IR RX symbol code                */
      __IOM uint32_t rfpt15     : 4;            /*!< [31..28] The pattern to compare with the IR RX symbol code                */
    } rfpat1_b;
  } ;
} CIR_Type;                                     /*!< Size = 172 (0xac)                                                         */



/* =========================================================================================================================== */
/* ================                                           GDMA0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA IP in low power platform with AXI interface. Only support up to 4092 data items. Common register struct for all channels (GDMA0)
  */

typedef struct {                                /*!< (@ 0xA00602C0) GDMA0 Structure                                            */
  
  union {
    __IM  uint32_t raw_tfr;                     /*!< (@ 0x00000000) IntTfr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_tfr    : 4;            /*!< [3..0] Raw interrupt status of transfer complete                          */
    } raw_tfr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t raw_block;                   /*!< (@ 0x00000008) IntBlock Raw Interrupt Status Register                     */
    
    struct {
      __IM  uint32_t raw_block  : 4;            /*!< [3..0] Raw interrupt status of one block transfer complete                */
    } raw_block_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t raw_src_tran;                /*!< (@ 0x00000010) IntSrcTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_src_tran : 4;          /*!< [3..0] Raw interrupt status of source transfer complete                   */
    } raw_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IM  uint32_t raw_dst_tran;                /*!< (@ 0x00000018) IntDstTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_dst_tran : 4;          /*!< [3..0] Raw interrupt status of destination transfer complete              */
    } raw_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t raw_err;                     /*!< (@ 0x00000020) IntErr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_err    : 4;            /*!< [3..0] Raw interrupt status of transfer error                             */
    } raw_err_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IM  uint32_t status_tfr;                  /*!< (@ 0x00000028) IntTfr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_tfr : 4;            /*!< [3..0] Interrupt status of transfer complete                              */
    } status_tfr_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IM  uint32_t status_block;                /*!< (@ 0x00000030) IntBlock Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t status_block : 4;          /*!< [3..0] Interrupt status of one block transfer complete                    */
    } status_block_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IM  uint32_t status_src_tran;             /*!< (@ 0x00000038) IntSrcTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_src_tran : 4;       /*!< [3..0] Interrupt status of source transfer complete                       */
    } status_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IM  uint32_t status_dst_tran;             /*!< (@ 0x00000040) IntDstTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_dst_tran : 4;       /*!< [3..0] Interrupt status of destination transfer complete                  */
    } status_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IM  uint32_t status_err;                  /*!< (@ 0x00000048) IntErr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_err : 4;            /*!< [3..0] Interrupt status of transfer error                                 */
    } status_err_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t mask_tfr;                    /*!< (@ 0x00000050) IntTfr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_tfr   : 4;            /*!< [3..0] Interrupt mask of transfer complete                                */
    } mask_tfr_b;
  } ;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t mask_block;                  /*!< (@ 0x00000058) IntBlock Interrupt Mask Register                           */
    
    struct {
      __IOM uint32_t mask_block : 4;            /*!< [3..0] Interrupt mask of one block transfer complete                      */
    } mask_block_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t mask_src_tran;               /*!< (@ 0x00000060) IntSrcTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_src_tran : 4;         /*!< [3..0] Interrupt mask of source transfer complete                         */
    } mask_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t mask_dst_tran;               /*!< (@ 0x00000068) IntDstTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_dst_tran : 4;         /*!< [3..0] Interrupt mask of destination transfer complete                    */
    } mask_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t mask_err;                    /*!< (@ 0x00000070) IntErr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_err   : 4;            /*!< [3..0] Interrupt mask of transfer error                                   */
    } mask_err_b;
  } ;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t clear_tfr;                   /*!< (@ 0x00000078) IntTfr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t status_tfr : 4;            /*!< [3..0] Clear interrupt status of transfer complete                        */
    } clear_tfr_b;
  } ;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t clear_block;                 /*!< (@ 0x00000080) IntBlock Interrupt Clear Register                          */
    
    struct {
      __OM  uint32_t clear_block : 4;           /*!< [3..0] Clear interrupt status of one block transfer complete              */
    } clear_block_b;
  } ;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t clear_src_tran;              /*!< (@ 0x00000088) IntSrcTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_src_tran : 4;        /*!< [3..0] Clear interrupt status of source transfer complete                 */
    } clear_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t clear_dst_tran;              /*!< (@ 0x00000090) IntDstTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_dst_tran : 4;        /*!< [3..0] Clear interrupt status of destination transfer complete            */
    } clear_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint32_t clear_err;                   /*!< (@ 0x00000098) IntErr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t clear_err  : 4;            /*!< [3..0] Clear interrupt status of transfer error                           */
    } clear_err_b;
  } ;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IM  uint32_t status_int;                  /*!< (@ 0x000000A0) Combined Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t tfr        : 1;            /*!< [0..0] OR of the contents of StatusTfr register                           */
      __IM  uint32_t block      : 1;            /*!< [1..1] OR of the contents of StatusBlock register                         */
      __IM  uint32_t srct       : 1;            /*!< [2..2] OR of the contents of StatusSrcTran register                       */
      __IM  uint32_t dstt       : 1;            /*!< [3..3] OR of the contents of StatusDstTran register                       */
      __IM  uint32_t err        : 1;            /*!< [4..4] OR of the contents of StatusErr register                           */
    } status_int_b;
  } ;
  __IM  uint32_t  RESERVED20[13];
  
  union {
    __IOM uint32_t dma_cfg_reg;                 /*!< (@ 0x000000D8) Configuration Register                                     */
    
    struct {
      __IOM uint32_t dma_en     : 1;            /*!< [0..0] RTK_DMAC Enable bit. 0 : Disable, 1 : Enable                       */
    } dma_cfg_reg_b;
  } ;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint32_t ch_en_reg;                   /*!< (@ 0x000000E0) Channel Enable Register                                    */
    
    struct {
      __IOM uint32_t ch_en      : 4;            /*!< [3..0] Enables/Disables the channel. Setting this bit enables
                                                     a channel while clearing this bit disables the channel.
                                                     0 : Disable the Channel 1 : Enable the Channel The ChEnReg.CH_EN
                                                     bit is automatically cleared by hardware to disable the
                                                     channel after the last AXI transfer of the DMA transfer
                                                     to the destination has completed. Software can therefore
                                                     poll this bit to determine when this channel is free for
                                                     a new DMA transfer.                                                       */
      __IM  uint32_t            : 4;
      __OM  uint32_t ch_en_we   : 4;            /*!< [11..8] Channel enable write enable                                       */
    } ch_en_reg_b;
  } ;
  __IM  uint32_t  RESERVED22[5];
  
  union {
    __IOM uint32_t ch_reset_reg;                /*!< (@ 0x000000F8) Channel Reset Register                                     */
    
    struct {
      __IOM uint32_t ch_reset_en : 4;           /*!< [3..0] Reset channel enable. Set this bit to reset a channel;
                                                     clear this bit to finish the reset flow and release the
                                                     channel. 0 : reset the channel finish 1 : reset the channel
                                                     start The reset bit is not automatically cleared by hardware.
                                                     Software must clear it to finish software reset.                          */
      __IM  uint32_t            : 4;
      __IM  uint32_t ch_reset_en_we : 4;        /*!< [11..8] Channel reset write enable                                        */
    } ch_reset_reg_b;
  } ;
} GDMA0_Type;                                   /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                            CH0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA control registers for specific channels (CH0)
  */

typedef struct {                                /*!< (@ 0xA0060000) CH0 Structure                                              */
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000000) Source Address Register for Channel x                      */
    
    struct {
      __IOM uint32_t sar        : 32;           /*!< [31..0] Source Address of DMA transfer. Updated after each source
                                                     transfer. The SINC field in the CTLx register determines
                                                     whether the address increments, decrements, or is left
                                                     unchanged on every source transfer throughout the block
                                                     transfer.                                                                 */
    } sar_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t dar;                         /*!< (@ 0x00000008) Destination Address Register for Channel x                 */
    
    struct {
      __IOM uint32_t dar        : 32;           /*!< [31..0] Destination address of DMA transfer. Updated after each
                                                     destination transfer. The DINC field in the CTLx register
                                                     determines whether the address increments, decrements,
                                                     or is left unchanged on every destination transfer throughout
                                                     the block transfer                                                        */
    } dar_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t ctl_low;                     /*!< (@ 0x00000018) Lower Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t int_en     : 1;            /*!< [0..0] If set, then all interrupt-generating sources are enabled.
                                                     Functions as a global mask bit for all interrupts for the
                                                     channel. Raw interrupt registers still assert if this field
                                                     is 0.                                                                     */
      __IOM uint32_t dst_tr_width : 3;          /*!< [3..1] Destination Transfer Width. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t src_tr_width : 3;          /*!< [6..4] Source Transfer Width. The block_ts field should be modified
                                                     in accordance with this field. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t dinc       : 2;            /*!< [8..7] Destination Address Increment. Indicate whether to increment
                                                     to destination address on every destination transfer. If
                                                     the device is fetching data from a destination peripheral
                                                     FIFO with a fixed adress, then this field should be set
                                                     to No Change. 0x00 : Increment, 0x1x : NoChange.                          */
      __IOM uint32_t sinc       : 2;            /*!< [10..9] Source Address Increment. Indicate whether to increment
                                                     to source address on every source transfer. If the device
                                                     is fetching data from a source peripheral FIFO with a fixed
                                                     adress, then this field should be set to No Change. 0x00
                                                     : Increment, 0x1x : NoChange.                                             */
      __IOM uint32_t dest_msize : 3;            /*!< [13..11] Destination Burst Transaction Length. Number of data
                                                     items, each of width ctl.dst_tr_width, to be read from
                                                     the destination every time a destination burst transaction
                                                     request is mode.                                                          */
      __IOM uint32_t src_msize  : 3;            /*!< [16..14] Source Burst Transaction Length. Number of data items,
                                                     each of width ctl.src_tr_width, to be read from the source
                                                     every time a source burst transaction request is mode.                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t tt_fc      : 3;            /*!< [22..20] Transfer Type and Flow Control. The following transfer
                                                     types are supported. Memory to Memory, Memory to Peripheral,
                                                     Peripheral to Memory.                                                     */
      __IM  uint32_t            : 4;
      __IOM uint32_t llp_dst_en : 1;            /*!< [27..27] Block chaining is enabled on the destination side if
                                                     this field is high and llp.loc is non-zero. Not supported
                                                     in LP-GDMA.                                                               */
      __IOM uint32_t llp_src_en : 1;            /*!< [28..28] Block chaining is enabled on the source side if this
                                                     field is high and llp.loc is non-zero. Not supported in
                                                     LP-GDMA.                                                                  */
    } ctl_low_b;
  } ;
  
  union {
    __IOM uint32_t ctl_up;                      /*!< (@ 0x0000001C) Upper Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t block_ts   : 12;           /*!< [11..0] Block Transfer Size. When the RTK_DMAC is the flow controller,
                                                     the user writes this field before the channel is enabled
                                                     in order to indicate the block size. The block_ts should
                                                     be modified according to the src_tr_width field. Ex: If
                                                     src_tr_width = 4 byte, block_ts >>= 2.                                    */
    } ctl_up_b;
  } ;
  __IM  uint32_t  RESERVED2[8];
  
  union {
    __IOM uint32_t cfg_low;                     /*!< (@ 0x00000040) Lower Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IOM uint32_t inactive   : 1;            /*!< [0..0] Indicate the channel is inactive or not. 1: Inactive
                                                     state, 0: Active state.                                                   */
      __IM  uint32_t            : 7;
      __IOM uint32_t ch_susp    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared. There is no guarantee
                                                     that the current transaction will complete. Can also be
                                                     used in conjunction with CFGx.FIFO_EMPTY to cleanly disable
                                                     a channel without losing any data. 0 : Not suspended, 1
                                                     : Suspend DMA transfer from the source                                    */
      __IM  uint32_t fifo_empty : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.
                                                     Can be used in conjunction with CFGx.CH_SUSP to cleanly
                                                     disable a channel. 1 : Channel FIFO empty, 0 : Channel
                                                     FIFO not empty.                                                           */
      __IM  uint32_t            : 8;
      __IOM uint32_t dst_hs_pol : 1;            /*!< [18..18] Destination Handshaking Interface Polarity. 0 : Active
                                                     high, 1: Active low                                                       */
      __IOM uint32_t src_hs_pol : 1;            /*!< [19..19] Source Handshaking Interface Polarity. 0 : Active high,
                                                     1: Active low                                                             */
      __IOM uint32_t max_abrst  : 10;           /*!< [29..20] Maximum OCP Burst Length. Maximum OCP burst length
                                                     that is used for DMA transfers on this channel.                           */
      __IOM uint32_t reload_src : 1;            /*!< [30..30] Automatic Source Reload. The SAR register can be automatically
                                                     reloaded from its initial value at the end of every block
                                                     for multi-block transfers. Not support in LP-GDMA.                        */
      __IOM uint32_t reload_dst : 1;            /*!< [31..31] Automatic Destination Reload. The DAR register can
                                                     be automatically reloaded from its initial value at the
                                                     end of every block for multi-block transfers. Not support
                                                     in LP-GDMA.                                                               */
    } cfg_low_b;
  } ;
  
  union {
    __IOM uint32_t cfg_up;                      /*!< (@ 0x00000044) Upper Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IM  uint32_t            : 7;
      __IOM uint32_t src_per    : 4;            /*!< [10..7] Assigns a hardware handshaking interface to the source
                                                     of channels. The channel can then communicate with the
                                                     source peripheral connected to that interface through the
                                                     assigned hardware handshaking interface.                                  */
      __IOM uint32_t dest_per   : 4;            /*!< [14..11] Assigns a hardware handshaking interface to the destination
                                                     of channels. The channel can then communicate with the
                                                     destination peripheral connected to that interface through
                                                     the assigned hardware handshaking interface.                              */
      __IOM uint32_t extended_src_per : 1;      /*!< [15..15] The extened 4th bit of src_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
      __IOM uint32_t extended_dest_per : 1;     /*!< [16..16] The extened 4th bit of dest_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
    } cfg_up_b;
  } ;
} CH0_Type;                                     /*!< Size = 72 (0x48)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define ICC_H_BASE                  0x40002B80UL
#define SPIC_BASE                   0x40006000UL
#define RTC_BASE                    0xA0000080UL
#define ICC_L_BASE                  0xA00002B0UL
#define GPIO_BASE                   0xA0001000UL
#define TG0_BASE                    0xA0002000UL
#define TM0_BASE                    0xA0002040UL
#define TM1_BASE                    0xA0002080UL
#define TM2_BASE                    0xA00020C0UL
#define TM3_BASE                    0xA0002100UL
#define TM4_BASE                    0xA0002140UL
#define TM5_BASE                    0xA0002180UL
#define TM6_BASE                    0xA00021C0UL
#define TM7_BASE                    0xA0002200UL
#define PWM_COMM_BASE               0xA0003000UL
#define PWM0_BASE                   0xA0003020UL
#define PWM1_BASE                   0xA0003040UL
#define PWM2_BASE                   0xA0003060UL
#define PWM3_BASE                   0xA0003080UL
#define PWM4_BASE                   0xA00030A0UL
#define PWM5_BASE                   0xA00030C0UL
#define PWM6_BASE                   0xA00030E0UL
#define PWM7_BASE                   0xA0003100UL
#define ADC_BASE                    0xA0010000UL
#define COMP_BASE                   0xA0010700UL
#define UART0_BASE                  0xA0040000UL
#define UART1_BASE                  0xA0040100UL
#define I2C_BASE                    0xA0044000UL
#define SGPIO_BASE                  0xA0046000UL
#define QDEC_BASE                   0xA0046800UL
#define CIR_BASE                    0xA0047000UL
#define GDMA0_BASE                  0xA00602C0UL
#define CH0_BASE                    0xA0060000UL
#define CH1_BASE                    0xA0060058UL
#define CH2_BASE                    0xA00600B0UL
#define CH3_BASE                    0xA0060108UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define ICC_H                       ((ICC_H_Type*)             ICC_H_BASE)
#define SPIC                        ((SPIC_Type*)              SPIC_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define ICC_L                       ((ICC_L_Type*)             ICC_L_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define TG0                         ((TG0_Type*)               TG0_BASE)
#define TM0                         ((TM0_Type*)               TM0_BASE)
#define TM1                         ((TM0_Type*)               TM1_BASE)
#define TM2                         ((TM0_Type*)               TM2_BASE)
#define TM3                         ((TM0_Type*)               TM3_BASE)
#define TM4                         ((TM0_Type*)               TM4_BASE)
#define TM5                         ((TM0_Type*)               TM5_BASE)
#define TM6                         ((TM0_Type*)               TM6_BASE)
#define TM7                         ((TM0_Type*)               TM7_BASE)
#define PWM_COMM                    ((PWM_COMM_Type*)          PWM_COMM_BASE)
#define PWM0                        ((PWM0_Type*)              PWM0_BASE)
#define PWM1                        ((PWM0_Type*)              PWM1_BASE)
#define PWM2                        ((PWM0_Type*)              PWM2_BASE)
#define PWM3                        ((PWM0_Type*)              PWM3_BASE)
#define PWM4                        ((PWM0_Type*)              PWM4_BASE)
#define PWM5                        ((PWM0_Type*)              PWM5_BASE)
#define PWM6                        ((PWM0_Type*)              PWM6_BASE)
#define PWM7                        ((PWM0_Type*)              PWM7_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define COMP                        ((COMP_Type*)              COMP_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define I2C                         ((I2C_Type*)               I2C_BASE)
#define SGPIO                       ((SGPIO_Type*)             SGPIO_BASE)
#define QDEC                        ((QDEC_Type*)              QDEC_BASE)
#define CIR                         ((CIR_Type*)               CIR_BASE)
#define GDMA0                       ((GDMA0_Type*)             GDMA0_BASE)
#define CH0                         ((CH0_Type*)               CH0_BASE)
#define CH1                         ((CH0_Type*)               CH1_BASE)
#define CH2                         ((CH0_Type*)               CH2_BASE)
#define CH3                         ((CH0_Type*)               CH3_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* RTL8195BLP_H */


/** @} */ /* End of group rtl8195blp */

/** @} */ /* End of group Realtek Semiconductor Corp. */
