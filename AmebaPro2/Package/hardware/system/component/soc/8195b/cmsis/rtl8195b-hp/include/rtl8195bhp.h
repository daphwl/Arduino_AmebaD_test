/**************************************************************************//**
 * @file     rtl8195bhp.h
 * @brief    CMSIS HeaderFile
 * @version  1.0
 * @date     28. July 2017
 * @note     Generated by SVDConv V3.3.9 on Friday, 28.07.2017 15:28:50
 *           from File 'rtl8195b-hp.svd',
 *           last modified on Friday, 28.07.2017 07:23:27
 ******************************************************************************/
/*
 * Copyright(c) 2007 - 2016 Realtek Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0 
 * Licensed under the Apache License, Version 2.0 (the License); you may 
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 *
 */



/** @addtogroup Realtek Realtek Semiconductor Corp.
  * @{
  */


/** @addtogroup rtl8195bhp
  * @{
  */


#ifndef RTL8195BHP_H
#define RTL8195BHP_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

enum {
/* ========================================  ARM ARMV8MML Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SecureFault_IRQn          =  -9,              /*!< -9 Secure Fault Handler                                                   */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* =========================================  rtl8195bhp Specific Interrupt Numbers  ========================================= */
  SystemOn_IRQn             =   0,              /*!< 0  SystemOn                                                               */
  TimerGroup0_IRQn          =   1,              /*!< 1  TimerGroup0                                                            */
  TimerGroup1_IRQn          =   2,              /*!< 2  TimerGroup1                                                            */
  GPIO_IRQn                 =   3,              /*!< 3  GPIO                                                                   */
  PWM_IRQn                  =   4,              /*!< 4  PWM                                                                    */
  ADC_IRQn                  =   5,              /*!< 5  ADC                                                                    */
  SGPIO_IRQn                =   6,              /*!< 6  SGPIO                                                                  */
  UART_IRQn                 =   7,              /*!< 7  UART                                                                   */
  I2C_IRQn                  =   8,              /*!< 8  I2C                                                                    */
  SSI_IRQn                  =   9,              /*!< 9  SSI                                                                    */
  I2S_IRQn                  =  10,              /*!< 10 I2S                                                                    */
  I3C_IRQn                  =  11,              /*!< 11 I3C                                                                    */
  USB_IRQn                  =  12,              /*!< 12 USB                                                                    */
  SDIOH_IRQn                =  13,              /*!< 13 SDIOH                                                                  */
  SDIOD_IRQn                =  14,              /*!< 14 SDIOD                                                                  */
  ETHERNET_IRQn             =  15,              /*!< 15 ETHERNET                                                               */
  WLAN_IRQn                 =  16,              /*!< 16 WLAN                                                                   */
  GDMA0_IRQn                =  17,              /*!< 17 GDMA0                                                                  */
  GDMA1_IRQn                =  18,              /*!< 18 GDMA1                                                                  */
  Crypto_IRQn               =  19,              /*!< 19 Crypto                                                                 */
  SPIC_IRQn                 =  20,              /*!< 20 SPIC                                                                   */
  ICC_IRQn                  =  21,              /*!< 21 ICC                                                                    */
  ISP_IRQn                  =  22,              /*!< 22 ISP                                                                    */
  H264_IRQn                 =  23,              /*!< 23 H264                                                                   */
  VOE_IRQn                  =  24,              /*!< 24 VOE                                                                    */
  TFT_IRQn                  =  25,              /*!< 25 TFT                                                                    */
  MJPG_IRQn                 =  26,              /*!< 26 MJPG                                                                   */
  SGDMA0_IRQn               =  27,              /*!< 27 SGDMA0                                                                 */
  SGDMA1_IRQn               =  28,              /*!< 28 SGDMA1                                                                 */
  SCrypto_IRQn              =  29,              /*!< 29 SCrypto                                                                */
  SLowPri_IRQn              =  30,              /*!< 30 SLowPri                                                                */
  LowPri_IRQn               =  31               /*!< 31 LowPri                                                                 */
};
typedef int32_t IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM ARMV8MML Processor and Core Peripherals  ============================ */
#define __ARMV8MML_REV                 0x0000U  /*!< ARMV8MML Core Revision                                                    */
#define __NVIC_PRIO_BITS               4        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present or not                                                        */
#define __FPU_PRESENT                  1        /*!< FPU present or not                                                        */
#define __FPU_DP                       0        /*!< Double Precision FPU                                                      */
#define __SAUREGION_PRESENT            1        /*!< SAU present or not                                                        */
#define __DSP_PRESENT                  1        /*!< DSP extension present                                                     */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_armv8mml.h"                      /*!< ARM ARMV8MML processor and core peripherals                               */
#include "system_rtl8195bhp.h"                  /*!< rtl8195bhp System                                                         */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          _SYSON                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief HS System Power Control (_SYSON)
  */

typedef struct {                                /*!< (@ 0x40000000) _SYSON Structure                                           */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} _SYSON_Type;                                  /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose I/O (GPIO)
  */

typedef struct {                                /*!< (@ 0x40001000) GPIO Structure                                             */
  
  union {
    __IM  uint32_t it_sts;                      /*!< (@ 0x00000000) GPIO interrupt type status Register                        */
    
    struct {
      __IM  uint32_t gpio_it_sts : 16;          /*!< [15..0] For each bit: 0: the specific GPIO pin is configured
                                                     to edge sensitive interrupt mode 1: the specific GPIO pin
                                                     is configured to levle sensitive interrupt mode.                          */
    } it_sts_b;
  } ;
  
  union {
    __IOM uint32_t ei_en;                       /*!< (@ 0x00000004) GPIO edge sensitive interrupt mode enable                  */
    
    struct {
      __IOM uint32_t ei_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as edge sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as zero.                                                       */
    } ei_en_b;
  } ;
  
  union {
    __IOM uint32_t li_en;                       /*!< (@ 0x00000008) GPIO level sensitive interrupt mode enable                 */
    
    struct {
      __IOM uint32_t li_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as level sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as 1.                                                          */
    } li_en_b;
  } ;
  
  union {
    __IM  uint32_t ip_sts;                      /*!< (@ 0x0000000C) GPIO interrupt polarity status                             */
    
    struct {
      __IM  uint32_t ip_sts0    : 2;            /*!< [1..0] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts1    : 2;            /*!< [3..2] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts2    : 2;            /*!< [5..4] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts3    : 2;            /*!< [7..6] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts4    : 2;            /*!< [9..8] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts5    : 2;            /*!< [11..10] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts6    : 2;            /*!< [13..12] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts7    : 2;            /*!< [15..14] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts8    : 2;            /*!< [17..16] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts9    : 2;            /*!< [19..18] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts10   : 2;            /*!< [21..20] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts11   : 2;            /*!< [23..22] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts12   : 2;            /*!< [25..24] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts13   : 2;            /*!< [27..26] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts14   : 2;            /*!< [29..28] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts15   : 2;            /*!< [31..30] The interrupt polarity status of GPIO15                          */
    } ip_sts_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ir_en;                       /*!< (@ 0x00000014) GPIO interrupt rising-edge enable                          */
    
    struct {
      __IOM uint32_t ir_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to rising-edge interrupt mode or
                                                     high-level mode (depends on REG_GPIO_IT_STS) and also cause
                                                     the corresponding bits of REG_GPIO_IP_STS to be read as
                                                     00b.                                                                      */
    } ir_en_b;
  } ;
  
  union {
    __IOM uint32_t if_en;                       /*!< (@ 0x00000018) GPIO interrupt falling-edge enable                         */
    
    struct {
      __IOM uint32_t if_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to falling-edge interrupt mode or
                                                     low-level interrupt mode (depends on REG_GPIO_IT_STS) and
                                                     cause the corresponding bits of REG_GPIO_IP_STS to be read
                                                     as 01b.                                                                   */
    } if_en_b;
  } ;
  
  union {
    __IOM uint32_t id_en;                       /*!< (@ 0x0000001C) GPIO interrupt dual-edge enable                            */
    
    struct {
      __IOM uint32_t id_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to dual-edge interrupt mode and
                                                     also cause the corresponding bits of REG_GPIO_IP_STS to
                                                     be read as 10b.                                                           */
    } id_en_b;
  } ;
  
  union {
    __IM  uint32_t ie_sts;                      /*!< (@ 0x00000020) GPIO interrupt enable status                               */
    
    struct {
      __IM  uint32_t ie_sts     : 16;           /*!< [15..0] For each bit: 0: the interrupt of the specific GPIO
                                                     pin is disabled 1: the interrupt of the specific GPIO pin
                                                     is enabled                                                                */
    } ie_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_en;                      /*!< (@ 0x00000024) GPIO interrupt enable                                      */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to enable the
                                                     specific GPIO INT and also cause the specified bit of REG_GPIO_IE_STS
                                                     to be read as ONE.                                                        */
    } int_en_b;
  } ;
  
  union {
    __IOM uint32_t int_dis;                     /*!< (@ 0x00000028) GPIO interrupt disable                                     */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to disable the
                                                     specified GPIO INT and also cause the specified bit of
                                                     REG_GPIO_IE_STS to be read as ZERO.                                       */
    } int_dis_b;
  } ;
  
  union {
    __IM  uint32_t int_raw_sts;                 /*!< (@ 0x0000002C) GPIO RAW interrupt status                                  */
    
    struct {
      __IM  uint32_t int_raw_sts : 16;          /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending
                                                     (permasking)                                                              */
    } int_raw_sts_b;
  } ;
  
  union {
    __IM  uint32_t int_sts;                     /*!< (@ 0x00000030) GPIO interrupt status                                      */
    
    struct {
      __IM  uint32_t int_sts    : 16;           /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending                */
    } int_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_clr;                     /*!< (@ 0x00000034) GPIO interrupt status clear                                */
    
    struct {
      __IOM uint32_t int_clr    : 16;           /*!< [15..0] For each bit writting: 0: No operation; 1: Clear edge
                                                     type pending interrupt of the conrtolled GPIO pin and clear
                                                     the specified bits of REG_GPIO_INT_STS as ZERO                            */
    } int_clr_b;
  } ;
  
  union {
    __IM  uint32_t int_func_en_sts;             /*!< (@ 0x00000038) GPIO interrupt function enable status                      */
    
    struct {
      __IM  uint32_t int_en_sts : 16;           /*!< [15..0] For each bit: 0: the specified GPIO INT is Disable 1:
                                                     the specified GPIO INT is Enable                                          */
    } int_func_en_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_func_en;                 /*!< (@ 0x0000003C) GPIO interrupt function enable                             */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is enabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ONE.                               */
    } int_func_en_b;
  } ;
  
  union {
    __IOM uint32_t int_func_dis;                /*!< (@ 0x00000040) GPIO interrupt function disable                            */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is disabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ZERO.                              */
    } int_func_dis_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t int0_sel;                    /*!< (@ 0x00000050) GPIO INT0 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT0                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT0                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int0_sel_b;
  } ;
  
  union {
    __IOM uint32_t int1_sel;                    /*!< (@ 0x00000054) GPIO INT1 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT1                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT1                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int1_sel_b;
  } ;
  
  union {
    __IOM uint32_t int2_sel;                    /*!< (@ 0x00000058) GPIO INT2 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT2                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT2                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int2_sel_b;
  } ;
  
  union {
    __IOM uint32_t int3_sel;                    /*!< (@ 0x0000005C) GPIO INT3 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT3                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT3                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int3_sel_b;
  } ;
  
  union {
    __IOM uint32_t int4_sel;                    /*!< (@ 0x00000060) GPIO INT4 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT4                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT4                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int4_sel_b;
  } ;
  
  union {
    __IOM uint32_t int5_sel;                    /*!< (@ 0x00000064) GPIO INT5 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT5                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT5                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int5_sel_b;
  } ;
  
  union {
    __IOM uint32_t int6_sel;                    /*!< (@ 0x00000068) GPIO INT6 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT6                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT6                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int6_sel_b;
  } ;
  
  union {
    __IOM uint32_t int7_sel;                    /*!< (@ 0x0000006C) GPIO INT7 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT7                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT7                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int7_sel_b;
  } ;
  
  union {
    __IOM uint32_t int8_sel;                    /*!< (@ 0x00000070) GPIO INT8 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT8                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT8                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int8_sel_b;
  } ;
  
  union {
    __IOM uint32_t int9_sel;                    /*!< (@ 0x00000074) GPIO INT9 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT9                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT9                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int9_sel_b;
  } ;
  
  union {
    __IOM uint32_t int10_sel;                   /*!< (@ 0x00000078) GPIO INT10 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT10                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT10                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int10_sel_b;
  } ;
  
  union {
    __IOM uint32_t int11_sel;                   /*!< (@ 0x0000007C) GPIO INT11 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT11                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT11                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int11_sel_b;
  } ;
  
  union {
    __IOM uint32_t int12_sel;                   /*!< (@ 0x00000080) GPIO INT12 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT12                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT12                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int12_sel_b;
  } ;
  
  union {
    __IOM uint32_t int13_sel;                   /*!< (@ 0x00000084) GPIO INT13 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT13                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT13                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int13_sel_b;
  } ;
  
  union {
    __IOM uint32_t int14_sel;                   /*!< (@ 0x00000088) GPIO INT14 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT14                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT14                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int14_sel_b;
  } ;
  
  union {
    __IOM uint32_t int15_sel;                   /*!< (@ 0x0000008C) GPIO INT15 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT15                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT15                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int15_sel_b;
  } ;
  __IM  uint32_t  RESERVED2[24];
  
  union {
    __IM  uint32_t deb_sts;                     /*!< (@ 0x000000F0) GPIO port debounce status                                  */
    
    struct {
      __IM  uint32_t deb_sts    : 16;           /*!< [15..0] For each bit: 0: the specific GPIO debounce pin is DISABLE
                                                     debounce 1: the specific GPIO debounce pin is ENABLE debounce             */
    } deb_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb_en;                      /*!< (@ 0x000000F4) GPIO debounce pin enable                                   */
    
    struct {
      __IOM uint32_t deb_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is enabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ONE.                                */
    } deb_en_b;
  } ;
  
  union {
    __IOM uint32_t deb_dis;                     /*!< (@ 0x000000F8) GPIO debounce pin disable                                  */
    
    struct {
      __IOM uint32_t deb_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is disabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ZERO.                               */
    } deb_dis_b;
  } ;
  
  union {
    __IM  uint32_t deb_dp_sts;                  /*!< (@ 0x000000FC) GPIO debounce data pin status                              */
    
    struct {
      __IM  uint32_t deb_dp_sts : 16;           /*!< [15..0] For each bit reading: read the signal level of the specified
                                                     pin after de-bounce                                                       */
    } deb_dp_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb0_sel;                    /*!< (@ 0x00000100) GPIO debounce0 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce0                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb0_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb1_sel;                    /*!< (@ 0x00000104) GPIO debounce1 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce1                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb1_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb2_sel;                    /*!< (@ 0x00000108) GPIO debounce2 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce2                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb2_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb3_sel;                    /*!< (@ 0x0000010C) GPIO debounce3 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce3                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb3_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb4_sel;                    /*!< (@ 0x00000110) GPIO debounce4 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce4                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb4_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb5_sel;                    /*!< (@ 0x00000114) GPIO debounce5 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce5                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb5_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb6_sel;                    /*!< (@ 0x00000118) GPIO debounce6 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce6                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb6_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb7_sel;                    /*!< (@ 0x0000011C) GPIO debounce7 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce7                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb7_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb8_sel;                    /*!< (@ 0x00000120) GPIO debounce8 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce8                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb8_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb9_sel;                    /*!< (@ 0x00000124) GPIO debounce9 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce9                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb9_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb10_sel;                   /*!< (@ 0x00000128) GPIO debounce10 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce10                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb10_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb11_sel;                   /*!< (@ 0x0000012C) GPIO debounce11 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce11                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb11_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb12_sel;                   /*!< (@ 0x00000130) GPIO debounce12 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce12                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb12_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb13_sel;                   /*!< (@ 0x00000134) GPIO debounce13 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce13                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb13_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb14_sel;                   /*!< (@ 0x00000138) GPIO debounce14 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce14                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb14_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb15_sel;                   /*!< (@ 0x0000013C) GPIO debounce15 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce15                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb15_sel_b;
  } ;
  __IM  uint32_t  RESERVED3[48];
  
  union {
    __IM  uint32_t port_a_dmd_sts;              /*!< (@ 0x00000200) GPIO port A data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_a_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_idm_en;               /*!< (@ 0x00000204) GPIO port A input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as zero.                                    */
    } port_a_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odm_en;               /*!< (@ 0x00000208) GPIO port A output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as one                                      */
    } port_a_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_od_sts;               /*!< (@ 0x0000020C) GPIO port A output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_a_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odl_en;               /*!< (@ 0x00000210) GPIO port A output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is zero.                               */
    } port_a_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odh_en;               /*!< (@ 0x00000214) GPIO port A output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is one.                                */
    } port_a_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odt_en;               /*!< (@ 0x00000218) GPIO port A output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_A_OD_STS
                                                     also will be toggled.                                                     */
    } port_a_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_dp_sts;               /*!< (@ 0x0000021C) GPIO port A data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port A.                                      */
    } port_a_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED4[8];
  
  union {
    __IM  uint32_t port_b_dmd_sts;              /*!< (@ 0x00000240) GPIO port B data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_b_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_idm_en;               /*!< (@ 0x00000244) GPIO port B input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as zero.                                    */
    } port_b_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odm_en;               /*!< (@ 0x00000248) GPIO port B output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as one                                      */
    } port_b_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_od_sts;               /*!< (@ 0x0000024C) GPIO port B output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_b_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odl_en;               /*!< (@ 0x00000250) GPIO port B output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is zero.                               */
    } port_b_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odh_en;               /*!< (@ 0x00000254) GPIO port B output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is one.                                */
    } port_b_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odt_en;               /*!< (@ 0x00000258) GPIO port B output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_B_OD_STS
                                                     also will be toggled.                                                     */
    } port_b_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_dp_sts;               /*!< (@ 0x0000025C) GPIO port B data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port B.                                      */
    } port_b_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED5[8];
  
  union {
    __IM  uint32_t port_c_dmd_sts;              /*!< (@ 0x00000280) GPIO port C data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_c_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_idm_en;               /*!< (@ 0x00000284) GPIO port C input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as zero.                                    */
    } port_c_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odm_en;               /*!< (@ 0x00000288) GPIO port C output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as one                                      */
    } port_c_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_od_sts;               /*!< (@ 0x0000028C) GPIO port C output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_c_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odl_en;               /*!< (@ 0x00000290) GPIO port C output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is zero.                               */
    } port_c_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odh_en;               /*!< (@ 0x00000294) GPIO port C output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is one.                                */
    } port_c_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odt_en;               /*!< (@ 0x00000298) GPIO port C output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_C_OD_STS
                                                     also will be toggled.                                                     */
    } port_c_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_dp_sts;               /*!< (@ 0x0000029C) GPIO port C data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port C.                                      */
    } port_c_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED6[8];
  
  union {
    __IM  uint32_t port_d_dmd_sts;              /*!< (@ 0x000002C0) GPIO port D data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_d_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_idm_en;               /*!< (@ 0x000002C4) GPIO port D input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as zero.                                    */
    } port_d_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odm_en;               /*!< (@ 0x000002C8) GPIO port D output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as one                                      */
    } port_d_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_od_sts;               /*!< (@ 0x000002CC) GPIO port D output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_d_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odl_en;               /*!< (@ 0x000002D0) GPIO port D output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is zero.                               */
    } port_d_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odh_en;               /*!< (@ 0x000002D4) GPIO port D output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is one.                                */
    } port_d_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odt_en;               /*!< (@ 0x000002D8) GPIO port D output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_D_OD_STS
                                                     also will be toggled.                                                     */
    } port_d_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_dp_sts;               /*!< (@ 0x000002DC) GPIO port D data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port D.                                      */
    } port_d_dp_sts_b;
  } ;
} GPIO_Type;                                    /*!< Size = 736 (0x2e0)                                                        */



/* =========================================================================================================================== */
/* ================                                            TG0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer Group 0 Control (TG0)
  */

typedef struct {                                /*!< (@ 0x40002000) TG0 Structure                                              */
  
  union {
    __IM  uint32_t ists;                        /*!< (@ 0x00000000) Timer Group interrupt status register                      */
    
    struct {
      __IM  uint32_t ists       : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt                             */
    } ists_b;
  } ;
  
  union {
    __IM  uint32_t raw_ists;                    /*!< (@ 0x00000004) Timer Group raw interrupt status register                  */
    
    struct {
      __IM  uint32_t rists      : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt (pre-masing)                */
    } raw_ists_b;
  } ;
  
  union {
    __IOM uint32_t tsel;                        /*!< (@ 0x00000008) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t tsel       : 3;            /*!< [2..0] The timer index in a timer group, to select the timer
                                                     for indirect read.                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Sync mode between Timer clock and APB clock 0: Freq.
                                                     of APB clock >> Freq. of Timer clock (about 10 times) 1:
                                                     others                                                                    */
      __IM  uint32_t            : 2;
      __IOM uint32_t poll       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by tsel. This bit is cleared by HW while
                                                     finishing read and indicate REG_TIMER_TC is ready                         */
    } tsel_b;
  } ;
  
  union {
    __IM  uint32_t tc;                          /*!< (@ 0x0000000C) Timer Group indirect read timer counter register           */
    
    struct {
      __IM  uint32_t timer_tc   : 32;           /*!< [31..0] Current counter value of the specifiied timer by register
                                                     tg_tsel.                                                                  */
    } tc_b;
  } ;
} TG0_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            TM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer0 (TM0)
  */

typedef struct {                                /*!< (@ 0x40002040) TM0 Structure                                              */
  
  union {
    __IOM uint32_t lc;                          /*!< (@ 0x00000000) Timer load count register                                  */
    
    struct {
      __IOM uint32_t lc         : 32;           /*!< [31..0] The counter value to be loaded into the timer counter
                                                     when timer is enabled or reset. Min = 0, when prescaler
                                                     register > 0; otherwise Min = 1.                                          */
    } lc_b;
  } ;
  
  union {
    __IOM uint32_t tc;                          /*!< (@ 0x00000004) Timer current counter register                             */
    
    struct {
      __IOM uint32_t tc         : 32;           /*!< [31..0] Current counter value.                                            */
    } tc_b;
  } ;
  
  union {
    __IOM uint32_t pc;                          /*!< (@ 0x00000008) Timer prescaler counter register                           */
    
    struct {
      __IOM uint32_t pc         : 10;           /*!< [9..0] Pre-scaler counter will be increased every clock after
                                                     timer is enabled. When the prescaler counter is equal to
                                                     PR, the next clock increments (decrements) the TC and clears
                                                     the PC.                                                                   */
    } pc_b;
  } ;
  
  union {
    __IOM uint32_t pr;                          /*!< (@ 0x0000000C) Timer prescaler register                                   */
    
    struct {
      __IOM uint32_t pr         : 10;           /*!< [9..0] When the PC is equal to this value, the next clock increments
                                                     (decrements) the TC and clears the PC.                                    */
    } pr_b;
  } ;
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000010) Timer control register                                     */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Timer enable control: 0: Disable 1: Enable                         */
      __IOM uint32_t mod        : 1;            /*!< [1..1] Timer operation mode: 0: timer mode (periodical mode);
                                                     it reloads LC to TC and repeat the process according to
                                                     the setting when the timeout event occurred. 1: counter
                                                     mode (one-shot mode); only one time process.                              */
      __IOM uint32_t imr        : 1;            /*!< [2..2] Timer Interrupt mask: 0: disable interrupt 1: enable
                                                     interrupt                                                                 */
      __IOM uint32_t cnt_mod    : 1;            /*!< [3..3] Timer counting mode: 0: Up-counter 1: Down-counter                 */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x00000014) Timer0 interrupt status register                           */
    
    struct {
      __IOM uint32_t timeout    : 1;            /*!< [0..0] Timeout interrupt                                                  */
      __IOM uint32_t match_ev0  : 1;            /*!< [1..1] Counter value match event0 interrupt.                              */
      __IOM uint32_t match_ev1  : 1;            /*!< [2..2] Counter value match event1 interrupt.                              */
      __IOM uint32_t match_ev2  : 1;            /*!< [3..3] Counter value match event2 interrupt.                              */
      __IOM uint32_t match_ev3  : 1;            /*!< [4..4] Counter value match event3 interrupt.                              */
    } isr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t mectrl;                      /*!< (@ 0x0000001C) Timer match event control register                         */
    
    struct {
      __IOM uint32_t me0_en     : 1;            /*!< [0..0] Counter value match event0 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me1_en     : 1;            /*!< [1..1] Counter value match event1 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me2_en     : 1;            /*!< [2..2] Counter value match event2 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me3_en     : 1;            /*!< [3..3] Counter value match event3 enable control: 0: Disable
                                                     1: Enable                                                                 */
    } mectrl_b;
  } ;
  
  union {
    __IOM uint32_t me0;                         /*!< (@ 0x00000020) Timer match event0 counter register                        */
    
    struct {
      __IOM uint32_t me0        : 32;           /*!< [31..0] Timer counter value for metch event0.                             */
    } me0_b;
  } ;
  
  union {
    __IOM uint32_t me1;                         /*!< (@ 0x00000024) Timer match event1 counter register                        */
    
    struct {
      __IOM uint32_t me1        : 32;           /*!< [31..0] Timer counter value for metch event1.                             */
    } me1_b;
  } ;
  
  union {
    __IOM uint32_t me2;                         /*!< (@ 0x00000028) Timer match event2 counter register                        */
    
    struct {
      __IOM uint32_t me2        : 32;           /*!< [31..0] Timer counter value for metch event2.                             */
    } me2_b;
  } ;
  
  union {
    __IOM uint32_t me3;                         /*!< (@ 0x0000002C) Timer match event3 counter register                        */
    
    struct {
      __IOM uint32_t me3        : 32;           /*!< [31..0] Timer counter value for metch event3.                             */
    } me3_b;
  } ;
} TM0_Type;                                     /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                         PWM_COMM                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PWM Group Control (PWM_COMM)
  */

typedef struct {                                /*!< (@ 0x40003000) PWM_COMM Structure                                         */
  
  union {
    __IM  uint32_t enable_status;               /*!< (@ 0x00000000) PWM enable status Register                                 */
    
    struct {
      __IM  uint32_t pwm_en_sts : 8;            /*!< [7..0] Each bit indicates the enabling status of corresponding
                                                     PWM: 0: the specific PWM is Disabled 1: the specific PWM
                                                     is Enabled                                                                */
    } enable_status_b;
  } ;
  
  union {
    __IOM uint32_t enable_ctrl;                 /*!< (@ 0x00000004) PWM enable Register                                        */
    
    struct {
      __IOM uint32_t pwm_en     : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the specific PWM is enabled
                                                     and the specific bit of REG_PWM_EN_STS is ONE.                            */
    } enable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t disable_ctrl;                /*!< (@ 0x00000008) PWM disable Register                                       */
    
    struct {
      __IOM uint32_t pwm_dis    : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the conrtolled PWM is disabled
                                                     and the specific bit of REG_PWM_EN_STS is ZERO.                           */
    } disable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t int_status;                  /*!< (@ 0x0000000C) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 8;       /*!< [7..0] To indicate the interrupt pending status for PWM 0 ~
                                                     7 duty auto-adjustment reaches the down-limit. Write 1
                                                     clear. Bit 0 for PWM0, bit 1 for PWM1, ...bit7 for PWM7.                  */
      __IM  uint32_t            : 8;
      __IOM uint32_t duty_adj_up_lim : 8;       /*!< [23..16] To indicate the interrupt pending status for PWM 0
                                                     ~ 7 duty auto-adjustment reaches the up-limit. Write 1
                                                     clear. Bit 16 for PWM0, bit 17 for PWM1, ...bit23 for PWM7.               */
      __IOM uint32_t period_end : 8;            /*!< [31..24] To indicate the interrupt pending status for PWM 0
                                                     ~7 period end. Write 1 clear. Bit 24 for PWM0, bit 25 for
                                                     PWM1, ...bit31 for PWM7.                                                  */
    } int_status_b;
  } ;
  
  union {
    __IOM uint32_t indread_idx;                 /*!< (@ 0x00000010) PWM Index of Indirect Read Register                        */
    
    struct {
      __IOM uint32_t pwm_sel    : 3;            /*!< [2..0] This field is used to assign the PWM index (0 ~ 7) for
                                                     the auto adjusted duty size indirect reading.                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Register sync mode selection for PWM clock and APB clock
                                                     0: Freq. of APB clock >> Freq. of PWM clock (about 10 times)
                                                     1: Freq. of PWM clock >= Freq. of APB clock                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t pool       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by BIT_PWM_INDREAD_IDX. This bit is cleared
                                                     by HW when reading is finished and indicates REG_PERI_PWM_INDREAD_DUTY
                                                     is ready.                                                                 */
    } indread_idx_b;
  } ;
  
  union {
    __IOM uint32_t indread_duty;                /*!< (@ 0x00000014) PWM Auto Adjusted Duty Indirect Read Register              */
    
    struct {
      __IOM uint32_t pwm_duty   : 12;           /*!< [11..0] This field is used to read the auto adjusted duty size
                                                     of the PWM which is assigned by the pwm_sel. The SW should
                                                     assign the PWM to read by write the pwm_sel and then read
                                                     this field to get the current duty size of the specified
                                                     PWM.                                                                      */
    } indread_duty_b;
  } ;
} PWM_COMM_Type;                                /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Width Modulation 0 (PWM0)
  */

typedef struct {                                /*!< (@ 0x40003020) PWM0 Structure                                             */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) PWM Control Register                                       */
    
    struct {
      __IOM uint32_t duty       : 12;           /*!< [11..0] The on-duty duration of PWM pulse. The time unit is
                                                     configured by the GTIMER which is specified by clk_sel
                                                     field. It can be written at any time, but HW will apply
                                                     the changing at PWM enable time or at the end of PWM period.              */
      __IOM uint32_t clk_sel    : 4;            /*!< [15..12] The tick source selection, G-timer 0 ~ 7 or SClk: 0:
                                                     GTIMER 0 1: GTIMER 1 ... 7: GTIMER 7 8: sclk                              */
      __IM  uint32_t cur_duty   : 12;           /*!< [27..16] The current duty size which is adjusted by the duty
                                                     auto-adjustment HW. The SW can read this field to know
                                                     the current duty size. However, the latest duty size may
                                                     not be sync to this field on time or the value may transition
                                                     while the SW is reading this field. So use in-direct read
                                                     method to read the duty size is more save and is suggested.               */
      __IOM uint32_t period_ie  : 1;            /*!< [28..28] This bit control the PWM period end interrupt enable
                                                     (1) or disable (0). When the PWM period end interrupt is
                                                     enabled, the PWM HW will assert the interrupt on every
                                                     PWM period end time. This interrupt status can be read
                                                     from pwm_int_status.                                                      */
      __IM  uint32_t run_sts    : 1;            /*!< [29..29] The PWM output running status: 0: PWM output is paused
                                                     1: the PWM output is running.                                             */
      __IOM uint32_t pause      : 1;            /*!< [30..30] The paus control: 0: Normal running 1: To pause the
                                                     PWM out at current PWM period end. Since the PWM output
                                                     is not stopped immediately, the software can poll the BIT_PERI_PWMx_RUNST
                                                     to know the PWM out is still running or is paused.                        */
      __IOM uint32_t ctrl_set   : 1;            /*!< [31..31] SW can change setting only at ctrl_set = 0, and set
                                                     ctrl_set = 1 after changing PWM Ctrl. HW will clear ctrl_set
                                                     bit after changing PWM Ctrl. PS. If this PWM is disabled
                                                     (PWMx_EN=0), the HW will not clear this bit. PS. if this
                                                     bit is asserted and the duty auto adjustment is enabled,
                                                     when the PWM is enabled the HW will updates its duty at
                                                     the 1st PWM period and then start the duty adjustment at
                                                     2nd PWM period.                                                           */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t timing_ctrl;                 /*!< (@ 0x00000004) PWM Timing Control Register                                */
    
    struct {
      __IOM uint32_t period     : 12;           /*!< [11..0] The period of PWM pulse. The time unit is configured
                                                     by the GTIMER which is specified by the clk_sel field.
                                                     It can be written at any time, but the HW will apply the
                                                     changing at PWM enable time or at the end of PWM period.                  */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_start : 12;           /*!< [27..16] The start of ON duration of PWM pulse in the period.
                                                     The time unit is the same as PWM period. It can be written
                                                     at any time, but HW change setting only at PWM enable and
                                                     the end of period.                                                        */
    } timing_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_ctrl;               /*!< (@ 0x00000008) PWM Duty Auto Adjustment Control Register                  */
    
    struct {
      __IOM uint32_t duty_dec_step : 10;        /*!< [9..0] The Duty Decreasing Step size of the Duty Auto Adjustment.         */
      __IM  uint32_t            : 2;
      __IOM uint32_t duty_inc_step : 10;        /*!< [21..12] The Duty Increasing Step size of the Duty Auto Adjustment        */
      __IM  uint32_t            : 5;
      __IOM uint32_t duty_dn_lim_ie : 1;        /*!< [27..27] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Down Limit.                                                           */
      __IOM uint32_t duty_up_lim_ie : 1;        /*!< [28..28] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Up Limit.                                                             */
      __IOM uint32_t adj_loop_en : 1;           /*!< [29..29] This bit is used to enable the Duty Auto Adjustment
                                                     Loop mode. 0: Disable 1: Enable If the Loop Mode is enabled,
                                                     reverse the Duty Auto Adjustment direction when the adjusted
                                                     Duty reach the Up Limit or the Down Limit.                                */
      __IOM uint32_t adj_dir    : 1;            /*!< [30..30] This bit is used to set the Duty Ato Adjustment direction.
                                                     0: Decrease Duty 1: Increase Duty                                         */
      __IOM uint32_t adj_en     : 1;            /*!< [31..31] This bit is used to enable the Duty Ato Adjustment.
                                                     0: Disable 1: Enable PS. If this bit is 1, the duty of
                                                     the auto adjustment will override the duty setting in the
                                                     pwm_ctrl register.                                                        */
    } auto_adj_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_limit;              /*!< (@ 0x0000000C) PWM Duty Auto Adjustment Limit Register                    */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 12;      /*!< [11..0] The down limit (in ticks) of the duty period for the
                                                     duty ratio auto adjustment                                                */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_adj_up_lim : 12;      /*!< [27..16] The up limit of the duty period for the duty ratio
                                                     auto adjustment                                                           */
    } auto_adj_limit_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_cycle;              /*!< (@ 0x00000010) PWM Duty Auto Adjustment Cycle Count Register              */
    
    struct {
      __IOM uint32_t adj_cycles : 12;           /*!< [11..0] The Cycle Count of the Duty Auto Adjustment. The Duty
                                                     size will be increased/decreased with a step size every
                                                     Cycle Count of PWM period                                                 */
    } auto_adj_cycle_b;
  } ;
} PWM0_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Controller to control 4IO & 8IO DTR Flash (SPIC)
  */

typedef struct {                                /*!< (@ 0x40006000) SPIC Structure                                             */
  
  union {
    __IOM uint32_t ctrlr0;                      /*!< (@ 0x00000000) SPIC Control Register 0                                    */
    
    struct {
      __IM  uint32_t            : 6;
      __IOM uint32_t scph       : 1;            /*!< [6..6] Serial Clock Phase.                                                */
      __IOM uint32_t scpol      : 1;            /*!< [7..7] Serial Clock Polarity.                                             */
      __IOM uint32_t tmod       : 2;            /*!< [9..8] Transfer mode.                                                     */
      __IM  uint32_t            : 6;
      __IOM uint32_t addr_ch    : 2;            /*!< [17..16] Indicate channel number of address phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t data_ch    : 2;            /*!< [19..18] Indicate channel number of data phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t cmd_ch     : 2;            /*!< [21..20] Indicate channel number of command phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t fast_rd    : 1;            /*!< [22..22] Indicate to use fast read command in user mode. If
                                                     setting to 1, SPIC would use FBAUDR to derive spi_sclk.                   */
      __IOM uint32_t ck_mtimes  : 5;            /*!< [27..23] Indicate the check time.                                         */
      __IOM uint32_t addr_ddr_en : 1;           /*!< [28..28] Enable address phase ddr mode.                                   */
      __IOM uint32_t data_ddr_en : 1;           /*!< [29..29] Enable data phase ddr mode.                                      */
      __IOM uint32_t cmd_ddr_en : 1;            /*!< [30..30] Enable command phase ddr mode. Always 2-byte command
                                                     type.                                                                     */
    } ctrlr0_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr1;                      /*!< (@ 0x00000004) SPIC Control Register 1                                    */
    
    struct {
      __IOM uint32_t ndf        : 12;           /*!< [11..0] ndf                                                               */
    } ctrlr1_b;
  } ;
  
  union {
    __IOM uint32_t ssienr;                      /*!< (@ 0x00000008) SPIC Enable Register                                       */
    
    struct {
      __IOM uint32_t spic_en    : 1;            /*!< [0..0] Enable or disable SPIC.                                            */
      __OM  uint32_t atck_cmd   : 1;            /*!< [1..1] Set to enable ATCK_CMD implementation. After this bit
                                                     is set, SPIC would not accept any command until checking
                                                     flash is not busy or timeout.                                             */
    } ssienr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ser;                         /*!< (@ 0x00000010) Slave Enable Register                                      */
    
    struct {
      __IOM uint32_t ser        : 1;            /*!< [0..0] SPIC only has one slave select line. This bit should
                                                     be always set.                                                            */
    } ser_b;
  } ;
  
  union {
    __IOM uint32_t baudr;                       /*!< (@ 0x00000014) Baud Rate Select Register                                  */
    
    struct {
      __IOM uint32_t sckdv      : 12;           /*!< [11..0] This register controls the frequency of spi_sclk. spi_sclk
                                                     = frequency of bus_clk / (2*sckdv)                                        */
    } baudr_b;
  } ;
  
  union {
    __IOM uint32_t txftlr;                      /*!< (@ 0x00000018) Transmit FIFO Threshold Level                              */
    
    struct {
      __IOM uint32_t tft        : 8;            /*!< [7..0] Transmit FIFO Threshold. Controls the level of entries
                                                     (or below) at which the transmit FIFO controller triggers
                                                     an interrupt.                                                             */
    } txftlr_b;
  } ;
  
  union {
    __IOM uint32_t rxftlr;                      /*!< (@ 0x0000001C) Receive FIFO Threshold Level                               */
    
    struct {
      __IOM uint32_t rft        : 8;            /*!< [7..0] Receive FIFO Threshold. Controls the level of entries
                                                     (or above) at which the receive FIFO controller triggers
                                                     an interrupt.                                                             */
    } rxftlr_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
    
    struct {
      __IM  uint32_t txtfl      : 8;            /*!< [7..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000024) Receive FIFO Level Register                                */
    
    struct {
      __IM  uint32_t rxtfl      : 8;            /*!< [7..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IM  uint32_t sr;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] SPIC Busy Flag. When set, indicates that a serial transfer
                                                     is in progress; when cleared indicates that the SPIC is
                                                     idle or disabled.                                                         */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. 0 : Transmit FIFO is full 1 : Transmit FIFO is
                                                     not full                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When the transmit FIFO contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. 0 : Transmit FIFO
                                                     is not empty 1 : Transmit FIFO is empty                                   */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. Set when the receive FIFO contains
                                                     one or more entries and is cleared when the receive FIFO
                                                     is empty. This bit can be polled by software to completely
                                                     empty the receive FIFO. 0 : Receive FIFO is empty 1 : Receive
                                                     FIFO is not empty                                                         */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. 0 : Receive
                                                     FIFO is not full 1 : Receive FIFO is full                                 */
      __IM  uint32_t txe        : 1;            /*!< [5..5] Transmission Error. Set if the transmit FIFO is empty
                                                     when a transfer is started. This bit can be set only when
                                                     the DW_apb_ssi is configured as a slave device. Data from
                                                     the previous transmission is resent on the txd line. This
                                                     bit is cleared when read. 0 : No error 1 : Transmission
                                                     error                                                                     */
      __IM  uint32_t dcol       : 1;            /*!< [6..6] Transmitting Status. This bit is set when SPIC is transmitting
                                                     command, address or data to the data register. By observing
                                                     this bit, users can avoid reading wrong data at the wrong
                                                     time if data is not ready to be read.                                     */
    } sr_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t txeim      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : spi_txeir_r interrupt
                                                     is masked 1 : spi_txeir_r interrupt is not masked                         */
      __IOM uint32_t txoim      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : spi_txoir_r
                                                     interrupt is masked 1 : spi_txoir_r interrupt is not masked               */
      __IOM uint32_t rxuim      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : spi_rxuir_r
                                                     interrupt is masked 1 : spi_rxuir_r interrupt is not masked               */
      __IOM uint32_t rxoim      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : spi_rxoir_r
                                                     interrupt is masked 1 : spi_rxoir_r interrupt is not masked               */
      __IOM uint32_t rxfim      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : spi_rxfir_r interrupt
                                                     is masked 1 : spi_rxfir_r interrupt is not masked                         */
      __IOM uint32_t fseim      : 1;            /*!< [5..5] FIFO Size Error Interrupt Mask. 0 : spi_fseir_r interrupt
                                                     is masked 1 : spi_fseir_r interrupt is not masked                         */
      __IOM uint32_t wbeim      : 1;            /*!< [6..6] Write Burst Error Interrupt Mask. 0 : spi_wbier_r interrupt
                                                     is masked 1 : spi_wbier_r interrupt is not masked                         */
      __IOM uint32_t byeim      : 1;            /*!< [7..7] Byte Enable Error Interrupt Mask 0 : spi_byeir_r interrupt
                                                     is masked 1 : spi_byeir_r interrupt is not masked                         */
      __IOM uint32_t aceim      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Mask. 0 : spi_aceir_r
                                                     interrupt is masked 1 : spi_aceir_r interrupt is not masked               */
      __IOM uint32_t txsim      : 1;            /*!< [9..9] Transmit Split Interrupt Mask. 0 : spi_tx_sir_r interrupt
                                                     is masked 1 : spi_tx_sir_r interrupt is not masked                        */
    } imr_b;
  } ;
  
  union {
    __IM  uint32_t isr;                         /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t txeis      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status after Masking 0
                                                     : spi_txeir_r interrupt is not active after masking 1 :
                                                     spi_txeir_r interrupt is active after masking                             */
      __IM  uint32_t txois      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_txoir_r interrupt is not active after masking 1
                                                     : spi_txoir_r interrupt is active after masking                           */
      __IM  uint32_t rxuis      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status after Masking
                                                     0 : spi_rxuir_r interrupt is not active after masking 1
                                                     : spi_rxuir_r interrupt is active after masking                           */
      __IM  uint32_t rxois      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_rxoir_r interrupt is not active after masking 1
                                                     : spi_rxoir_r interrupt is active after masking                           */
      __IM  uint32_t rxfis      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status after Masking 0 :
                                                     spi_rxfir_r interrupt is not active after masking 1 : spi_rxfir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t fseis      : 1;            /*!< [5..5] FIFO Size Error Interrupt Status after Masking. 0 : spi_fseir_r
                                                     interrupt is not active after masking 1 : spi_fseir_r interrupt
                                                     is active after masking                                                   */
      __IM  uint32_t wbeis      : 1;            /*!< [6..6] Write Burst Error Interrupt Status after Masking. 0 :
                                                     spi_wbier_r interrupt is not active after masking 1 : spi_wbier_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t byeis      : 1;            /*!< [7..7] Byte Enable Error Interrupt Status after Masking 0 :
                                                     spi_byeir_r interrupt is not active after masking 1 : spi_byeir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t aceis      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Status after Masking.
                                                     0 : spi_aceir_r interrupt is not active after masking 1
                                                     : spi_aceir_r interrupt is active after masking                           */
      __IM  uint32_t txsis      : 1;            /*!< [9..9] Transmit Split Interrupt Status after Masking. 0 : spi_tx_sir_r
                                                     interrupt is not active after masking 1 : spi_tx_sir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxsis      : 1;            /*!< [10..10] Receive Split Interrupt Status after Masking. 0 : spi_rx_sir_r
                                                     interrupt is not active after masking 1 : spi_rx_sir_r
                                                     interrupt is active after masking                                         */
    } isr_b;
  } ;
  
  union {
    __IM  uint32_t risr;                        /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t txeir      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Raw Status before Masking
                                                     0 : spi_txeir_r interrupt is not acitve before masking
                                                     1 : spi_txeir_r interrupt is acitve before masking                        */
      __IM  uint32_t txoir      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_txoir_r interrupt is not acitve before masking
                                                     1 : spi_txoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxuir      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Raw Status before Masking
                                                     0 : spi_rxuir_r interrupt is not acitve before masking
                                                     1 : spi_rxuir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxoir      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_rxoir_r interrupt is not acitve before masking
                                                     1 : spi_rxoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxfir      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Raw Status before Masking
                                                     0 : spi_rxfir_r interrupt is not acitve before masking
                                                     1 : spi_rxfir_r interrupt is acitve before masking                        */
      __IM  uint32_t fseir      : 1;            /*!< [5..5] FIFO Size Error Interrupt Raw Status before Masking.
                                                     0 : spi_fseir_r interrupt is not acitve before masking
                                                     1 : spi_fseir_r interrupt is acitve before masking                        */
      __IM  uint32_t wbeir      : 1;            /*!< [6..6] Write Burst Error Interrupt Raw Status before Masking.
                                                     0 : spi_wbier_r interrupt is not acitve before masking
                                                     1 : spi_wbier_r interrupt is acitve before masking                        */
      __IM  uint32_t byeir      : 1;            /*!< [7..7] Byte Enable Error Interrupt Raw Status before Masking
                                                     0 : spi_byeir_r interrupt is not acitve before masking
                                                     1 : spi_byeir_r interrupt is acitve before masking                        */
      __IM  uint32_t aceir      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Raw Status before
                                                     Masking. 0 : spi_aceir_r interrupt is not acitve before
                                                     masking 1 : spi_aceir_r interrupt is acitve before masking                */
    } risr_b;
  } ;
  
  union {
    __IM  uint32_t txoicr;                      /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t txoicr     : 1;            /*!< [0..0] Clear Transmit FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txo_intr interrupt; writing has
                                                     no effect.                                                                */
    } txoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxoicr;                      /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
    
    struct {
      __IM  uint32_t rxoicr     : 1;            /*!< [0..0] Clear Receive FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxo_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxuicr;                      /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t rxuicr     : 1;            /*!< [0..0] Clear Receive FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxu_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxuicr_b;
  } ;
  
  union {
    __IM  uint32_t faeicr;                      /*!< (@ 0x00000044) Frame Alignment Interrupt Clear Register                   */
    
    struct {
      __IM  uint32_t faeicr     : 1;            /*!< [0..0] Clear Frame Alignment Interrupt. This register reflects
                                                     the status of the interrupt. A read from this register
                                                     clears the ssi_fae_intr interrupt; writing has no effect.                 */
    } faeicr_b;
  } ;
  
  union {
    __IM  uint32_t icr;                         /*!< (@ 0x00000048) Interrupt Clear Register                                   */
    
    struct {
      __IM  uint32_t icr        : 1;            /*!< [0..0] Clear Interrupts. This register is set if any of the
                                                     interrupts below are active. A read clears the ssi_txu_intr,
                                                     ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_fae_intr
                                                     interrupts. Writing to this register has no effect.                       */
    } icr_b;
  } ;
  
  union {
    __IOM uint32_t dmacr;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t rx_dmac_en : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel 0 : Receive DMA disabled 1 : Receive DMA
                                                     enabled                                                                   */
      __IOM uint32_t tx_dmac_en : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. 0 : Transmit DMA disabled 1 : Transmit
                                                     DMA enabled                                                               */
    } dmacr_b;
  } ;
  
  union {
    __IOM uint32_t dmatdlr;                     /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t dmatdl     : 8;            /*!< [7..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tx_dmac_en = 1.                                                       */
    } dmatdlr_b;
  } ;
  
  union {
    __IOM uint32_t dmardlr;                     /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
    
    struct {
      __IOM uint32_t dmardl     : 8;            /*!< [7..0] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or above this field value + 1, and rx_dmac_en
                                                     = 1.                                                                      */
    } dmardlr_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    union {
      __IOM uint32_t dr_word;                   /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint32_t word     : 32;           /*!< [31..0] Access FIFO as if its width is 4 byte per data item               */
      } dr_word_b;
    } ;
    
    union {
      __IOM uint16_t dr_half_word;              /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint16_t half_word : 16;          /*!< [15..0] Access FIFO as if its width is 2 byte per data item               */
      } dr_half_word_b;
    } ;
    
    union {
      __IOM uint8_t dr_byte;                    /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint8_t byte      : 8;            /*!< [7..0] Access FIFO as if its width is 1 byte per data item                */
      } dr_byte_b;
    } ;
  };
  __IM  uint32_t  RESERVED2[31];
  
  union {
    union {
      __IOM uint32_t read_fast_single;          /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_cmd  : 8;            /*!< [7..0] Fast read command.                                                 */
      } read_fast_single_b;
    } ;
    
    union {
      __IOM uint32_t rd_octal_io;               /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_octal_cmd : 16;      /*!< [15..0] Fast read command for Octal IO mode.                              */
      } rd_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t read_dual_data;              /*!< (@ 0x000000E4) Dual Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_dual_o_cmd : 8;         /*!< [7..0] Dual data read command, 1-1-2 mode.                                */
    } read_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t read_dual_addr_data;         /*!< (@ 0x000000E8) Dual IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual address and data read command, 1-2-2 mode.                    */
    } read_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_data;              /*!< (@ 0x000000EC) Quad Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_quad_o_cmd : 8;         /*!< [7..0] Quad data read command, 1-1-4 mode.                                */
    } read_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_addr_data;         /*!< (@ 0x000000F0) Quad IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_quad_io_cmd : 8;        /*!< [7..0] Quad address and data read command, 1-4-4 mode.                    */
      __IM  uint32_t            : 8;
      __IOM uint32_t prm_value  : 8;            /*!< [23..16] High Performance Read Mode Control Value.                        */
    } read_quad_addr_data_b;
  } ;
  
  union {
    union {
      __IOM uint32_t write_single;              /*!< (@ 0x000000F4) Single IO Page Program Command Register                    */
      
      struct {
        __IOM uint32_t wr_cmd   : 8;            /*!< [7..0] One bit mode page program command.                                 */
      } write_single_b;
    } ;
    
    union {
      __IOM uint32_t write_octal_io;            /*!< (@ 0x000000F4) Octal IO Page Program Command Register                     */
      
      struct {
        __IOM uint32_t wr_octal_cmd : 16;       /*!< [15..0] Octal IO page program command.                                    */
      } write_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t write_dual_data;             /*!< (@ 0x000000F8) Dual Page Program Command Register                         */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual page program command, 1-1-2 mode.                             */
    } write_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t write_dual_addr_data;        /*!< (@ 0x000000FC) Dual IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_dual_ii_cmd : 8;        /*!< [7..0] Dual IO page program command, 1-2-2 mode.                          */
    } write_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_data;             /*!< (@ 0x00000100) Quad Page Program Command Register                         */
    
    struct {
      __IOM uint32_t wr_quad_i_cmd : 8;         /*!< [7..0] Quad page program command, 1-1-4 mode.                             */
    } write_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_addr_data;        /*!< (@ 0x00000104) Quad IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_quad_ii_cmd : 8;        /*!< [7..0] Quad IO page program command, 1-4-4 mode.                          */
    } write_quad_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_enable;                /*!< (@ 0x00000108) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t wr_en_cmd  : 16;           /*!< [15..0] Write Enable Command. The second command byte is for
                                                     DTR mode.                                                                 */
    } write_enable_b;
  } ;
  
  union {
    __IOM uint32_t read_status;                 /*!< (@ 0x0000010C) Read Status Command Register                               */
    
    struct {
      __IOM uint32_t rd_st_cmd  : 16;           /*!< [15..0] Read flash status register command.                               */
    } read_status_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr2;                      /*!< (@ 0x00000110) SPIC Control Register 2                                    */
    
    struct {
      __IOM uint32_t so_dnum    : 1;            /*!< [0..0] Indicate SO input pin of SPI Flash is connected to spi_sout[0]
                                                     or spi_sout[1]. Set 1 to support multi-channels connection
                                                     in default.                                                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t seq_en     : 1;            /*!< [3..3] Set to enable data-split program / read.                           */
      __IOM uint32_t tx_fifo_entry : 4;         /*!< [7..4] Indicate the valid entry of transmit FIFO.                         */
      __IOM uint32_t rx_fifo_entry : 4;         /*!< [11..8] Indicate the valid entry of receive FIFO.                         */
      __IOM uint32_t cs_active_hold : 2;        /*!< [13..12] For flash chip select active hold time after SCLK resing
                                                     edge.                                                                     */
    } ctrlr2_b;
  } ;
  
  union {
    __IOM uint32_t fbaudr;                      /*!< (@ 0x00000114) Fast Read Baud Rate Select Register                        */
    
    struct {
      __IOM uint32_t fsckdv     : 12;           /*!< [11..0] This register controls the frequency of spi_sclk for
                                                     fast read command. spi_sclk = frequency of bus_clk / (2*fsckdv)           */
    } fbaudr_b;
  } ;
  
  union {
    __IOM uint32_t addr_length;                 /*!< (@ 0x00000118) Address Byte Length Register                               */
    
    struct {
      __IOM uint32_t addr_phase_length : 3;     /*!< [2..0] Indicate the number of bytes in address phase. addr_phase_length
                                                     [2] is an extended bit for 4-Byte Address with PRM mode.
                                                     Set to 5, SPIC can send 4 byte address and 1 byte PRM mode
                                                     value. 3-Byte Address with PRM mode need to set this bit
                                                     to 0, SPIC can send 3byte address and 1byte PRM mode value.
                                                     1 : One byte address, 2 : Two byte address, 3 : Three byte
                                                     address, 4: Four byte address with PRM value, 0 : Four
                                                     byte address / Three bytee addree with PRM value.                         */
    } addr_length_b;
  } ;
  
  union {
    union {
      __IOM uint32_t auto_length;               /*!< (@ 0x0000011C) Auto Mode Address Byte Length Register                     */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IM  uint32_t          : 4;
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t auto_dum_len : 8;        /*!< [25..18] Dummy cycle is used to check flash status in auto_write
                                                     operation if delay time of read data 1 cycle.                             */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_b;
    } ;
    
    union {
      __IOM uint32_t auto_length_seq;           /*!< (@ 0x0000011C) Sequential Auto Mode Address Byte Length Register          */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IOM uint32_t in_physical_cyc : 4;     /*!< [15..12] Indicate how many SPIC clk cycles from pad to internal
                                                     SPIC.                                                                     */
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t spic_cyc_per_byte : 8;   /*!< [25..18] Indicate how many SPIC clk cycles for one byte. Formula
                                                     = BAUD*2*Byte / CH, the maximum value is 256                              */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_seq_b;
    } ;
  };
  
  union {
    __IOM uint32_t valid_cmd;                   /*!< (@ 0x00000120) Valid Command Register                                     */
    
    struct {
      __IOM uint32_t frd_single : 1;            /*!< [0..0] Execute fast read for auto read mode.                              */
      __IOM uint32_t rd_dual_i  : 1;            /*!< [1..1] Execute dual data write for auto read mode. (1-1-2)                */
      __IOM uint32_t rd_dual_io : 1;            /*!< [2..2] Execute dual address data read for auto read mode. (1-2-2)         */
      __IOM uint32_t rd_quad_o  : 1;            /*!< [3..3] Execute quad data write for auto read mode. (1-1-4)                */
      __IOM uint32_t rd_quad_io : 1;            /*!< [4..4] Execute quad address data read for auto read mode. (1-4-4)         */
      __IOM uint32_t wr_dual_i  : 1;            /*!< [5..5] Execute dual data write for auto write mode. (1-1-2)               */
      __IOM uint32_t wr_dual_ii : 1;            /*!< [6..6] Execute dual address data write for auto write mode.
                                                     (1-2-2)                                                                   */
      __IOM uint32_t wr_quad_i  : 1;            /*!< [7..7] Execute quad data write for auto write mode. (1-1-4)               */
      __IOM uint32_t wr_quad_ii : 1;            /*!< [8..8] Execute quad address data write for auto write mode.
                                                     (1-4-4)                                                                   */
      __IOM uint32_t wr_blocking : 1;           /*!< [9..9] Accept next operation after the write data push to FIFO
                                                     and FIFO is pop data to empty by SPIC. Should always be
                                                     1.                                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t prm_en     : 1;            /*!< [11..11] Enable SPIC performance read mode in auto mode.                  */
      __IOM uint32_t ctrlr0_ch  : 1;            /*!< [12..12] Set this bit, then SPIC refers cmd_ch / data_ch / addr_en
                                                     / cmd_ddr_en / data_ddr_en / addr_ddr_en bit fields in
                                                     Control Register 0 in auto mode.                                          */
      __IM  uint32_t            : 1;
      __IOM uint32_t seq_trans_en : 1;          /*!< [14..14] Set 1 to enable read sequential transaction determination
                                                     function. If the auto read address is sequenctial, users
                                                     can save command phase and address phase under this mode.                 */
    } valid_cmd_b;
  } ;
  
  union {
    __IOM uint32_t flash_size;                  /*!< (@ 0x00000124) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t flash_size : 4;            /*!< [3..0] The size of flash size to select the target SPI flash
                                                     in auto mode.                                                             */
    } flash_size_b;
  } ;
  
  union {
    __IOM uint32_t flush_fifo;                  /*!< (@ 0x00000128) Read Status Command Register                               */
    
    struct {
      __OM  uint32_t flush_fifio : 1;           /*!< [0..0] Write to flush SPIC FIFO.                                          */
    } flush_fifo_b;
  } ;
} SPIC_Type;                                    /*!< Size = 300 (0x12c)                                                        */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief 8-channel ADC with 12-bit resolution and 250K SPS (ADC)
  */

typedef struct {                                /*!< (@ 0x40010000) ADC Structure                                              */
  
  union {
    __IOM uint32_t conf;                        /*!< (@ 0x00000000) ADC Configuration Register                                 */
    
    struct {
      __IOM uint32_t ref_in_sel : 1;            /*!< [0..0] ADC reference voltage input.                                       */
      __IOM uint32_t op_mod     : 3;            /*!< [3..1] ADC operation mode. This field is to control ADC operation
                                                     mode.                                                                     */
      __IOM uint32_t cvlist_len : 4;            /*!< [7..4] ADC conversion list length. This field defines the number
                                                     of items in ADC conversion channel list. 0 is for 1 item
                                                     in list. 1 is for 2 items in list.                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t en         : 1;            /*!< [9..9] ADC enable control. This bit is to control ADC is enable
                                                     or not.                                                                   */
    } conf_b;
  } ;
  
  union {
    __IOM uint32_t in_type;                     /*!< (@ 0x00000004) ADC Input Type Register                                    */
    
    struct {
      __IOM uint32_t ch0        : 1;            /*!< [0..0] ADC channel 0 input type.                                          */
      __IOM uint32_t ch1        : 1;            /*!< [1..1] ADC channel 1 input type.                                          */
      __IOM uint32_t ch2        : 1;            /*!< [2..2] ADC channel 2 input type.                                          */
      __IOM uint32_t ch3        : 1;            /*!< [3..3] ADC channel 3 input type.                                          */
      __IOM uint32_t ch4        : 1;            /*!< [4..4] ADC channel 4 input type.                                          */
      __IOM uint32_t ch5        : 1;            /*!< [5..5] ADC channel 5 input type.                                          */
      __IOM uint32_t ch6        : 1;            /*!< [6..6] ADC channel 6 input type.                                          */
      __IOM uint32_t ch7        : 1;            /*!< [7..7] ADC channel 7 input type.                                          */
    } in_type_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch0;                 /*!< (@ 0x00000008) ADC Channel 0 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 0 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 0 comparison high threshold.                         */
    } comp_th_ch0_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch1;                 /*!< (@ 0x0000000C) ADC Channel 1 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 1 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 1 comparison high threshold.                         */
    } comp_th_ch1_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch2;                 /*!< (@ 0x00000010) ADC Channel 2 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 2 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 2 comparison high threshold.                         */
    } comp_th_ch2_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch3;                 /*!< (@ 0x00000014) ADC Channel 3 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 3 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 3 comparison high threshold.                         */
    } comp_th_ch3_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch4;                 /*!< (@ 0x00000018) ADC Channel 4 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 4 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 4 comparison high threshold.                         */
    } comp_th_ch4_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch5;                 /*!< (@ 0x0000001C) ADC Channel 5 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 5 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 5 comparison high threshold.                         */
    } comp_th_ch5_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch6;                 /*!< (@ 0x00000020) ADC Channel 6 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 6 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 6 comparison high threshold.                         */
    } comp_th_ch6_b;
  } ;
  
  union {
    __IOM uint32_t comp_th_ch7;                 /*!< (@ 0x00000024) ADC Channel 7 Comparison Threshold Register                */
    
    struct {
      __IOM uint32_t th_l       : 16;           /*!< [15..0] ADC channel 7 comparison low threshold.                           */
      __IOM uint32_t th_h       : 16;           /*!< [31..16] ADC channel 7 comparison high threshold.                         */
    } comp_th_ch7_b;
  } ;
  
  union {
    __IOM uint32_t comp_ctrl;                   /*!< (@ 0x00000028) ADC Comparison Control Register                            */
    
    struct {
      __IOM uint32_t ch0        : 2;            /*!< [1..0] This field controls that ADC channel 0 comparison criterion.       */
      __IOM uint32_t ch1        : 2;            /*!< [3..2] This field controls that ADC channel 1 comparison criterion.       */
      __IOM uint32_t ch2        : 2;            /*!< [5..4] This field controls that ADC channel 2 comparison criterion.       */
      __IOM uint32_t ch3        : 2;            /*!< [7..6] This field controls that ADC channel 3 comparison criterion.       */
      __IOM uint32_t ch4        : 2;            /*!< [9..8] This field controls that ADC channel 4 comparison criterion.       */
      __IOM uint32_t ch5        : 2;            /*!< [11..10] This field controls that ADC channel 5 comparison criterion.     */
      __IOM uint32_t ch6        : 2;            /*!< [13..12] This field controls that ADC channel 6 comparison criterion.     */
      __IOM uint32_t ch7        : 2;            /*!< [15..14] This field controls that ADC channel 7 comparison criterion.     */
    } comp_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t comp_sts;                    /*!< (@ 0x0000002C) ADC Comparison Status Register                             */
    
    struct {
      __IM  uint32_t ch0        : 2;            /*!< [1..0] This field reflects comparison result of chnnel 0 immediately.     */
      __IM  uint32_t ch1        : 2;            /*!< [3..2] This field reflects comparison result of chnnel 1 immediately.     */
      __IM  uint32_t ch2        : 2;            /*!< [5..4] This field reflects comparison result of chnnel 2 immediately.     */
      __IM  uint32_t ch3        : 2;            /*!< [7..6] This field reflects comparison result of chnnel 3 immediately.     */
      __IM  uint32_t ch4        : 2;            /*!< [9..8] This field reflects comparison result of chnnel 4 immediately.     */
      __IM  uint32_t ch5        : 2;            /*!< [11..10] This field reflects comparison result of chnnel 5 immediately.   */
      __IM  uint32_t ch6        : 2;            /*!< [13..12] This field reflects comparison result of chnnel 6 immediately.   */
      __IM  uint32_t ch7        : 2;            /*!< [15..14] This field reflects comparison result of chnnel 7 immediately.   */
    } comp_sts_b;
  } ;
  
  union {
    __IOM uint32_t chsw_list_0;                 /*!< (@ 0x00000030) ADC Channel Swtich List 0 Register                         */
    
    struct {
      __IOM uint32_t chsw_0     : 4;            /*!< [3..0] This field defines 1st channel in channel switch list.             */
      __IOM uint32_t chsw_1     : 4;            /*!< [7..4] This field defines 2nd channel in channel switch list.             */
      __IOM uint32_t chsw_2     : 4;            /*!< [11..8] This field defines 3rd channel in channel switch list.            */
      __IOM uint32_t chsw_3     : 4;            /*!< [15..12] This field defines 4th channel in channel switch list.           */
      __IOM uint32_t chsw_4     : 4;            /*!< [19..16] This field defines 5th channel in channel switch list.           */
      __IOM uint32_t chsw_5     : 4;            /*!< [23..20] This field defines 6th channel in channel switch list.           */
      __IOM uint32_t chsw_6     : 4;            /*!< [27..24] This field defines 7th channel in channel switch list.           */
      __IOM uint32_t chsw_7     : 4;            /*!< [31..28] This field defines 8th channel in channel switch list.           */
    } chsw_list_0_b;
  } ;
  
  union {
    __IOM uint32_t chsw_list_1;                 /*!< (@ 0x00000034) ADC Channel Swtich List 1 Register                         */
    
    struct {
      __IOM uint32_t chsw_8     : 4;            /*!< [3..0] This field defines 9th channel in channel switch list.             */
      __IOM uint32_t chsw_9     : 4;            /*!< [7..4] This field defines 10th channel in channel switch list.            */
      __IOM uint32_t chsw_10    : 4;            /*!< [11..8] This field defines 11th channel in channel switch list.           */
      __IOM uint32_t chsw_11    : 4;            /*!< [15..12] This field defines 12th channel in channel switch list.          */
      __IOM uint32_t chsw_12    : 4;            /*!< [19..16] This field defines 13th channel in channel switch list.          */
      __IOM uint32_t chsw_13    : 4;            /*!< [23..20] This field defines 14th channel in channel switch list.          */
      __IOM uint32_t chsw_14    : 4;            /*!< [27..24] This field defines 15th channel in channel switch list.          */
      __IOM uint32_t chsw_15    : 4;            /*!< [31..28] This field defines 16th channel in channel switch list.          */
    } chsw_list_1_b;
  } ;
  
  union {
    __IOM uint32_t rst_list;                    /*!< (@ 0x00000038) ADC Reset List Register                                    */
    
    struct {
      __IOM uint32_t rst_list   : 1;            /*!< [0..0] This bit is to reset channel switch list or not.                   */
    } rst_list_b;
  } ;
  
  union {
    __IOM uint32_t auto_chsw_ctrl;              /*!< (@ 0x0000003C) ADC Auto Channel Switch Control Register                   */
    
    struct {
      __IOM uint32_t auto_chsw_en : 1;          /*!< [0..0] This bit controls the automatic channel switch enabled
                                                     or not.                                                                   */
    } auto_chsw_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t sw_trig;                     /*!< (@ 0x00000040) ADC Software Trigger Register                              */
    
    struct {
      __IOM uint32_t sw_trig    : 1;            /*!< [0..0] This bit controls the ADC module to do a conersion.                */
    } sw_trig_b;
  } ;
  
  union {
    __IM  uint32_t last_item;                   /*!< (@ 0x00000044) ADC Last Item Register                                     */
    
    struct {
      __IM  uint32_t last_item  : 4;            /*!< [3..0] This field records the last conversion list item that
                                                     a conversion is done for.                                                 */
    } last_item_b;
  } ;
  
  union {
    __IM  uint32_t sts;                         /*!< (@ 0x00000048) ADC Busy_Ready Status Register                             */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] This bit reflects the ADC is busy or not.                          */
      __IM  uint32_t full       : 1;            /*!< [1..1] This bit reflects the ADC FIFO is full or not.                     */
      __IM  uint32_t empty      : 1;            /*!< [2..2] This bit reflects the ADC FIFO is empty or not.                    */
    } sts_b;
  } ;
  
  union {
    __IOM uint32_t intr_ctrl;                   /*!< (@ 0x0000004C) ADC Interrupt Control Register                             */
    
    struct {
      __IOM uint32_t it_cvlist_end_en : 1;      /*!< [0..0] This bit controls the interrupt is enbled or not when
                                                     a conversion of the last channel in the list is done.                     */
      __IOM uint32_t it_cv_end_en : 1;          /*!< [1..1] This bit controls the interrupt is enbled or not every
                                                     time a conversion is done.                                                */
      __IOM uint32_t it_chcv_end_en : 1;        /*!< [2..2] This bit controls the interrupt is enbled or not when
                                                     a particular channel conversion is done.                                  */
      __IOM uint32_t it_fifo_full_en : 1;       /*!< [3..3] This bit controls the interrupt is enabled or not when
                                                     a FIFO full state takes place.                                            */
      __IOM uint32_t it_fifo_over_en : 1;       /*!< [4..4] This bit controls the interrupt is enabled or not when
                                                     a FIFO overflow state takes place.                                        */
      __IOM uint32_t it_fifo_empty_en : 1;      /*!< [5..5] This bit controls the interrupt is enabled or not when
                                                     a FIFO empty state takes place.                                           */
      __IOM uint32_t it_dat_ovw_en : 1;         /*!< [6..6] This bit controls the interrupt is enabled or not when
                                                     a data overwritten situation takes place.                                 */
      __IOM uint32_t it_err_en  : 1;            /*!< [7..7] This bit controls the interrupt is enabled or not when
                                                     an error state takes place.                                               */
      __IOM uint32_t it_comp_ch0_en : 1;        /*!< [8..8] This bit controls the interrupt is enabled or not when
                                                     channel 0 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch1_en : 1;        /*!< [9..9] This bit controls the interrupt is enabled or not when
                                                     channel 1 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch2_en : 1;        /*!< [10..10] This bit controls the interrupt is enabled or not when
                                                     channel 2 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch3_en : 1;        /*!< [11..11] This bit controls the interrupt is enabled or not when
                                                     channel 3 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch4_en : 1;        /*!< [12..12] This bit controls the interrupt is enabled or not when
                                                     channel 4 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch5_en : 1;        /*!< [13..13] This bit controls the interrupt is enabled or not when
                                                     channel 5 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch6_en : 1;        /*!< [14..14] This bit controls the interrupt is enabled or not when
                                                     channel 6 comparison criterion matches.                                   */
      __IOM uint32_t it_comp_ch7_en : 1;        /*!< [15..15] This bit controls the interrupt is enabled or not when
                                                     channel 7 comparison criterion matches.                                   */
    } intr_ctrl_b;
  } ;
  
  union {
    __IM  uint32_t intr_raw_sts;                /*!< (@ 0x00000050) ADC Interrupt RAW Status Register                          */
    
    struct {
      __IM  uint32_t it_cvlist_end : 1;         /*!< [0..0] This bit is the raw status of channel conversion list
                                                     end interrupt.                                                            */
      __IM  uint32_t it_cv_end  : 1;            /*!< [1..1] This bit is the raw status of each conversion end interrupt.       */
      __IM  uint32_t it_chcv_end : 1;           /*!< [2..2] This bit is the raw status of particular channel conversion
                                                     end interrupt.                                                            */
      __IM  uint32_t it_fifo_full : 1;          /*!< [3..3] This bit is the raw status of FIFO full interrupt.                 */
      __IM  uint32_t it_fifo_over : 1;          /*!< [4..4] This bit is the raw status of FIFO overflow interrupt.             */
      __IM  uint32_t it_fifo_empty : 1;         /*!< [5..5] This bit is the raw status of FIFO empty interrupt.                */
      __IM  uint32_t it_dat_ovw : 1;            /*!< [6..6] This bit is the raw status of global data register overwritten
                                                     interrupt.                                                                */
      __IM  uint32_t it_err     : 1;            /*!< [7..7] This bit is the raw status of error interrupt.                     */
      __IM  uint32_t it_comp_ch0 : 1;           /*!< [8..8] This bit is the raw status of channel 0 comparison interrupt.      */
      __IM  uint32_t it_comp_ch1 : 1;           /*!< [9..9] This bit is the raw status of channel 1 comparison interrupt.      */
      __IM  uint32_t it_comp_ch2 : 1;           /*!< [10..10] This bit is the raw status of channel 2 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch3 : 1;           /*!< [11..11] This bit is the raw status of channel 3 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch4 : 1;           /*!< [12..12] This bit is the raw status of channel 4 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch5 : 1;           /*!< [13..13] This bit is the raw status of channel 5 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch6 : 1;           /*!< [14..14] This bit is the raw status of channel 6 comparison
                                                     interrupt.                                                                */
      __IM  uint32_t it_comp_ch7 : 1;           /*!< [15..15] This bit is the raw status of channel 7 comparison
                                                     interrupt.                                                                */
    } intr_raw_sts_b;
  } ;
  
  union {
    __IOM uint32_t intr_sts;                    /*!< (@ 0x00000054) ADC Interrupt Status Register                              */
    
    struct {
      __IOM uint32_t it_cvlist_end : 1;         /*!< [0..0] This bit is the status of channel conversion list end
                                                     interrupt.                                                                */
      __IOM uint32_t it_cv_end  : 1;            /*!< [1..1] This bit is the status of each conversion end interrupt.           */
      __IOM uint32_t it_chcv_end : 1;           /*!< [2..2] This bit is the status of particular channel conversion
                                                     end interrupt.                                                            */
      __IOM uint32_t it_fifo_full : 1;          /*!< [3..3] This bit is the status of FIFO full interrupt.                     */
      __IOM uint32_t it_fifo_over : 1;          /*!< [4..4] This bit is the status of FIFO overflow interrupt.                 */
      __IOM uint32_t it_fifo_empty : 1;         /*!< [5..5] This bit is the status of FIFO empty interrupt.                    */
      __IOM uint32_t it_dat_ovw : 1;            /*!< [6..6] This bit is the status of global data register overwritten
                                                     interrupt.                                                                */
      __IOM uint32_t it_err     : 1;            /*!< [7..7] This bit is the status of error interrupt.                         */
      __IOM uint32_t it_comp_ch0 : 1;           /*!< [8..8] This bit is the status of channel 0 comparison interrupt.          */
      __IOM uint32_t it_comp_ch1 : 1;           /*!< [9..9] This bit is the status of channel 1 comparison interrupt.          */
      __IOM uint32_t it_comp_ch2 : 1;           /*!< [10..10] This bit is the status of channel 2 comparison interrupt.        */
      __IOM uint32_t it_comp_ch3 : 1;           /*!< [11..11] This bit is the status of channel 3 comparison interrupt.        */
      __IOM uint32_t it_comp_ch4 : 1;           /*!< [12..12] This bit is the status of channel 4 comparison interrupt.        */
      __IOM uint32_t it_comp_ch5 : 1;           /*!< [13..13] This bit is the status of channel 5 comparison interrupt.        */
      __IOM uint32_t it_comp_ch6 : 1;           /*!< [14..14] This bit is the status of channel 6 comparison interrupt.        */
      __IOM uint32_t it_comp_ch7 : 1;           /*!< [15..15] This bit is the status of channel 7 comparison interrupt.        */
    } intr_sts_b;
  } ;
  
  union {
    __IOM uint32_t it_chno_con;                 /*!< (@ 0x00000058) ADC Conversion Interrupt Channel Number Configuration
                                                                    Register                                                   */
    
    struct {
      __IOM uint32_t it_chno_con : 3;           /*!< [2..0] This field defines that ADC module should send interrupt
                                                     signal to system when a conversion which of channel number
                                                     is the same as this field. This register is only valid
                                                     when BIT_ADC_IT_CHCV_END_EN is set.                                       */
    } it_chno_con_b;
  } ;
  
  union {
    __IOM uint32_t full_lvl;                    /*!< (@ 0x0000005C) ADC FIFO Full Level Register                               */
    
    struct {
      __IOM uint32_t full_lvl   : 6;            /*!< [5..0] This field defines the FIFO full entry threshold level
                                                     and it is used for FIFO full interrupt. It should be set
                                                     according to ADC FIFO depth.                                              */
    } full_lvl_b;
  } ;
  
  union {
    __IOM uint32_t trig_timer_sel;              /*!< (@ 0x00000060) ADC Trigger Timer Select Register                          */
    
    struct {
      __IOM uint32_t trig_timer_sel : 3;        /*!< [2..0] This field defines which timer channel would be used
                                                     to make ADC module do a conversion.                                       */
    } trig_timer_sel_b;
  } ;
  
  union {
    __IOM uint32_t dat_global;                  /*!< (@ 0x00000064) ADC Global Data Register                                   */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of a
                                                     conversion channel in the list.                                           */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in BIT_ADC_DATA_GLOBAL takes place.                             */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_glb.                                             */
      __IOM uint32_t ch         : 3;            /*!< [25..23] This field indicates which channel data is in dat_glb            */
    } dat_global_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch0;                     /*!< (@ 0x00000068) ADC Channel 0 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     0.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch0 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch0.                                             */
    } dat_ch0_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch1;                     /*!< (@ 0x0000006C) ADC Channel 1 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     1.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch1 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch1.                                             */
    } dat_ch1_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch2;                     /*!< (@ 0x00000070) ADC Channel 2 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     2.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch2 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch2.                                             */
    } dat_ch2_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch3;                     /*!< (@ 0x00000074) ADC Channel 3 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     3.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch3 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch3.                                             */
    } dat_ch3_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch4;                     /*!< (@ 0x00000078) ADC Channel 4 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     4.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch4 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch4.                                             */
    } dat_ch4_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch5;                     /*!< (@ 0x0000007C) ADC Channel 5 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     5.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch5 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch5.                                             */
    } dat_ch5_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch6;                     /*!< (@ 0x00000080) ADC Channel 6 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     6.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch6 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch6.                                             */
    } dat_ch6_b;
  } ;
  
  union {
    __IOM uint32_t dat_ch7;                     /*!< (@ 0x00000084) ADC Channel 7 Data Register                                */
    
    struct {
      __IOM uint32_t dat        : 18;           /*!< [17..0] This field contains the newest conversion data of channel
                                                     7.                                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t ovw        : 1;            /*!< [21..21] This bit indicates that there is a data overwritten
                                                     situation in dat_ch7 takes place.                                         */
      __IOM uint32_t rdy        : 1;            /*!< [22..22] This field indicates that a conversion is done. And
                                                     its data is put into dat_ch7.                                             */
    } dat_ch7_b;
  } ;
  
  union {
    __IOM uint32_t dma_con;                     /*!< (@ 0x00000088) ADC DMA Control Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] This bit controls that DMA function of ADC is enabled
                                                     or not.                                                                   */
      __IM  uint32_t            : 7;
      __IOM uint32_t lvl        : 6;            /*!< [13..8] This field defines the FIFO threshold level that ADC
                                                     module should make a DMA request to DMA module.                           */
    } dma_con_b;
  } ;
  
  union {
    __IOM uint32_t flr;                         /*!< (@ 0x0000008C) ADC FIFO Level Register                                    */
    
    struct {
      __IOM uint32_t flr        : 7;            /*!< [6..0] This field records the current ADC FIFO entry number.              */
    } flr_b;
  } ;
  
  union {
    __IOM uint32_t clr_fifo;                    /*!< (@ 0x00000090) ADC Clear FIFO Register                                    */
    
    struct {
      __IOM uint32_t clr_fifo   : 1;            /*!< [0..0] This bit is used to clear FIFO contents and makes it
                                                     to the default status.                                                    */
    } clr_fifo_b;
  } ;
  
  union {
    __IOM uint32_t clk_div;                     /*!< (@ 0x00000094) ADC Clock Division Register                                */
    
    struct {
      __IOM uint32_t clk_div    : 3;            /*!< [2..0] This field defines clock divider level of ADC module.              */
    } clk_div_b;
  } ;
  
  union {
    __IOM uint32_t dly_cnt;                     /*!< (@ 0x00000098) ADC Delay Couont Register                                  */
    
    struct {
      __IOM uint32_t dly_cnt    : 4;            /*!< [3..0] This field defines channel switch delay count.                     */
    } dly_cnt_b;
  } ;
  
  union {
    __IOM uint32_t pwr_ctrl;                    /*!< (@ 0x0000009C) ADC Power Control Register                                 */
    
    struct {
      __IOM uint32_t pwr_ctrl   : 1;            /*!< [0..0] This field is used to power control.                               */
    } pwr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad0;                     /*!< (@ 0x000000A0) ADC Analog Control 0 Register                              */
    
    struct {
      __IOM uint32_t pwr_cut    : 1;            /*!< [0..0] This field is for analog usage.                                    */
      __IOM uint32_t en         : 1;            /*!< [1..1] This field is for analog usage.                                    */
      __IOM uint32_t ref_en     : 1;            /*!< [2..2] This field is for analog usage.                                    */
      __IOM uint32_t cal_en     : 1;            /*!< [3..3] This field is for analog usage.                                    */
      __IOM uint32_t ext_vref_en : 1;           /*!< [4..4] This field is for analog usage.                                    */
      __IOM uint32_t ck         : 1;            /*!< [5..5] This field is for analog usage.                                    */
      __IOM uint32_t ckd2       : 1;            /*!< [6..6] This field is for analog usage.                                    */
      __IOM uint32_t dly        : 1;            /*!< [7..7] This field is for analog usage.                                    */
      __IOM uint32_t samp       : 1;            /*!< [8..8] This field is for analog usage.                                    */
      __IOM uint32_t revck      : 1;            /*!< [9..9] This field is for analog usage.                                    */
      __IOM uint32_t dout       : 1;            /*!< [10..10] This field is for analog usage.                                  */
      __IOM uint32_t bstca      : 1;            /*!< [11..11] This field is for analog usage.                                  */
      __IOM uint32_t avg        : 1;            /*!< [12..12] This field is for analog usage.                                  */
      __IOM uint32_t bypass     : 6;            /*!< [18..13] This field is for analog usage.                                  */
      __IOM uint32_t dat_sel    : 5;            /*!< [23..19] This field is for analog usage.                                  */
      __IOM uint32_t dummy      : 8;            /*!< [31..24] This field is for analog usage.                                  */
    } ana_ad0_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad1;                     /*!< (@ 0x000000A4) ADC Analog Control 1 Register                              */
    
    struct {
      __IOM uint32_t dout0_p    : 2;            /*!< [1..0] This field is for analog usage.                                    */
      __IOM uint32_t dout0_n    : 2;            /*!< [3..2] This field is for analog usage.                                    */
      __IOM uint32_t dout1_p    : 3;            /*!< [6..4] This field is for analog usage.                                    */
      __IOM uint32_t dout1_n    : 3;            /*!< [9..7] This field is for analog usage.                                    */
      __IOM uint32_t dout2_p    : 3;            /*!< [12..10] This field is for analog usage.                                  */
      __IOM uint32_t dout2_n    : 3;            /*!< [15..13] This field is for analog usage.                                  */
      __IOM uint32_t dout3_p    : 4;            /*!< [19..16] This field is for analog usage.                                  */
      __IOM uint32_t dout3_n    : 4;            /*!< [23..20] This field is for analog usage.                                  */
      __IOM uint32_t dout4_n    : 5;            /*!< [28..24] This field is for analog usage.                                  */
      __IOM uint32_t dummy      : 3;            /*!< [31..29] This field is for analog usage.                                  */
    } ana_ad1_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad2;                     /*!< (@ 0x000000A8) ADC Analog Control 2 Register                              */
    
    struct {
      __IOM uint32_t dout4_n    : 5;            /*!< [4..0] This field is for analog usage.                                    */
      __IOM uint32_t dout5_p    : 5;            /*!< [9..5] This field is for analog usage.                                    */
      __IOM uint32_t dout5_n    : 5;            /*!< [14..10] This field is for analog usage.                                  */
      __IOM uint32_t dout6_p    : 5;            /*!< [19..15] This field is for analog usage.                                  */
      __IOM uint32_t dout6_n    : 5;            /*!< [24..20] This field is for analog usage.                                  */
      __IOM uint32_t dout7_p    : 5;            /*!< [29..25] This field is for analog usage.                                  */
      __IOM uint32_t dummy      : 2;            /*!< [31..30] This field is for analog usage.                                  */
    } ana_ad2_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad3;                     /*!< (@ 0x000000AC) ADC Analog Control 3 Register                              */
    
    struct {
      __IOM uint32_t dout7_n    : 5;            /*!< [4..0] This field is for analog usage.                                    */
      __IOM uint32_t dout8_p    : 5;            /*!< [9..5] This field is for analog usage.                                    */
      __IOM uint32_t dout8_n    : 5;            /*!< [14..10] This field is for analog usage.                                  */
      __IOM uint32_t dout9_p    : 6;            /*!< [20..15] This field is for analog usage.                                  */
      __IOM uint32_t dout9_n    : 6;            /*!< [26..21] This field is for analog usage.                                  */
      __IOM uint32_t dummy      : 5;            /*!< [31..27] This field is for analog usage.                                  */
    } ana_ad3_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad4;                     /*!< (@ 0x000000B0) ADC Analog Control 4 Register                              */
    
    struct {
      __IOM uint32_t dout10_p   : 5;            /*!< [4..0] This field is for analog usage.                                    */
      __IOM uint32_t dout10_n   : 5;            /*!< [9..5] This field is for analog usage.                                    */
      __IOM uint32_t dout11_p   : 5;            /*!< [14..10] This field is for analog usage.                                  */
      __IOM uint32_t dout11_n   : 6;            /*!< [20..15] This field is for analog usage.                                  */
      __IM  uint32_t            : 5;
      __IOM uint32_t dummy      : 6;            /*!< [31..26] This field is for analog usage.                                  */
    } ana_ad4_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad5;                     /*!< (@ 0x000000B4) ADC Analog Control 5 Register                              */
    
    struct {
      __IOM uint32_t dout12_p   : 8;            /*!< [7..0] This field is for analog usage.                                    */
      __IOM uint32_t dout12_n   : 8;            /*!< [15..8] This field is for analog usage.                                   */
      __IOM uint32_t dout13_p   : 8;            /*!< [23..16] This field is for analog usage.                                  */
      __IOM uint32_t dout13_n   : 8;            /*!< [31..24] This field is for analog usage.                                  */
    } ana_ad5_b;
  } ;
  
  union {
    __IOM uint32_t ana_ad6;                     /*!< (@ 0x000000B8) ADC Analog Control 6 Register                              */
    
    struct {
      __IOM uint32_t dout_offp  : 6;            /*!< [5..0] This field is for analog usage.                                    */
      __IOM uint32_t dout_offn  : 6;            /*!< [11..6] This field is for analog usage.                                   */
      __IOM uint32_t dummy      : 4;            /*!< [15..12] This field is for analog usage.                                  */
    } ana_ad6_b;
  } ;
} ADC_Type;                                     /*!< Size = 188 (0xbc)                                                         */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART port 0, 7/8 bit frame, 1/2 stop bit, up to 4000000 baud rate (UART0)
  */

typedef struct {                                /*!< (@ 0x40040000) UART0 Structure                                            */
  
  union {
    __IOM uint32_t dll;                         /*!< (@ 0x00000000) Divisor Latch (LS) Register                                */
    
    struct {
      __IOM uint32_t dll        : 8;            /*!< [7..0] Baud rate divisor-low register, accessable only when
                                                     DLAB = 1                                                                  */
    } dll_b;
  } ;
  
  union {
    union {
      __IOM uint32_t dlm;                       /*!< (@ 0x00000004) Divisor Latch (MS) Register                                */
      
      struct {
        __IOM uint32_t dlm      : 8;            /*!< [7..0] Baud rate divisor-high register, accessable only when
                                                     DLAB = 1                                                                  */
      } dlm_b;
    } ;
    
    union {
      __IOM uint32_t ier;                       /*!< (@ 0x00000004) Interrupt Enable Register                                  */
      
      struct {
        __IOM uint32_t erbi     : 1;            /*!< [0..0] Enable Received Data Available Interrupt (ERBFI) (rx
                                                     trigger)                                                                  */
        __IOM uint32_t etbei    : 1;            /*!< [1..1] Enable Transmitter FIFO Empty interrupt (ETBEI) (tx fifo
                                                     empty)                                                                    */
        __IOM uint32_t elsi     : 1;            /*!< [2..2] Enable Receiver Line Status Interrupt (ELSI) (receiver
                                                     line status)                                                              */
        __IOM uint32_t edssi    : 1;            /*!< [3..3] Enable Modem Status Interrupt (EDSSI) (modem status transition)    */
      } ier_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t iir;                       /*!< (@ 0x00000008) Interrupt Identification Register                          */
      
      struct {
        __IM  uint32_t int_pend : 1;            /*!< [0..0] Indicates that an interrupt is pending when it's logic
                                                     0. When it is 1, no interrupt is pending                                  */
        __IM  uint32_t int_id   : 3;            /*!< [3..1] Bit1 and Bit2 the two bits of the IIR are used to identify
                                                     the highest priority interrupt pending as indicated in
                                                     the following table Bit3: In the FIFO mode this bit is
                                                     set along with bit 2 when a timeout interrupt is pending.                 */
      } iir_b;
    } ;
    
    union {
      __IOM uint32_t fcr;                       /*!< (@ 0x00000008) FIFO Control Register                                      */
      
      struct {
        __OM  uint32_t en_rxfifo_err : 1;       /*!< [0..0] Set as 1 to enable the report of Error in RCVR FIFO field
                                                     in LSR bit [7]                                                            */
        __OM  uint32_t clear_rxfifo : 1;        /*!< [1..1] Writing a Logic 1 to Bit 1 clears the Receiver FIFO and
                                                     resets its logic. But it doesn't clear the shift register.
                                                     The 1 that is written to this bit position is self-clearing.              */
        __OM  uint32_t clear_txfifo : 1;        /*!< [2..2] Write 1 to this bit clears the Transmitter FIFO and resets
                                                     its logic. But the shift register is not cleared, The 1
                                                     that is written to this bit position is self-clearing.                    */
        __OM  uint32_t dma_mode : 1;            /*!< [3..3] Support DMA mode. (cooperate with DW DDMA in the data
                                                     path)                                                                     */
        __IM  uint32_t          : 1;
        __IOM uint32_t txfifo_low_level : 1;    /*!< [5..5] Define the Transmission FIFO Low Water Level Interrupt
                                                     trigger. 0: 4 byte 1: 8 bytes                                             */
        __IOM uint32_t rxfifo_trigger_level : 2;/*!< [7..6] Define the 32-entries Receiver FIFO Interrupt trigger
                                                     level 0~31 bytes 00: 1 byte 01: 8 bytes 10: 16 bytes 11:
                                                     30 bytes (for some device detect RTS de-assertion slower,
                                                     reserve more RX FIFO space to prevent RX FIFO overflow
                                                     )                                                                         */
      } fcr_b;
    } ;
  };
  
  union {
    __IOM uint32_t lcr;                         /*!< (@ 0x0000000C) Line Control Register                                      */
    
    struct {
      __IOM uint32_t wls0       : 1;            /*!< [0..0] Word length selection,                                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t stb        : 1;            /*!< [2..2] This bit specifies the number of Stop bits transmitted
                                                     and received in each serial character. 0: 1 stop bit. 1:
                                                     2 stop bits. Note that the receiver always checks the first
                                                     stop bit only.                                                            */
      __IOM uint32_t parity_en  : 1;            /*!< [3..3] Parity Enable                                                      */
      __IOM uint32_t even_parity_sel : 1;       /*!< [4..4] Even Parity select                                                 */
      __IOM uint32_t stick_parity_en : 1;       /*!< [5..5] Stick Parity enable control. LCR[5:4]: 00: Odd Parity
                                                     01: Even Parity 10: Stick Parity as 0 11: Stick Parity
                                                     as 1                                                                      */
      __IOM uint32_t break_ctrl : 1;            /*!< [6..6] Break Control bit. Break control bit causes a break condition
                                                     to be transmitted to the receiving UART.                                  */
      __IOM uint32_t dlab       : 1;            /*!< [7..7] Divisor Latch Access bit Note: DLL/DLM only can be access
                                                     when dlab bit = 1, IER only can be access when dlab bit
                                                     = 0. THR/RBR don't care about dlab bit value                              */
    } lcr_b;
  } ;
  
  union {
    __IOM uint32_t mcr;                         /*!< (@ 0x00000010) Modem Control Register                                     */
    
    struct {
      __IOM uint32_t dtr        : 1;            /*!< [0..0] Data Terminal Ready (DTR) signal control 0::DTR is logic
                                                     1 1::DTR is logic 0                                                       */
      __IOM uint32_t rts        : 1;            /*!< [1..1] Request to Send (RTS) signal control 0: RTS is logic
                                                     1 1: RTS is logic 0 The RTS output is controlled as following
                                                     equation: RTS_output = rts_en ? (~rts|FIFO_FlowCtrl):~rts                 */
      __IOM uint32_t out1       : 1;            /*!< [2..2] This bit controls the Output 1 (OUT1_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t out2       : 1;            /*!< [3..3] This bit controls the output 2 (OUT2_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t loopback_en : 1;           /*!< [4..4] LoopBack mode. This bit provides a local loopback feature
                                                     for diagnostic testing of the UART.                                       */
      __IOM uint32_t cts_en     : 1;            /*!< [5..5] CTS flow control enable (CTSE) This Bit (CTSE) is the
                                                     auto CTS flow control enable. When set (1), the auto CTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t rts_en     : 1;            /*!< [6..6] RTS flow control enable (RTSE) This Bit (RTSE) is the
                                                     auto RTS flow control enables. When set (1), the auto RTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t sw_cts     : 1;            /*!< [7..7] Software controlled CTS. The software can use this bit
                                                     to pause the UART transmission, just like the HW flow control.This
                                                     bit setting will effects the CTS flow-control: CTS = cts_en
                                                     ? (sw_cts | CTS_input) : sw_cts                                           */
    } mcr_b;
  } ;
  
  union {
    __IM  uint32_t lsr;                         /*!< (@ 0x00000014) Line Status Register                                       */
    
    struct {
      __IM  uint32_t rxfifo_datardy : 1;        /*!< [0..0] Data Ready (DR) indicator This bit is 1 when at least
                                                     one character has been received and transferred into the
                                                     FIFO. It be reset to logic 0 by reading all of the data
                                                     in the Receiver Buffer Register or the RX FIFO.                           */
      __IM  uint32_t overrun_err : 1;           /*!< [1..1] Overrun Error (OE) indicator. This bit is set (1) to
                                                     indicates that data in the RX FIFO was not read by the
                                                     CPU before the next character was transferred into the
                                                     RX FIFO,                                                                  */
      __IM  uint32_t parity_err : 1;            /*!< [2..2] Parity Error (PE) indicator. This bit is set to indicates
                                                     that the received data character does not have the correct
                                                     even or odd parity, as selected by the even-parity-select
                                                     bit.                                                                      */
      __IM  uint32_t framing_err : 1;           /*!< [3..3] Framing Error (FE) indicator. This bit is set when the
                                                     received character at the top of the FIFO did not have
                                                     a valid stop bit.                                                         */
      __IM  uint32_t break_err_int : 1;         /*!< [4..4] Break Interrupt (BI) indicator. This bit is set to logic
                                                     1 whenever the received data input is held in the Spacing
                                                     (logic 0) state for a longer than a full word transmission
                                                     time.                                                                     */
      __IM  uint32_t txfifo_empty : 1;          /*!< [5..5] TXFIFO empty indicator. It indicates that the Transmitter
                                                     FIFO is empty. This bit is set when the Transmitter FIFO
                                                     is empty; it is cleared when at least 1 byte is written
                                                     to the Transmitter FIFO.                                                  */
      __IM  uint32_t            : 1;
      __IM  uint32_t rxfifo_err : 1;            /*!< [7..7] Uart_rx_error. This bit is set when there is at least
                                                     on parity error, framing error or break indication in the
                                                     FIFO. It is clear when the CPU reads the LSR, if there
                                                     are no subsequent errors in the FIFO                                      */
    } lsr_b;
  } ;
  
  union {
    __IM  uint32_t msr;                         /*!< (@ 0x00000018) Modem Status Register                                      */
    
    struct {
      __IM  uint32_t d_cts      : 1;            /*!< [0..0] Delta Clear to Send (DCTS) indicator                               */
      __IM  uint32_t d_dsr      : 1;            /*!< [1..1] Delta Data Set Ready (DDSR) indicator                              */
      __IM  uint32_t teri       : 1;            /*!< [2..2] Trailing Edge of Ring Indicator (TERI) detector. The
                                                     RI line has changed its state from low to high state.                     */
      __IM  uint32_t d_dcd      : 1;            /*!< [3..3] Delta Data Carrier Detect (DDCD) indicator.                        */
      __IM  uint32_t r_cts      : 1;            /*!< [4..4] Complement of the CTS input or equals to RTS in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dsr      : 1;            /*!< [5..5] Complement of the DSR input or equals to DTR in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_ri       : 1;            /*!< [6..6] Complement of the RI input or equals to Out1 in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dcd      : 1;            /*!< [7..7] Complement of the DCD input or equals to Out2 in loopback
                                                     mode.                                                                     */
    } msr_b;
  } ;
  
  union {
    __IOM uint32_t scr;                         /*!< (@ 0x0000001C) Scratch Pad Register                                       */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t pin_lb_test : 1;           /*!< [3..3] For uart IP txd/rxd/rts/cts pin loopback test                      */
      __IM  uint32_t fl_frame_err : 1;          /*!< [4..4] Frame error flag                                                   */
      __IM  uint32_t fl_set_bi_err : 1;         /*!< [5..5] set_bi_err flag                                                    */
      __IOM uint32_t rx_break_int_en : 1;       /*!< [6..6] Rx break signal interrupt enable                                   */
      __IOM uint32_t rx_break_int_sts : 1;      /*!< [7..7] Rx break signal interrupt status, write 1 to this bit
                                                     will clear the interrupt pending status                                   */
      __IOM uint32_t dbg_sel    : 4;            /*!< [11..8] Debug port selection                                              */
      __IM  uint32_t            : 4;
      __IOM uint32_t xfactor_adj : 11;          /*!< [26..16] The ovsr_adj, one of factors of baud rate calculation            */
    } scr_b;
  } ;
  
  union {
    __IOM uint32_t stsr;                        /*!< (@ 0x00000020) STS Register                                               */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t reset_rcv  : 1;            /*!< [3..3] Reset Uart Receiver                                                */
      __IOM uint32_t xfactor    : 4;            /*!< [7..4] Factor of Baud rate calculation, the ovsr[3:0]                     */
      __IM  uint32_t            : 16;
      __IM  uint32_t dma_mode   : 1;            /*!< [24..24] dma_mode field of FCR bit[3]                                     */
      __IM  uint32_t fifo_en    : 1;            /*!< [25..25] fifo_en field of FCR bit[0]                                      */
      __IM  uint32_t txfifo_low_level : 1;      /*!< [26..26] txfifo_low_level in FCR bit[5], Define the Transmission
                                                     FIFO Low Water Level Interrupt trigger. 0: 4 byte 1: 8
                                                     bytes                                                                     */
      __IM  uint32_t rxfifo_trigger_level : 2;  /*!< [28..27] rxfifo_trigger_level in FCR bit[7:6], Define the 32-entries
                                                     Receiver FIFO Interrupt trigger level 0~31 bytes 00: 1
                                                     byte 01: 8 bytes 10: 16 bytes 11: 28 bytes (for some device
                                                     detect RTS de-assertion slower, reserve more RX FIFO space
                                                     to prevent RX FIFO overflow )                                             */
    } stsr_b;
  } ;
  
  union {
    union {
      __IM  uint32_t rbr;                       /*!< (@ 0x00000024) Receiver Buffer Register                                   */
      
      struct {
        __IM  uint32_t rxdata   : 8;            /*!< [7..0] Rx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially received.                                              */
      } rbr_b;
    } ;
    
    union {
      __OM  uint32_t thr;                       /*!< (@ 0x00000024) Transmitter Holder Register                                */
      
      struct {
        __OM  uint32_t txdata   : 8;            /*!< [7..0] Tx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially transmitted.                                           */
      } thr_b;
    } ;
  };
  
  union {
    __IOM uint32_t miscr;                       /*!< (@ 0x00000028) MISC Control Register                                      */
    
    struct {
      __IOM uint32_t irda_enable : 1;           /*!< [0..0] IRDA mode enable control. When set this bit as 1, the
                                                     UART is co-work with IRDA SIR mode. i.e., txd/rxd are irda
                                                     signals.                                                                  */
      __IOM uint32_t txdma_en   : 1;            /*!< [1..1] TX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t rxdma_en   : 1;            /*!< [2..2] RX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t txdma_burstsize : 5;       /*!< [7..3] Txdma burstsize                                                    */
      __IOM uint32_t rxdma_burstsize : 6;       /*!< [13..8] Rxdma burstsize                                                   */
      __IOM uint32_t irda_tx_inv : 1;           /*!< [14..14] Invert irda_tx_o when this bit is 1.                             */
      __IOM uint32_t irda_rx_inv : 1;           /*!< [15..15] Invert irda_rx_i when this bit is 1.                             */
      __IOM uint32_t tx_en      : 1;            /*!< [16..16] The UART TX function.enable control                              */
    } miscr_b;
  } ;
  
  union {
    __IOM uint32_t txplsr;                      /*!< (@ 0x0000002C) IRDA SIR TX Pulse Width Control 0 Register                 */
    
    struct {
      __IOM uint32_t txpulse_lowbound_shiftval : 15;/*!< [14..0] The shift value of SIR tx pulse's left edge position.         */
      __IOM uint32_t lowbound_shiftright : 1;   /*!< [15..15] SIR TX pulse lower bond shift control.                           */
      __IOM uint32_t txpulse_upperbound_shiftval : 15;/*!< [30..16] The shift value of SIR tx pulse's right edge position.     */
      __IOM uint32_t Upperbound_shiftright : 1; /*!< [31..31] SIR TX pulse upper bond shift control.                           */
    } txplsr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t baudmonr;                    /*!< (@ 0x00000034) Baud Monitor Register                                      */
    
    struct {
      __IM  uint32_t min_fall_space : 12;       /*!< [11..0] Min_fall_space                                                    */
      __IM  uint32_t min_low_period : 12;       /*!< [23..12] Min_low_period                                                   */
      __IOM uint32_t falling_thresh : 6;        /*!< [29..24] Falling_thresh                                                   */
      __IM  uint32_t mon_data_vld : 1;          /*!< [30..30] The monitor data valid indication                                */
      __IOM uint32_t toggle_mon_en : 1;         /*!< [31..31] Baud monitor toggle bit enable.                                  */
    } baudmonr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t dbg2;                        /*!< (@ 0x0000003C) Debug Register                                             */
    
    struct {
      __IM  uint32_t dbg_uart   : 32;           /*!< [31..0] The debug port output value, depend on dbg_sel value
                                                     in SCR[2:0].                                                              */
    } dbg2_b;
  } ;
  
  union {
    __IOM uint32_t rfcr;                        /*!< (@ 0x00000040) RX Filter Control Register                                 */
    
    struct {
      __IOM uint32_t rf_len     : 1;            /*!< [0..0] Set the length of received data to be check. 0/1 = 1bytes/2bytes   */
      __IOM uint32_t rf_mask_en : 1;            /*!< [1..1] Enable the mask operation for received data.                       */
      __IOM uint32_t rf_cmp_op  : 2;            /*!< [3..2] Set the RX filter comparing rule. The matched condition
                                                     is listed as following table: RF_LEN = 0: RF_CMP_OP = 0
                                                     (AND) 1st byte = Magic Pattern1 1 (OR) (1st byte = Magic
                                                     Pattern1) OR (1st byte = Magic Pattern2) 2 (XOR) (1st byte
                                                     != Magic Pattern1) AND (1st byte != Magic Pattern2) RF_LEN
                                                     = 1: RF_CMP_OP = 0 (AND) (1st byte = Magic Pattern1) AND
                                                     (2nd byte = Magic Pattern2) 1 (OR) (2nd byte = Magic Pattern1)
                                                     OR (2nd byte = Magic Pattern2) 2 (XOR) (1st byte != Magic
                                                     Pattern1) AND (2nd byte != Magic Patte                                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t rf_en      : 1;            /*!< [7..7] RX Filter enable control                                           */
    } rfcr_b;
  } ;
  
  union {
    __IOM uint32_t rfmpr;                       /*!< (@ 0x00000044) RX Filter Magic Pattern Register                           */
    
    struct {
      __IOM uint32_t rf_mp1     : 8;            /*!< [7..0] The magic pattern1 for the 1st received byte checking.             */
      __IOM uint32_t rf_mp2     : 8;            /*!< [15..8] The magic pattern2 for the 2nd received byte checking.            */
    } rfmpr_b;
  } ;
  
  union {
    __IOM uint32_t rfmvr;                       /*!< (@ 0x00000048) RX Filter Mask Value Register                              */
    
    struct {
      __IOM uint32_t rf_mv1     : 8;            /*!< [7..0] The mask value for the 1st received byte.                          */
      __IOM uint32_t rf_mv2     : 8;            /*!< [15..8] The mask value for the 2nd received byte.                         */
    } rfmvr_b;
  } ;
  
  union {
    __IOM uint32_t rftor;                       /*!< (@ 0x0000004C) RX Filter Timeout Register                                 */
    
    struct {
      __IOM uint32_t rf_timeout : 20;           /*!< [19..0] Set the timeout value of the RX filter idle detection.
                                                     This value is number of ticks. A tick time is equal to
                                                     a UART bit time.                                                          */
    } rftor_b;
  } ;
  
  union {
    __IOM uint32_t rflvr;                       /*!< (@ 0x00000050) RX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t rx_fifo_lv : 6;            /*!< [5..0] The level of the RX FIFO. This value indicates the number
                                                     of data bytes in the RX FIFO.                                             */
    } rflvr_b;
  } ;
  
  union {
    __IOM uint32_t tflvr;                       /*!< (@ 0x00000054) TX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t tx_fifo_lv : 5;            /*!< [4..0] The level of the TX FIFO. This value indicates the number
                                                     of data bytes in the TX FIFO.                                             */
    } tflvr_b;
  } ;
  
  union {
    __IOM uint32_t visr;                        /*!< (@ 0x00000058) Vendor Interrupt Status Register                           */
    
    struct {
      __IOM uint32_t rf_match_patt : 1;         /*!< [0..0] The interrupt status of RX filter pattern checking matched.
                                                     Write 1 to clear this interrupt status. 0: Interrupt is
                                                     not pending. 1: Interrupt is pending.                                     */
      __IOM uint32_t rf_timeout : 1;            /*!< [1..1] This bit indicates the interrupt pending status of the
                                                     RX filter timeout occurred. The RX idle detection mechanism
                                                     is used to check whether the receiving is in idle state
                                                     for re-aquire pattern matching. This mechanism uses a timer
                                                     to monitor new data receiving. This timer will reload the
                                                     initial value whenever a new byte is received. If the timeout
                                                     occurred (timer value countdown to 0), the RX filter will
                                                     be reset to the initialed state and restart the first received
                                                     1 or 2 bytes checking.                                                    */
      __IOM uint32_t tx_fifo_lv : 1;            /*!< [2..2] This bit indicates the interrupt pending status of the
                                                     TX FIFO water level equal to the level setting. The software
                                                     can use this interrupt to know the TX FIFO water level
                                                     is low and refill the TX FIFO. To enable this interrupt,
                                                     IER bit[5] should be written as 1. Write 1 to this bit
                                                     will clear the pending status.                                            */
      __IOM uint32_t rx_idle_timeout : 1;       /*!< [3..3] This bit indicate the receiver idle timeout interrupt
                                                     pending status. Write 1 to this bit will clear the pending
                                                     status.                                                                   */
    } visr_b;
  } ;
  
  union {
    __IOM uint32_t vier;                        /*!< (@ 0x0000005C) Vendor Interrupt Enabling Control Register                 */
    
    struct {
      __IOM uint32_t rf_match_int_en : 1;       /*!< [0..0] The Rx filter pattern matched interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t rf_timeout_int_en : 1;     /*!< [1..1] The Rx filter idle timeout interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t tx_fifo_lv_int_en : 1;     /*!< [2..2] The TX FIFO water level interrupt enabling control: 1:
                                                     enable 0: disable                                                         */
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [3..3] The RX idle timeout interrupt enabling control: 1: enable
                                                     0: disable                                                                */
    } vier_b;
  } ;
  
  union {
    __IOM uint32_t ritor;                       /*!< (@ 0x00000060) RX Idle Timeout Register                                   */
    
    struct {
      __IOM uint32_t rxidle_timeout_value : 4;  /*!< [3..0] Time unit is the duration of a UART bit, depends on the
                                                     baud-rate setting. Default 0. 0: 8 bit time. (1*8) 1: 16
                                                     bit time. (2*8) 2: 32 bit time. (2^2*8) 3: 64 bit time.
                                                     (2^3*8) 4: 128 bit time. (2^4*8) 5: 256 bit time. (2^5*8)
                                                     6: 512 bit time. (2^6*8) 7: 1024 bit time. (2^7*8) 8: 2048
                                                     bit time. (2^8*8) 9: 4096 bit time. (2^9*8) 10: 8192 bit
                                                     time. (2^10*8) 11: 16384 bit time. (2^11*8) 12: 32768 bit
                                                     time. (2^12*8) 13: 65535 bit time. (2^13*8) 14: 131072
                                                     bit time. (2^14*8) 15: 262144 bit time. (2^15*8)                          */
      __IM  uint32_t            : 27;
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [31..31] RX idle timeout enable, default 0.                               */
    } ritor_b;
  } ;
} UART0_Type;                                   /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                           SSI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SSI supports 8 bit and 16 bit frame format with different combination of clock phase and clock polarity(mode 0 ~ mode 3). Some SSI devices have limited capability. SSI0 & SSI1 are full funtion devices that can be a master or a slave device. In contrast, SSI 2 can only be master devices while SSI3 can only be a slave device. Note that SSI3 suppots SPI protocol only. (SSI0)
  */

typedef struct {                                /*!< (@ 0x40042000) SSI0 Structure                                             */
  
  union {
    __IOM uint32_t ctrlr0;                      /*!< (@ 0x00000000) SSI Control Register 0                                     */
    
    struct {
      __IOM uint32_t dfs        : 4;            /*!< [3..0] Data frame size                                                    */
      __IOM uint32_t frf        : 2;            /*!< [5..4] Frame format                                                       */
      __IOM uint32_t scph       : 1;            /*!< [6..6] Serial Clock Phase. Valid when the frame format (FRF)
                                                     is set to Motorola SPI. The serial clock phase selects
                                                     the relationship of the serial clock with the slave select
                                                     signal. When SCPH = 0, data are captured on the first edge
                                                     of the serial clock. When SCPH = 1, the serial clock starts
                                                     toggling one cycle after the slave select line is activated,
                                                     and data are captured on the second edge of the serial
                                                     clock. 0: Serial clock toggles in middle of first data
                                                     bit 1: Serial clock toggles at start of first data bi                     */
      __IOM uint32_t scpol      : 1;            /*!< [7..7] Serial Clock Polarity. Valid when the frame format (FRF)
                                                     is set to Motorola SPI. Used to select the polarity of
                                                     the inactive serial clock, which is held inactive when
                                                     the DW_apb_ssi master is not actively transferring data
                                                     on the serial bus. 0 : Inactive state of serial clock is
                                                     low 1 : Inactive state of serial clock is high                            */
      __IOM uint32_t tmod       : 2;            /*!< [9..8] Transfer mode                                                      */
      __IOM uint32_t slv_oe     : 1;            /*!< [10..10] Slave ouput enable. Relevant only when the device is
                                                     a slave                                                                   */
      __IM  uint32_t            : 1;
      __IOM uint32_t cfs        : 4;            /*!< [15..12] Control frame size for Microwire frame format                    */
      __IM  uint32_t            : 5;
      __IOM uint32_t tx_byte_swap : 1;          /*!< [21..21] Reverse every transmit byte                                      */
      __IOM uint32_t tx_bit_swap : 1;           /*!< [22..22] Reverse every transmit bit                                       */
      __IOM uint32_t rx_byte_swap : 1;          /*!< [23..23] Reverse every received byte                                      */
      __IOM uint32_t rx_bit_swap : 1;           /*!< [24..24] Reverse every received bit                                       */
      __IM  uint32_t            : 6;
      __IOM uint32_t ss_t       : 1;            /*!< [31..31] SSI master chooses to toggle between successive frames
                                                     or not. SPI3 does not support this feature.                               */
    } ctrlr0_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr1;                      /*!< (@ 0x00000004) SSI Control Register 1                                     */
    
    struct {
      __IOM uint32_t ndf        : 16;           /*!< [15..0] Number of data frame. Only valid when SSI device is
                                                     a master                                                                  */
    } ctrlr1_b;
  } ;
  
  union {
    __IOM uint32_t ssienr;                      /*!< (@ 0x00000008) SSI Enable Register                                        */
    
    struct {
      __IOM uint32_t ssi_en     : 1;            /*!< [0..0] SSI Enable. Enables and disables all DW_apb_ssi operations.
                                                     When disabled, all serial transfers are halted immediately.
                                                     Transmit and receive FIFO buffers are cleared when the
                                                     device is disabled. It is impossible to program some of
                                                     the DW_apb_ssi control registers when enabled. When disabled,
                                                     the ssi_sleep output is set (after delay) to inform the
                                                     system that it is safe to remove the ssi_clk, thus saving
                                                     power consumption in the system                                           */
    } ssienr_b;
  } ;
  
  union {
    __IOM uint32_t mwcr;                        /*!< (@ 0x0000000C) Microwire Control Register                                 */
    
    struct {
      __IOM uint32_t mwmod      : 1;            /*!< [0..0] Microwire Transfer Mode. Defines the transfer is sequential
                                                     or not.SPI3 does not support this feature.                                */
      __IOM uint32_t mdd        : 1;            /*!< [1..1] Microwire Control. Defines the direction of the data
                                                     word when the Microwire serial protocol is used.SPI3 does
                                                     not support this feature.                                                 */
      __IOM uint32_t mhs        : 1;            /*!< [2..2] Microwire Handshaking. Only valide when SSI device is
                                                     a slave.SPI3 does not support this feature.                               */
    } mwcr_b;
  } ;
  
  union {
    __IOM uint32_t ser;                         /*!< (@ 0x00000010) Slave Enable Register                                      */
    
    struct {
      __IOM uint32_t ser        : 8;            /*!< [7..0] This register is only valid when the device is configured
                                                     as a master device. It is used to select which slave devices
                                                     it would like to communicate with.                                        */
    } ser_b;
  } ;
  
  union {
    __IOM uint32_t baudr;                       /*!< (@ 0x00000014) Baud Rate Select Register                                  */
    
    struct {
      __IOM uint32_t sckdv      : 16;           /*!< [15..0] This register is only valid when the device is configured
                                                     as a master device. It is used to change the operating
                                                     frequency of SPI device.                                                  */
    } baudr_b;
  } ;
  
  union {
    __IOM uint32_t txftlr;                      /*!< (@ 0x00000018) Transmit FIFO Threshold Level                              */
    
    struct {
      __IOM uint32_t tft        : 8;            /*!< [7..0] Transmit FIFO Threshold. Controls the level of entries
                                                     (or below) at which the transmit FIFO controller triggers
                                                     an interrupt.                                                             */
    } txftlr_b;
  } ;
  
  union {
    __IOM uint32_t rxftlr;                      /*!< (@ 0x0000001C) Receive FIFO Threshold Level                               */
    
    struct {
      __IOM uint32_t rft        : 8;            /*!< [7..0] Receive FIFO Threshold. Controls the level of entries
                                                     (or above) at which the receive FIFO controller triggers
                                                     an interrupt.                                                             */
    } rxftlr_b;
  } ;
  
  union {
    __IOM uint32_t txflr;                       /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
    
    struct {
      __IM  uint32_t txtfl      : 8;            /*!< [7..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000024) Receive FIFO Level Register                                */
    
    struct {
      __IM  uint32_t rxtfl      : 8;            /*!< [7..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IM  uint32_t sr;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] SSI Busy Flag. When set, indicates that a serial transfer
                                                     is in progress; when cleared indicates that the DW_apb_ssi
                                                     is idle or disabled.                                                      */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. 0 : Transmit FIFO is full 1 : Transmit FIFO is
                                                     not full                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When the transmit FIFO contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. 0 : Transmit FIFO
                                                     is not empty 1 : Transmit FIFO is empty                                   */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. Set when the receive FIFO contains
                                                     one or more entries and is cleared when the receive FIFO
                                                     is empty. This bit can be polled by software to completely
                                                     empty the receive FIFO. 0 : Receive FIFO is empty 1 : Receive
                                                     FIFO is not empty                                                         */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. 0 : Receive
                                                     FIFO is not full 1 : Receive FIFO is full                                 */
      __IM  uint32_t txe        : 1;            /*!< [5..5] Transmission Error. Set if the transmit FIFO is empty
                                                     when a transfer is started. This bit can be set only when
                                                     the DW_apb_ssi is configured as a slave device. Data from
                                                     the previous transmission is resent on the txd line. This
                                                     bit is cleared when read. 0 : No error 1 : Transmission
                                                     error                                                                     */
    } sr_b;
  } ;
  
  union {
    union {
      __IOM uint32_t imr;                       /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
      
      struct {
        __IOM uint32_t txeim    : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : ssi_txe_intr interrupt
                                                     is masked 1 : ssi_txe_intr interrupt is not masked                        */
        __IOM uint32_t txoim    : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : ssi_txo_intr
                                                     interrupt is masked 1 : ssi_txo_intr interrupt is not masked              */
        __IOM uint32_t rxuim    : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : ssi_rxu_intr
                                                     interrupt is masked 1 : ssi_rxu_intr interrupt is not masked              */
        __IOM uint32_t rxoim    : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : ssi_rxo_intr
                                                     interrupt is masked 1 : ssi_rxo_intr interrupt is not masked              */
        __IOM uint32_t rxfim    : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : ssi_rxf_intr interrupt
                                                     is masked 1 : ssi_rxf_intr interrupt is not masked                        */
        __IOM uint32_t mstim    : 1;            /*!< [5..5] Multi-Master Contention Interrupt Mask. This bit field
                                                     is not present if the deice is a slave. 0 : ssi_mst_intr
                                                     interrupt is masked 1 : ssi_mst_intr interrupt is not masked              */
        __IOM uint32_t txuim    : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status. Should not
                                                     be set when the device is a master and not under SPI mode.
                                                     0 : ssi_txu_intr interrupt is masked 1 : ssi_txu_intr interrupt
                                                     is not masked                                                             */
        __IOM uint32_t ssrim    : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Mask 0 : ssi_ssr_intr
                                                     interrupt is masked 1 : ssi_ssr_intr interrupt is not masked              */
      } imr_b;
    } ;
    
    union {
      __IOM uint32_t imr_slv;                   /*!< (@ 0x0000002C) Interrupt Mask of RTK-SPI Slave Register                   */
      
      struct {
        __IOM uint32_t txeim    : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : ssi_txe_intr interrupt
                                                     is masked 1 : ssi_txe_intr interrupt is not masked                        */
        __IOM uint32_t txoim    : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : ssi_txo_intr
                                                     interrupt is masked 1 : ssi_txo_intr interrupt is not masked              */
        __IOM uint32_t rxuim    : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : ssi_rxu_intr
                                                     interrupt is masked 1 : ssi_rxu_intr interrupt is not masked              */
        __IOM uint32_t rxoim    : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : ssi_rxo_intr
                                                     interrupt is masked 1 : ssi_rxo_intr interrupt is not masked              */
        __IOM uint32_t rxfim    : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : ssi_rxf_intr interrupt
                                                     is masked 1 : ssi_rxf_intr interrupt is not masked                        */
        __IOM uint32_t faeim    : 1;            /*!< [5..5] Frame Alignment Interrupt Mask. Only SPI3 has this bit.
                                                     0 : ssi_fae_intr interrupt is masked 1 : ssi_fae_intr interrupt
                                                     is not masked                                                             */
        __IOM uint32_t txuim    : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status. Should not
                                                     be set when the device is a master and not under SPI mode.
                                                     0 : ssi_txu_intr interrupt is masked 1 : ssi_txu_intr interrupt
                                                     is not masked                                                             */
        __IOM uint32_t ssrim    : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Mask 0 : ssi_ssr_intr
                                                     interrupt is masked 1 : ssi_ssr_intr interrupt is not masked              */
      } imr_slv_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t isr;                       /*!< (@ 0x00000030) Interrupt Status Register                                  */
      
      struct {
        __IM  uint32_t txeis    : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active after masking 1 = ssi_txe_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t txois    : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active after masking 1 = ssi_txo_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxuis    : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active after masking 1 = ssi_rxu_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxois    : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active after masking 1 = ssi_rxo_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxfis    : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status 0 = ssi_rxf_intr interrupt
                                                     is not active after masking 1 = ssi_rxf_intr interrupt
                                                     is full after masking                                                     */
        __IM  uint32_t mstis    : 1;            /*!< [5..5] Multi-Master Contention Interrupt. This bit field is
                                                     not present if the deice is a slave. 0 = ssi_mst_intr interrupt
                                                     not active after masking 1 = ssi_mst_intr interrupt is
                                                     active after masking                                                      */
        __IM  uint32_t txuis    : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active after masking 1 = ssi_txu_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t ssris    : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active after masking 1 = ssi_ssr_intr
                                                     interrupt is active after masking                                         */
      } isr_b;
    } ;
    
    union {
      __IM  uint32_t isr_slv;                   /*!< (@ 0x00000030) Interrupt Status Register                                  */
      
      struct {
        __IM  uint32_t txeis    : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active after masking 1 = ssi_txe_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t txois    : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active after masking 1 = ssi_txo_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxuis    : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active after masking 1 = ssi_rxu_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxois    : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active after masking 1 = ssi_rxo_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t rxfis    : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status 0 = ssi_rxf_intr interrupt
                                                     is not active after masking 1 = ssi_rxf_intr interrupt
                                                     is full after masking                                                     */
        __IM  uint32_t faeis    : 1;            /*!< [5..5] Frame Alignment Interrupt Status. Only SPI3 has this
                                                     bit. 0 = ssi_fae_intr interrupt not active after masking
                                                     1 = ssi_fae_intr interrupt is active after masking                        */
        __IM  uint32_t txuis    : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active after masking 1 = ssi_txu_intr
                                                     interrupt is active after masking                                         */
        __IM  uint32_t ssris    : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active after masking 1 = ssi_ssr_intr
                                                     interrupt is active after masking                                         */
      } isr_slv_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t risr;                      /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
      
      struct {
        __IM  uint32_t txeir    : 1;            /*!< [0..0] Transmit FIFO Empty Raw Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active prior to masking 1 = ssi_txe_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t txoir    : 1;            /*!< [1..1] Transmit FIFO Overflow Raw Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active prior to masking 1 = ssi_txo_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxuir    : 1;            /*!< [2..2] Receive FIFO Underflow Raw Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxu_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxoir    : 1;            /*!< [3..3] Receive FIFO Overflow Raw Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxo_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxfir    : 1;            /*!< [4..4] Receive FIFO Full Raw Interrupt Status 0 = ssi_rxf_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxf_intr
                                                     interrupt is full prior to masking                                        */
        __IM  uint32_t mstir    : 1;            /*!< [5..5] Multi-Master Contention Raw Interrupt Status. This bit
                                                     field is not present if the deice is a slave. 0 = ssi_mst_intr
                                                     interrupt not active prior to masking 1 = ssi_mst_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t txuir    : 1;            /*!< [6..6] Transmit FIFO Under Flow Raw Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active prior to masking 1 = ssi_txu_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t ssrir    : 1;            /*!< [7..7] SS_N Rising Edge Detect Raw Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active prior to masking 1 = ssi_ssr_intr
                                                     interrupt is active prior to masking                                      */
      } risr_b;
    } ;
    
    union {
      __IM  uint32_t risr_slv;                  /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
      
      struct {
        __IM  uint32_t txeir    : 1;            /*!< [0..0] Transmit FIFO Empty Raw Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active prior to masking 1 = ssi_txe_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t txoir    : 1;            /*!< [1..1] Transmit FIFO Overflow Raw Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active prior to masking 1 = ssi_txo_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxuir    : 1;            /*!< [2..2] Receive FIFO Underflow Raw Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxu_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxoir    : 1;            /*!< [3..3] Receive FIFO Overflow Raw Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxo_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t rxfir    : 1;            /*!< [4..4] Receive FIFO Full Raw Interrupt Status 0 = ssi_rxf_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxf_intr
                                                     interrupt is full prior to masking                                        */
        __IM  uint32_t faeir    : 1;            /*!< [5..5] Frame Alignment Error Raw Interrupt Status. Only SPI3
                                                     has this bit. 0 = ssi_fae_intr interrupt not active prior
                                                     to masking 1 = ssi_fae_intr interrupt is active prior to
                                                     masking                                                                   */
        __IM  uint32_t txuir    : 1;            /*!< [6..6] Transmit FIFO Under Flow Raw Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active prior to masking 1 = ssi_txu_intr
                                                     interrupt is active prior to masking                                      */
        __IM  uint32_t ssrir    : 1;            /*!< [7..7] SS_N Rising Edge Detect Raw Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active prior to masking 1 = ssi_ssr_intr
                                                     interrupt is active prior to masking                                      */
      } risr_slv_b;
    } ;
  };
  
  union {
    __IM  uint32_t txoicr;                      /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t txoicr     : 1;            /*!< [0..0] Clear Transmit FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txo_intr interrupt; writing has
                                                     no effect.                                                                */
    } txoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxoicr;                      /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
    
    struct {
      __IM  uint32_t rxoicr     : 1;            /*!< [0..0] Clear Receive FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxo_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxuicr;                      /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t rxuicr     : 1;            /*!< [0..0] Clear Receive FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxu_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxuicr_b;
  } ;
  
  union {
    union {
      __IM  uint32_t msticr;                    /*!< (@ 0x00000044) Multi-Master Interrupt Clear Register                      */
      
      struct {
        __IM  uint32_t msticr   : 1;            /*!< [0..0] Clear Multi-Master Contention Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_mst_intr interrupt; writing has
                                                     no effect. SPI3 does not have this register definition.                   */
      } msticr_b;
    } ;
    
    union {
      __IM  uint32_t faeicr;                    /*!< (@ 0x00000044) Frame Alignment Interrupt Clear Register                   */
      
      struct {
        __IM  uint32_t faeicr   : 1;            /*!< [0..0] Clear Frame Alignment Interrupt. This register reflects
                                                     the status of the interrupt. A read from this register
                                                     clears the ssi_fae_intr interrupt; writing has no effect.
                                                     Only SPI3 has this register definition.                                   */
      } faeicr_b;
    } ;
  };
  
  union {
    __IM  uint32_t icr;                         /*!< (@ 0x00000048) Interrupt Clear Register                                   */
    
    struct {
      __IM  uint32_t icr        : 1;            /*!< [0..0] Clear Interrupts. This register is set if any of the
                                                     interrupts below are active. A read clears the ssi_txu_intr,
                                                     ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_fae_intr,
                                                     ssi_ssr_intr interrupts. Writing to this register has no
                                                     effect.                                                                   */
    } icr_b;
  } ;
  
  union {
    __IOM uint32_t dmacr;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel 0 : Receive DMA disabled 1 : Receive DMA
                                                     enabled                                                                   */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. 0 : Transmit DMA disabled 1 : Transmit
                                                     DMA enabled                                                               */
    } dmacr_b;
  } ;
  
  union {
    __IOM uint32_t dmatdlr;                     /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t dmatdl     : 8;            /*!< [7..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and TDMAE = 1.                                                            */
    } dmatdlr_b;
  } ;
  
  union {
    __IOM uint32_t dmardlr;                     /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
    
    struct {
      __IM  uint32_t            : 7;
      __IOM uint32_t dmardl     : 1;            /*!< [7..7] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or above this field value + 1, and RDMAE=1.                   */
    } dmardlr_b;
  } ;
  
  union {
    __IM  uint32_t txuicr;                      /*!< (@ 0x00000058) Transmit FIFO Underflow Interrupt Clear Register           */
    
    struct {
      __IM  uint32_t txuicr     : 1;            /*!< [0..0] Clear Transmit FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txu_intr interrupt; writing has
                                                     no effect.                                                                */
    } txuicr_b;
  } ;
  
  union {
    __IM  uint32_t ssricr;                      /*!< (@ 0x0000005C) SS_N Rising Edge Detect Interrupt Clear Register           */
    
    struct {
      __IM  uint32_t ssiicr     : 1;            /*!< [0..0] Clear SS_N Rinsing Edge Detect Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_ssr_intr interrupt; writing has
                                                     no effect.                                                                */
    } ssricr_b;
  } ;
  
  union {
    __IOM uint16_t dr;                          /*!< (@ 0x00000060) Data Register                                              */
    
    struct {
      __IOM uint16_t dr         : 16;           /*!< [15..0] Data register is a 16-bit read/write buffer for the
                                                     transmit/receive FIFOs. When the register is read, data
                                                     in the receive FIFO buffer is accessed. When it is written
                                                     to, data are moved into the transmit FIFO buffer; a write
                                                     can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN
                                                     = 0.When writing to this register, you must right-justify
                                                     the data. Read data are automatically right-justified.
                                                     Read : Receive FIFO buffer Write : Transmit FIFO buffer                   */
    } dr_b;
  } ;
  __IM  uint16_t  RESERVED;
  __IM  uint32_t  RESERVED1[35];
  
  union {
    __IOM uint32_t rx_sample_dly;               /*!< (@ 0x000000F0) Rx Sample Delay Register                                   */
    
    struct {
      __IOM uint32_t rsd        : 8;            /*!< [7..0] Receive Data Sample Delay. This register is used to delay
                                                     the sample of the rxd input signal. Each value represents
                                                     a single ssi_clk delay on the sample of the rxd signal.
                                                     If this register is programmed with a value that exceed
                                                     the depth of the internal shift register, a zero delay
                                                     will be applied to the rxd sample.                                        */
    } rx_sample_dly_b;
  } ;
} SSI0_Type;                                    /*!< Size = 244 (0xf4)                                                         */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C with 7-bit/10-bit SS/FS/HS mode in master and slave mode transmission (I2C0)
  */

typedef struct {                                /*!< (@ 0x40044000) I2C0 Structure                                             */
  
  union {
    __IOM uint32_t con;                         /*!< (@ 0x00000000) I2C Control Register                                       */
    
    struct {
      __IOM uint32_t mst_mod    : 1;            /*!< [0..0] This bit controls whether the I2C Module master is enabled.        */
      __IOM uint32_t spd        : 2;            /*!< [2..1] These bits control at which speed the I2C Module operates.         */
      __IOM uint32_t slv_10bit_addr : 1;        /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     I2C Module responds to 7- or 10-bit addresses.                            */
      __IOM uint32_t mst_10bit_addr : 1;        /*!< [4..4] This bit controls whether the I2C Module starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.                  */
      __IOM uint32_t rstrt_en   : 1;            /*!< [5..5] This bit determines whether RESTART conditions may be
                                                     sent when acting as a master.                                             */
      __IOM uint32_t slv_dis    : 1;            /*!< [6..6] This bit controls whether I2C has its slave 0 disabled.            */
      __IOM uint32_t slv_dis_1  : 1;            /*!< [7..7] This bit controls whether I2C has its slave 1 disabled.            */
    } con_b;
  } ;
  
  union {
    __IOM uint32_t tar;                         /*!< (@ 0x00000004) I2C Target Address Register                                */
    
    struct {
      __IOM uint32_t tar        : 10;           /*!< [9..0] This is the target address for any master transaction.             */
      __IOM uint32_t gc_start_byte : 1;         /*!< [10..10] If bit 11 (SPECIAL) is set to 1, then this bit indicates
                                                     whether a General Call or START byte command is to be performed
                                                     by the I2C Module. 0: General Call 1: START BYTE                          */
      __IOM uint32_t spec       : 1;            /*!< [11..11] This bit indicates whether software performs a General
                                                     Call or START BYTE command.                                               */
      __IOM uint32_t tar_10bit_addr : 1;        /*!< [12..12] This bit controls whether the I2C Module starts its
                                                     transfers in 7-or 10-bit addressing mode when acting as
                                                     a master.                                                                 */
    } tar_b;
  } ;
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t sar        : 10;           /*!< [9..0] The sar holds the slave address when the I2C is operating
                                                     as a slave.                                                               */
    } sar_b;
  } ;
  
  union {
    __IOM uint32_t hs_maddr;                    /*!< (@ 0x0000000C) I2C High Speed Master Code Address Register                */
    
    struct {
      __IOM uint32_t hs_maddr   : 3;            /*!< [2..0] This bit field holds the value of the I2C HS mode master
                                                     code                                                                      */
    } hs_maddr_b;
  } ;
  
  union {
    __IOM uint32_t dat_cmd;                     /*!< (@ 0x00000010) I2C Data Buffer and Command Register                       */
    
    struct {
      __IOM uint32_t dat        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus.                                                  */
      __OM  uint32_t cmd        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.          */
      __OM  uint32_t stp        : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __OM  uint32_t rstrt      : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.                                             */
      __OM  uint32_t null_dat   : 1;            /*!< [11..11] This bit controls whether to transfer slave address
                                                     only.                                                                     */
    } dat_cmd_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_hcnt;                 /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     standard speed.                                                           */
    } ss_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_lcnt;                 /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     standard speed.                                                           */
    } ss_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_hcnt;                 /*!< (@ 0x0000001C) Fast Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     fast speed.                                                               */
    } fs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_lcnt;                 /*!< (@ 0x00000020) Fast Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     fast speed.                                                               */
    } fs_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_hcnt;                 /*!< (@ 0x00000024) High Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high period count for
                                                     high speed.                                                               */
    } hs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_lcnt;                 /*!< (@ 0x00000028) High Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     high speed.                                                               */
    } hs_scl_lcnt_b;
  } ;
  
  union {
    __IM  uint32_t intr_stat;                   /*!< (@ 0x0000002C) I2C Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t intr_msk;                    /*!< (@ 0x00000030) I2C Interrupt Mask Register                                */
    
    struct {
      __IOM uint32_t rx_under   : 1;            /*!< [0..0] Correspond to intr_sts                                             */
      __IOM uint32_t rx_over    : 1;            /*!< [1..1] Correspond to intr_sts                                             */
      __IOM uint32_t rx_full    : 1;            /*!< [2..2] Correspond to intr_sts                                             */
      __IOM uint32_t tx_over    : 1;            /*!< [3..3] Correspond to intr_sts                                             */
      __IOM uint32_t tx_empty   : 1;            /*!< [4..4] Correspond to intr_sts                                             */
      __IOM uint32_t rd_req     : 1;            /*!< [5..5] Correspond to intr_sts                                             */
      __IOM uint32_t tx_abrt    : 1;            /*!< [6..6] Correspond to intr_sts                                             */
      __IOM uint32_t rx_done    : 1;            /*!< [7..7] Correspond to intr_sts                                             */
      __IOM uint32_t act        : 1;            /*!< [8..8] Correspond to intr_sts                                             */
      __IOM uint32_t stp_det    : 1;            /*!< [9..9] Correspond to intr_sts                                             */
      __IOM uint32_t strt_det   : 1;            /*!< [10..10] Correspond to intr_sts                                           */
      __IOM uint32_t gen_call   : 1;            /*!< [11..11] Correspond to intr_sts                                           */
      __IOM uint32_t addr0_match : 1;           /*!< [12..12] Correspond to intr_sts                                           */
      __IOM uint32_t addr1_match : 1;           /*!< [13..13] Correspond to intr_sts                                           */
      __IOM uint32_t ms_code_det : 1;           /*!< [14..14] Correspond to intr_sts                                           */
      __IOM uint32_t dma_i2c_done : 1;          /*!< [15..15] Correspond to intr_sts                                           */
    } intr_msk_b;
  } ;
  
  union {
    __IM  uint32_t raw_intr_stat;               /*!< (@ 0x00000034) I2C Raw Interrupt Status Register                          */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } raw_intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t rx_tl;                       /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t rx_tl      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
    } rx_tl_b;
  } ;
  
  union {
    __IOM uint32_t tx_tl;                       /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t tx_tl      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
    } tx_tl_b;
  } ;
  
  union {
    __IOM uint32_t clr_intr;                    /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t clr_intr   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the TX_ABRT_SOURCE register.                   */
    } clr_intr_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_under;                /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_rx_under : 1;          /*!< [0..0] Read this register to clear the rx_under interrupt (bit
                                                     0) of the raw_intr_stat register                                          */
    } clr_rx_under_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_over;                 /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_over : 1;           /*!< [0..0] Read this register to clear the rx_over interrupt (bit
                                                     1) of the raw_intr_stat register                                          */
    } clr_rx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_over;                 /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_over : 1;           /*!< [0..0] Read this register to clear the tx_over interrupt (bit
                                                     3) of the raw_intr_stat register.                                         */
    } clr_tx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_rd_req;                  /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t clr_rd_req : 1;            /*!< [0..0] Read this register to clear the rd_req interrupt (bit
                                                     5) of the raw_intr_stat register                                          */
    } clr_rd_req_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_abrt;                 /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_abrt : 1;           /*!< [0..0] Read this register to clear the tx_abrt interrupt (bit
                                                     6) of the raw_intr_stat register, and the tx_abrt_src register.This
                                                     also releases the tx fifo from the flushed/reset state,
                                                     allowing more writes to the TX FIFO. Refer to Bit 9 of
                                                     the tx_abrt_src register for an exception to clearing tx_abrt_src.        */
    } clr_tx_abrt_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_done;                 /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_done : 1;           /*!< [0..0] Read this register to clear the rx_done interrupt (bit
                                                     7) of the raw_intr_stat register                                          */
    } clr_rx_done_b;
  } ;
  
  union {
    __IOM uint32_t clr_act;                     /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_act    : 1;            /*!< [0..0] Reading this register clears the activity interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the activity interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the activity interrupt (bit 8) of the raw_intr_stat
                                                     register.                                                                 */
    } clr_act_b;
  } ;
  
  union {
    __IOM uint32_t clr_stp_det;                 /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_stp_det : 1;           /*!< [0..0] Read this register to clear the stop_det interrupt (bit
                                                     9) of the raw_intr_stat register.                                         */
    } clr_stp_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_strt_det;                /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t clr_strt_det : 1;          /*!< [0..0] Read this register to clear the start_det interrupt (bit
                                                     10) of the raw_intr_stat register.                                        */
    } clr_strt_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_gen_call;                /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_gen_call : 1;          /*!< [0..0] Read this register to clear the gen_call interrupt (bit
                                                     11) of raw_intr_stat register                                             */
    } clr_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Controls whether the I2C Module is enabled.                        */
      __IOM uint32_t abrt       : 1;            /*!< [1..1] Abort I2C current transfer is done w/o flush Tx/Rx FIFO            */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t sts;                         /*!< (@ 0x00000070) I2C Status Reigster                                        */
    
    struct {
      __IM  uint32_t act        : 1;            /*!< [0..0] I2C Activity Status.                                               */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full.                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or morevalid entries, this bit is cleared. This bit
                                                     field does not request an interrupt.                                      */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty.                                                    */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO CompletelyFull. When the receive FIFO iscompletely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared.                              */
      __IM  uint32_t mst_act    : 1;            /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t slv_act    : 1;            /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t mst_hold_tx_empty : 1;     /*!< [7..7] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in master mode.                                          */
      __IM  uint32_t mst_hold_rx_full : 1;      /*!< [8..8] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in master mode.                                           */
      __IM  uint32_t slv_hold_tx_empty : 1;     /*!< [9..9] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in slave mode.                                           */
      __IM  uint32_t slv_hold_rx_full : 1;      /*!< [10..10] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in slave mode.                                            */
      __IOM uint32_t bus_sts    : 2;            /*!< [12..11] Show current I2C bus status                                      */
    } sts_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000074) I2C Transmit FIFO Level Register                           */
    
    struct {
      __IM  uint32_t txflr      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000078) I2C Receive FIFO Level Register                            */
    
    struct {
      __IM  uint32_t rxflr      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IOM uint32_t sda_hold;                    /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register                          */
    
    struct {
      __IOM uint32_t sda_hold   : 16;           /*!< [15..0] Sets the required SDA hold timein units of clk period.            */
    } sda_hold_b;
  } ;
  
  union {
    __IOM uint32_t tx_abrt_src;                 /*!< (@ 0x00000080) I2C Transmit Abort Source Register                         */
    
    struct {
      __IM  uint32_t addr_7bit_nack : 1;        /*!< [0..0] 1: Master is in 7-bit addressing mode and the address
                                                     sent was not acknowledged by any slave.                                   */
      __IM  uint32_t addr1_10bit_nack : 1;      /*!< [1..1] 1: Master is in 10-bit address mode and the first 10-bit
                                                     address byte was not acknowledged by any slave.                           */
      __IM  uint32_t addr2_10bit_nack : 1;      /*!< [2..2] 1: Master is in 10-bit address mode and the second address
                                                     byte of the 10-bit address was not acknowledged by any
                                                     slave.                                                                    */
      __IM  uint32_t txdat_nack : 1;            /*!< [3..3] 1: This is a master-mode only bit. Master has received
                                                     an acknowledgement for the address, but when it sent data
                                                     byte(s) following the address, it did not receive an acknowledge
                                                     from the remote slave(s).                                                 */
      __IM  uint32_t gcall_nack : 1;            /*!< [4..4] 1: I2C Module in master mode sent a General Call and
                                                     no slave on the bus acknowledged the General Call.                        */
      __IM  uint32_t gcall_rd   : 1;            /*!< [5..5] 1: I2C Module in master mode sent a General Call but
                                                     the user programmed the byte following the General Call
                                                     to be a read from the bus (dat_cmd[9] is set to 1).                       */
      __IM  uint32_t hs_ackdet  : 1;            /*!< [6..6] 1: Master is in High Speed mode and the High Speed Master
                                                     code was acknowledged (wrong behavior).                                   */
      __IM  uint32_t sbyte_ackdet : 1;          /*!< [7..7] 1: Master has sent a START Byte and the START Byte was
                                                     acknowledged (wrong behavior).                                            */
      __IM  uint32_t norstrt_hs : 1;            /*!< [8..8] 1: The restart is disabled (rstrt_en bit (con[5]) = 0)
                                                     and the user is trying to use the master to transfer data
                                                     in High Speed mode.                                                       */
      __IM  uint32_t norstrt_sbyte : 1;         /*!< [9..9] 1: The restart is disabled (rstrt bit con[5]) = 0) and
                                                     the user is trying to send a START Byte.                                  */
      __IM  uint32_t norstrt_10bit_rd : 1;      /*!< [10..10] 1: The restart is disabled (rstrt_en bit (con[5]) =
                                                     0) and the master sends a read command in 10-bit addressing
                                                     mode.                                                                     */
      __IM  uint32_t mst_dis    : 1;            /*!< [11..11] 1: User tries to initiate a Master operation with the
                                                     Master mode disabled.                                                     */
      __IM  uint32_t arb_lost   : 1;            /*!< [12..12] 1: Master has lost arbitration, or if tx_abrt_src[14]
                                                     is also set, then the slave transmitter has lost arbitration.             */
      __IM  uint32_t slvflush_txfifo : 1;       /*!< [13..13] 1: Slave has received a read command and some data
                                                     exists in the TX FIFO so the slave issues a tx_abrt interrupt
                                                     to flush old data in TX FIFO.                                             */
      __IM  uint32_t slv_arblost : 1;           /*!< [14..14] 1: Slave lost the bus while transmitting data to a
                                                     remote master. Tx_abrt_src[12] is set at the same time.                   */
      __IM  uint32_t slvrd_intx : 1;            /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in cmd(bit 8) of dat_cmd register.                        */
    } tx_abrt_src_b;
  } ;
  
  union {
    __IOM uint32_t slv_dat_nack;                /*!< (@ 0x00000084) I2C Generate Slave Data NACK Register                      */
    
    struct {
      __IOM uint32_t slv_dat_nack : 1;          /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     I2C Module is a slavereceiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria.                                   */
    } slv_dat_nack_b;
  } ;
  
  union {
    __IOM uint32_t dma_cr;                      /*!< (@ 0x00000088) I2C DMA Control Reigster                                   */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel.                                                         */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel.                                                         */
    } dma_cr_b;
  } ;
  
  union {
    __IOM uint32_t dma_tdlr;                    /*!< (@ 0x0000008C) I2C DMA Transmit Data Level Register                       */
    
    struct {
      __IOM uint32_t tdlr       : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tdmae= 1.                                                             */
    } dma_tdlr_b;
  } ;
  
  union {
    __IOM uint32_t dma_rdlr;                    /*!< (@ 0x00000090) I2C DMA Receive Data Level Register                        */
    
    struct {
      __IOM uint32_t rdlr       : 4;            /*!< [3..0] Receive Data Level.                                                */
    } dma_rdlr_b;
  } ;
  
  union {
    __IOM uint32_t sda_setup;                   /*!< (@ 0x00000094) I2C SDA Setup Register                                     */
    
    struct {
      __IOM uint32_t sda_setup  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an clk frequency of 10 MHz, sda_setup
                                                     should be programmed to a value of 11. sda_setup must be
                                                     programmed with a minimum value of 2.                                     */
    } sda_setup_b;
  } ;
  
  union {
    __IOM uint32_t ack_gen_call;                /*!< (@ 0x00000098) I2C ACK General Call Register                              */
    
    struct {
      __IOM uint32_t ack_gen_call : 1;          /*!< [0..0] ACK General Call. When set to 1, I2C Module responds
                                                     with a ACK (by asserting data_oe) when it receives a General
                                                     Call. When set to 0, the I2C Module does not generate General
                                                     Call interrupts.                                                          */
    } ack_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t en_sts;                      /*!< (@ 0x0000009C) I2C Enable Status Register                                 */
    
    struct {
      __IM  uint32_t en         : 1;            /*!< [0..0] Enable Status.                                                     */
      __IM  uint32_t slv_dis_in_busy : 1;       /*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting of the ENABLE register
                                                     from 1 to 0.                                                              */
      __IM  uint32_t slv_rx_dat_lost : 1;       /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting of enable
                                                     from 1 to 0.                                                              */
      __IM  uint32_t dma_dis_sts : 2;           /*!< [4..3] DMA_DISABLE_WHILE_BUSY. 00: No ill disable event is active
                                                     01: I2C is disable while busy in legacy mode 10: I2C is
                                                     disable while busy in DMA mode 11: I2C is disable while
                                                     busy in Descriptor mode                                                   */
    } en_sts_b;
  } ;
  
  union {
    __IOM uint32_t dma_cmd;                     /*!< (@ 0x000000A0) I2C DMA Command Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Set to enable DMA mode.                                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t cmd        : 1;            /*!< [5..5] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the I2C Module
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. 1 = Read 0 = Write                                      */
      __IOM uint32_t stp        : 1;            /*!< [6..6] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __IOM uint32_t rstrt      : 1;            /*!< [7..7] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received when DMA mode is enabled.                    */
    } dma_cmd_b;
  } ;
  
  union {
    __IOM uint32_t dma_len;                     /*!< (@ 0x000000A4) I2C DMA Transfer Data Length Register                      */
    
    struct {
      __IOM uint32_t len        : 16;           /*!< [15..0] DMA transfer data length(R/W)                                     */
      __IM  uint32_t tr_len     : 16;           /*!< [31..16] DMA mode transfer bytes(Read only)                               */
    } dma_len_b;
  } ;
  
  union {
    __IOM uint32_t dma_mod;                     /*!< (@ 0x000000A8) I2C DMA Mode Register                                      */
    
    struct {
      __IOM uint32_t dma_mod    : 2;            /*!< [1..0] DMA operation mode                                                 */
    } dma_mod_b;
  } ;
  
  union {
    __IOM uint32_t slp;                         /*!< (@ 0x000000AC) I2C Sleep Control Register                                 */
    
    struct {
      __IOM uint32_t clk_ctrl   : 1;            /*!< [0..0] I2C clock control, write 1 controller would gate I2C
                                                     clock until I2C slave is enable and reset synchronized
                                                     register procedure is done                                                */
      __IM  uint32_t slp_clk_gated : 1;         /*!< [1..1] I2C clock has been gated (Read Only)                               */
    } slp_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t dat_fltr_rsts_l;             /*!< (@ 0x000000B8) Data Filter Resistor Low Register                          */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_l : 20;      /*!< [19..0] Data Filter Resistor Low                                          */
    } dat_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_rsts_m;             /*!< (@ 0x000000BC) Data Filter Resistor Main Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_m : 20;      /*!< [19..0] Data Filter Resistor Main                                         */
    } dat_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_l;             /*!< (@ 0x000000C0) Clock Filter Resistor Low Register                         */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_l : 20;      /*!< [19..0] Clock Filter Resistor Low                                         */
    } clk_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_m;             /*!< (@ 0x000000C4) Clock Filter Resistor Main Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_m : 20;      /*!< [19..0] Clock Filter Resistor Main                                        */
    } clk_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_l;              /*!< (@ 0x000000C8) Data Filter Capacitor Low Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_cap_l : 20;       /*!< [19..0] Data Filter Capacitor Low                                         */
    } dat_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_m;              /*!< (@ 0x000000CC) Data Filter Capacitor Main Register                        */
    
    struct {
      __IOM uint32_t dat_fltr_cap_m : 5;        /*!< [4..0] Data Filter Capacitor Main                                         */
    } dat_fltr_cap_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_l;              /*!< (@ 0x000000D0) Clock Filter Capacitor Low Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_cap_l : 20;       /*!< [19..0] Clock Filter Capacitor Low                                        */
    } clk_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_m;              /*!< (@ 0x000000D4) Clock Filter Capacitor Main Register                       */
    
    struct {
      __IOM uint32_t clk_fltr_cap_m : 5;        /*!< [4..0] Clock Filter Capacitor Main                                        */
    } clk_fltr_cap_m_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t clr_addr_match;              /*!< (@ 0x000000E4) Clear I2C ADDR_MATCH Interrupt Register                    */
    
    struct {
      __IOM uint32_t clr_addr_match : 1;        /*!< [0..0] Clear address match interrupts raw status, and it's read
                                                     clear.                                                                    */
    } clr_addr_match_b;
  } ;
  
  union {
    __IOM uint32_t clr_dma_done;                /*!< (@ 0x000000E8) Clear I2C DMA_DONE Interrupt Register                      */
    
    struct {
      __IOM uint32_t clr_dma_done : 1;          /*!< [0..0] Clear dma_i2c_done_intr interrupts raw status, and it's
                                                     read clear.                                                               */
    } clr_dma_done_b;
  } ;
  
  union {
    __IOM uint32_t fltr;                        /*!< (@ 0x000000EC) I2C Bus Filter Register                                    */
    
    struct {
      __IOM uint32_t dig_fltr_deg : 4;          /*!< [3..0] I2C module digital filter degree                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t dig_fltr_en : 1;           /*!< [8..8] I2C module digital filter slection (enable)                        */
    } fltr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t sar1;                        /*!< (@ 0x000000F4) I2C Slave Address 1 Register                               */
    
    struct {
      __IOM uint32_t sar1       : 7;            /*!< [6..0] I2C Second Slave Address                                           */
    } sar1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t ver;                         /*!< (@ 0x000000FC) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t ver        : 32;           /*!< [31..0] I2C module version number                                         */
    } ver_b;
  } ;
} I2C0_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2C2                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C with 7-bit/10-bit SS/FS/HS mode in master and slave mode transmission (I2C2)
  */

typedef struct {                                /*!< (@ 0x40003400) I2C2 Structure                                             */
  
  union {
    __IOM uint32_t con;                         /*!< (@ 0x00000000) I2C Control Register                                       */
    
    struct {
      __IOM uint32_t mst_mod    : 1;            /*!< [0..0] This bit controls whether the I2C Module master is enabled.        */
      __IOM uint32_t spd        : 2;            /*!< [2..1] These bits control at which speed the I2C Module operates.         */
      __IOM uint32_t slv_10bit_addr : 1;        /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     I2C Module responds to 7- or 10-bit addresses.                            */
      __IOM uint32_t mst_10bit_addr : 1;        /*!< [4..4] This bit controls whether the I2C Module starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.                  */
      __IOM uint32_t rstrt_en   : 1;            /*!< [5..5] This bit determines whether RESTART conditions may be
                                                     sent when acting as a master.                                             */
      __IOM uint32_t slv_dis    : 1;            /*!< [6..6] This bit controls whether I2C has its slave 0 disabled.            */
      __IOM uint32_t slv_dis_1  : 1;            /*!< [7..7] This bit controls whether I2C has its slave 1 disabled.            */
    } con_b;
  } ;
  
  union {
    __IOM uint32_t tar;                         /*!< (@ 0x00000004) I2C Target Address Register                                */
    
    struct {
      __IOM uint32_t tar        : 10;           /*!< [9..0] This is the target address for any master transaction.             */
      __IOM uint32_t gc_start_byte : 1;         /*!< [10..10] If bit 11 (SPECIAL) is set to 1, then this bit indicates
                                                     whether a General Call or START byte command is to be performed
                                                     by the I2C Module. 0: General Call 1: START BYTE                          */
      __IOM uint32_t spec       : 1;            /*!< [11..11] This bit indicates whether software performs a General
                                                     Call or START BYTE command.                                               */
      __IOM uint32_t tar_10bit_addr : 1;        /*!< [12..12] This bit controls whether the I2C Module starts its
                                                     transfers in 7-or 10-bit addressing mode when acting as
                                                     a master.                                                                 */
    } tar_b;
  } ;
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t sar        : 10;           /*!< [9..0] The sar holds the slave address when the I2C is operating
                                                     as a slave.                                                               */
    } sar_b;
  } ;
  
  union {
    __IOM uint32_t hs_maddr;                    /*!< (@ 0x0000000C) I2C High Speed Master Code Address Register                */
    
    struct {
      __IOM uint32_t hs_maddr   : 3;            /*!< [2..0] This bit field holds the value of the I2C HS mode master
                                                     code                                                                      */
    } hs_maddr_b;
  } ;
  
  union {
    __IOM uint32_t dat_cmd;                     /*!< (@ 0x00000010) I2C Data Buffer and Command Register                       */
    
    struct {
      __IOM uint32_t dat        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus.                                                  */
      __OM  uint32_t cmd        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.          */
      __OM  uint32_t stp        : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __OM  uint32_t rstrt      : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.                                             */
      __OM  uint32_t null_dat   : 1;            /*!< [11..11] This bit controls whether to transfer slave address
                                                     only.                                                                     */
    } dat_cmd_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_hcnt;                 /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     standard speed.                                                           */
    } ss_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_lcnt;                 /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     standard speed.                                                           */
    } ss_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_hcnt;                 /*!< (@ 0x0000001C) Fast Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     fast speed.                                                               */
    } fs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_lcnt;                 /*!< (@ 0x00000020) Fast Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     fast speed.                                                               */
    } fs_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_hcnt;                 /*!< (@ 0x00000024) High Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high period count for
                                                     high speed.                                                               */
    } hs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_lcnt;                 /*!< (@ 0x00000028) High Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     high speed.                                                               */
    } hs_scl_lcnt_b;
  } ;
  
  union {
    __IM  uint32_t intr_stat;                   /*!< (@ 0x0000002C) I2C Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t intr_msk;                    /*!< (@ 0x00000030) I2C Interrupt Mask Register                                */
    
    struct {
      __IOM uint32_t rx_under   : 1;            /*!< [0..0] Correspond to intr_sts                                             */
      __IOM uint32_t rx_over    : 1;            /*!< [1..1] Correspond to intr_sts                                             */
      __IOM uint32_t rx_full    : 1;            /*!< [2..2] Correspond to intr_sts                                             */
      __IOM uint32_t tx_over    : 1;            /*!< [3..3] Correspond to intr_sts                                             */
      __IOM uint32_t tx_empty   : 1;            /*!< [4..4] Correspond to intr_sts                                             */
      __IOM uint32_t rd_req     : 1;            /*!< [5..5] Correspond to intr_sts                                             */
      __IOM uint32_t tx_abrt    : 1;            /*!< [6..6] Correspond to intr_sts                                             */
      __IOM uint32_t rx_done    : 1;            /*!< [7..7] Correspond to intr_sts                                             */
      __IOM uint32_t act        : 1;            /*!< [8..8] Correspond to intr_sts                                             */
      __IOM uint32_t stp_det    : 1;            /*!< [9..9] Correspond to intr_sts                                             */
      __IOM uint32_t strt_det   : 1;            /*!< [10..10] Correspond to intr_sts                                           */
      __IOM uint32_t gen_call   : 1;            /*!< [11..11] Correspond to intr_sts                                           */
      __IOM uint32_t addr0_match : 1;           /*!< [12..12] Correspond to intr_sts                                           */
      __IOM uint32_t addr1_match : 1;           /*!< [13..13] Correspond to intr_sts                                           */
      __IOM uint32_t ms_code_det : 1;           /*!< [14..14] Correspond to intr_sts                                           */
      __IOM uint32_t dma_i2c_done : 1;          /*!< [15..15] Correspond to intr_sts                                           */
    } intr_msk_b;
  } ;
  
  union {
    __IM  uint32_t raw_intr_stat;               /*!< (@ 0x00000034) I2C Raw Interrupt Status Register                          */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } raw_intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t rx_tl;                       /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t rx_tl      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
    } rx_tl_b;
  } ;
  
  union {
    __IOM uint32_t tx_tl;                       /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t tx_tl      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
    } tx_tl_b;
  } ;
  
  union {
    __IOM uint32_t clr_intr;                    /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t clr_intr   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the TX_ABRT_SOURCE register.                   */
    } clr_intr_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_under;                /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_rx_under : 1;          /*!< [0..0] Read this register to clear the rx_under interrupt (bit
                                                     0) of the raw_intr_stat register                                          */
    } clr_rx_under_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_over;                 /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_over : 1;           /*!< [0..0] Read this register to clear the rx_over interrupt (bit
                                                     1) of the raw_intr_stat register                                          */
    } clr_rx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_over;                 /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_over : 1;           /*!< [0..0] Read this register to clear the tx_over interrupt (bit
                                                     3) of the raw_intr_stat register.                                         */
    } clr_tx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_rd_req;                  /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t clr_rd_req : 1;            /*!< [0..0] Read this register to clear the rd_req interrupt (bit
                                                     5) of the raw_intr_stat register                                          */
    } clr_rd_req_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_abrt;                 /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_abrt : 1;           /*!< [0..0] Read this register to clear the tx_abrt interrupt (bit
                                                     6) of the raw_intr_stat register, and the tx_abrt_src register.This
                                                     also releases the tx fifo from the flushed/reset state,
                                                     allowing more writes to the TX FIFO. Refer to Bit 9 of
                                                     the tx_abrt_src register for an exception to clearing tx_abrt_src.        */
    } clr_tx_abrt_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_done;                 /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_done : 1;           /*!< [0..0] Read this register to clear the rx_done interrupt (bit
                                                     7) of the raw_intr_stat register                                          */
    } clr_rx_done_b;
  } ;
  
  union {
    __IOM uint32_t clr_act;                     /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_act    : 1;            /*!< [0..0] Reading this register clears the activity interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the activity interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the activity interrupt (bit 8) of the raw_intr_stat
                                                     register.                                                                 */
    } clr_act_b;
  } ;
  
  union {
    __IOM uint32_t clr_stp_det;                 /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_stp_det : 1;           /*!< [0..0] Read this register to clear the stop_det interrupt (bit
                                                     9) of the raw_intr_stat register.                                         */
    } clr_stp_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_strt_det;                /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t clr_strt_det : 1;          /*!< [0..0] Read this register to clear the start_det interrupt (bit
                                                     10) of the raw_intr_stat register.                                        */
    } clr_strt_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_gen_call;                /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_gen_call : 1;          /*!< [0..0] Read this register to clear the gen_call interrupt (bit
                                                     11) of raw_intr_stat register                                             */
    } clr_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Controls whether the I2C Module is enabled.                        */
      __IOM uint32_t abrt       : 1;            /*!< [1..1] Abort I2C current transfer is done w/o flush Tx/Rx FIFO            */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t sts;                         /*!< (@ 0x00000070) I2C Status Reigster                                        */
    
    struct {
      __IM  uint32_t act        : 1;            /*!< [0..0] I2C Activity Status.                                               */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full.                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or morevalid entries, this bit is cleared. This bit
                                                     field does not request an interrupt.                                      */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty.                                                    */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO CompletelyFull. When the receive FIFO iscompletely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared.                              */
      __IM  uint32_t mst_act    : 1;            /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t slv_act    : 1;            /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t mst_hold_tx_empty : 1;     /*!< [7..7] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in master mode.                                          */
      __IM  uint32_t mst_hold_rx_full : 1;      /*!< [8..8] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in master mode.                                           */
      __IM  uint32_t slv_hold_tx_empty : 1;     /*!< [9..9] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in slave mode.                                           */
      __IM  uint32_t slv_hold_rx_full : 1;      /*!< [10..10] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in slave mode.                                            */
      __IOM uint32_t bus_sts    : 2;            /*!< [12..11] Show current I2C bus status                                      */
    } sts_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000074) I2C Transmit FIFO Level Register                           */
    
    struct {
      __IM  uint32_t txflr      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000078) I2C Receive FIFO Level Register                            */
    
    struct {
      __IM  uint32_t rxflr      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IOM uint32_t sda_hold;                    /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register                          */
    
    struct {
      __IOM uint32_t sda_hold   : 16;           /*!< [15..0] Sets the required SDA hold timein units of clk period.            */
    } sda_hold_b;
  } ;
  
  union {
    __IOM uint32_t tx_abrt_src;                 /*!< (@ 0x00000080) I2C Transmit Abort Source Register                         */
    
    struct {
      __IM  uint32_t addr_7bit_nack : 1;        /*!< [0..0] 1: Master is in 7-bit addressing mode and the address
                                                     sent was not acknowledged by any slave.                                   */
      __IM  uint32_t addr1_10bit_nack : 1;      /*!< [1..1] 1: Master is in 10-bit address mode and the first 10-bit
                                                     address byte was not acknowledged by any slave.                           */
      __IM  uint32_t addr2_10bit_nack : 1;      /*!< [2..2] 1: Master is in 10-bit address mode and the second address
                                                     byte of the 10-bit address was not acknowledged by any
                                                     slave.                                                                    */
      __IM  uint32_t txdat_nack : 1;            /*!< [3..3] 1: This is a master-mode only bit. Master has received
                                                     an acknowledgement for the address, but when it sent data
                                                     byte(s) following the address, it did not receive an acknowledge
                                                     from the remote slave(s).                                                 */
      __IM  uint32_t gcall_nack : 1;            /*!< [4..4] 1: I2C Module in master mode sent a General Call and
                                                     no slave on the bus acknowledged the General Call.                        */
      __IM  uint32_t gcall_rd   : 1;            /*!< [5..5] 1: I2C Module in master mode sent a General Call but
                                                     the user programmed the byte following the General Call
                                                     to be a read from the bus (dat_cmd[9] is set to 1).                       */
      __IM  uint32_t hs_ackdet  : 1;            /*!< [6..6] 1: Master is in High Speed mode and the High Speed Master
                                                     code was acknowledged (wrong behavior).                                   */
      __IM  uint32_t sbyte_ackdet : 1;          /*!< [7..7] 1: Master has sent a START Byte and the START Byte was
                                                     acknowledged (wrong behavior).                                            */
      __IM  uint32_t norstrt_hs : 1;            /*!< [8..8] 1: The restart is disabled (rstrt_en bit (con[5]) = 0)
                                                     and the user is trying to use the master to transfer data
                                                     in High Speed mode.                                                       */
      __IM  uint32_t norstrt_sbyte : 1;         /*!< [9..9] 1: The restart is disabled (rstrt bit con[5]) = 0) and
                                                     the user is trying to send a START Byte.                                  */
      __IM  uint32_t norstrt_10bit_rd : 1;      /*!< [10..10] 1: The restart is disabled (rstrt_en bit (con[5]) =
                                                     0) and the master sends a read command in 10-bit addressing
                                                     mode.                                                                     */
      __IM  uint32_t mst_dis    : 1;            /*!< [11..11] 1: User tries to initiate a Master operation with the
                                                     Master mode disabled.                                                     */
      __IM  uint32_t arb_lost   : 1;            /*!< [12..12] 1: Master has lost arbitration, or if tx_abrt_src[14]
                                                     is also set, then the slave transmitter has lost arbitration.             */
      __IM  uint32_t slvflush_txfifo : 1;       /*!< [13..13] 1: Slave has received a read command and some data
                                                     exists in the TX FIFO so the slave issues a tx_abrt interrupt
                                                     to flush old data in TX FIFO.                                             */
      __IM  uint32_t slv_arblost : 1;           /*!< [14..14] 1: Slave lost the bus while transmitting data to a
                                                     remote master. Tx_abrt_src[12] is set at the same time.                   */
      __IM  uint32_t slvrd_intx : 1;            /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in cmd(bit 8) of dat_cmd register.                        */
    } tx_abrt_src_b;
  } ;
  
  union {
    __IOM uint32_t slv_dat_nack;                /*!< (@ 0x00000084) I2C Generate Slave Data NACK Register                      */
    
    struct {
      __IOM uint32_t slv_dat_nack : 1;          /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     I2C Module is a slavereceiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria.                                   */
    } slv_dat_nack_b;
  } ;
  
  union {
    __IOM uint32_t dma_cr;                      /*!< (@ 0x00000088) I2C DMA Control Reigster                                   */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel.                                                         */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel.                                                         */
    } dma_cr_b;
  } ;
  
  union {
    __IOM uint32_t dma_tdlr;                    /*!< (@ 0x0000008C) I2C DMA Transmit Data Level Register                       */
    
    struct {
      __IOM uint32_t tdlr       : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tdmae= 1.                                                             */
    } dma_tdlr_b;
  } ;
  
  union {
    __IOM uint32_t dma_rdlr;                    /*!< (@ 0x00000090) I2C DMA Receive Data Level Register                        */
    
    struct {
      __IOM uint32_t rdlr       : 4;            /*!< [3..0] Receive Data Level.                                                */
    } dma_rdlr_b;
  } ;
  
  union {
    __IOM uint32_t sda_setup;                   /*!< (@ 0x00000094) I2C SDA Setup Register                                     */
    
    struct {
      __IOM uint32_t sda_setup  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an clk frequency of 10 MHz, sda_setup
                                                     should be programmed to a value of 11. sda_setup must be
                                                     programmed with a minimum value of 2.                                     */
    } sda_setup_b;
  } ;
  
  union {
    __IOM uint32_t ack_gen_call;                /*!< (@ 0x00000098) I2C ACK General Call Register                              */
    
    struct {
      __IOM uint32_t ack_gen_call : 1;          /*!< [0..0] ACK General Call. When set to 1, I2C Module responds
                                                     with a ACK (by asserting data_oe) when it receives a General
                                                     Call. When set to 0, the I2C Module does not generate General
                                                     Call interrupts.                                                          */
    } ack_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t en_sts;                      /*!< (@ 0x0000009C) I2C Enable Status Register                                 */
    
    struct {
      __IM  uint32_t en         : 1;            /*!< [0..0] Enable Status.                                                     */
      __IM  uint32_t slv_dis_in_busy : 1;       /*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting of the ENABLE register
                                                     from 1 to 0.                                                              */
      __IM  uint32_t slv_rx_dat_lost : 1;       /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting of enable
                                                     from 1 to 0.                                                              */
      __IM  uint32_t dma_dis_sts : 2;           /*!< [4..3] DMA_DISABLE_WHILE_BUSY. 00: No ill disable event is active
                                                     01: I2C is disable while busy in legacy mode 10: I2C is
                                                     disable while busy in DMA mode 11: I2C is disable while
                                                     busy in Descriptor mode                                                   */
    } en_sts_b;
  } ;
  
  union {
    __IOM uint32_t dma_cmd;                     /*!< (@ 0x000000A0) I2C DMA Command Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Set to enable DMA mode.                                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t cmd        : 1;            /*!< [5..5] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the I2C Module
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. 1 = Read 0 = Write                                      */
      __IOM uint32_t stp        : 1;            /*!< [6..6] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __IOM uint32_t rstrt      : 1;            /*!< [7..7] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received when DMA mode is enabled.                    */
    } dma_cmd_b;
  } ;
  
  union {
    __IOM uint32_t dma_len;                     /*!< (@ 0x000000A4) I2C DMA Transfer Data Length Register                      */
    
    struct {
      __IOM uint32_t len        : 16;           /*!< [15..0] DMA transfer data length(R/W)                                     */
      __IM  uint32_t tr_len     : 16;           /*!< [31..16] DMA mode transfer bytes(Read only)                               */
    } dma_len_b;
  } ;
  
  union {
    __IOM uint32_t dma_mod;                     /*!< (@ 0x000000A8) I2C DMA Mode Register                                      */
    
    struct {
      __IOM uint32_t dma_mod    : 2;            /*!< [1..0] DMA operation mode                                                 */
    } dma_mod_b;
  } ;
  
  union {
    __IOM uint32_t slp;                         /*!< (@ 0x000000AC) I2C Sleep Control Register                                 */
    
    struct {
      __IOM uint32_t clk_ctrl   : 1;            /*!< [0..0] I2C clock control, write 1 controller would gate I2C
                                                     clock until I2C slave is enable and reset synchronized
                                                     register procedure is done                                                */
      __IM  uint32_t slp_clk_gated : 1;         /*!< [1..1] I2C clock has been gated (Read Only)                               */
    } slp_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t dat_fltr_rsts_l;             /*!< (@ 0x000000B8) Data Filter Resistor Low Register                          */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_l : 20;      /*!< [19..0] Data Filter Resistor Low                                          */
    } dat_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_rsts_m;             /*!< (@ 0x000000BC) Data Filter Resistor Main Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_m : 20;      /*!< [19..0] Data Filter Resistor Main                                         */
    } dat_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_l;             /*!< (@ 0x000000C0) Clock Filter Resistor Low Register                         */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_l : 20;      /*!< [19..0] Clock Filter Resistor Low                                         */
    } clk_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_m;             /*!< (@ 0x000000C4) Clock Filter Resistor Main Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_m : 20;      /*!< [19..0] Clock Filter Resistor Main                                        */
    } clk_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_l;              /*!< (@ 0x000000C8) Data Filter Capacitor Low Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_cap_l : 20;       /*!< [19..0] Data Filter Capacitor Low                                         */
    } dat_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_m;              /*!< (@ 0x000000CC) Data Filter Capacitor Main Register                        */
    
    struct {
      __IOM uint32_t dat_fltr_cap_m : 5;        /*!< [4..0] Data Filter Capacitor Main                                         */
    } dat_fltr_cap_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_l;              /*!< (@ 0x000000D0) Clock Filter Capacitor Low Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_cap_l : 20;       /*!< [19..0] Clock Filter Capacitor Low                                        */
    } clk_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_m;              /*!< (@ 0x000000D4) Clock Filter Capacitor Main Register                       */
    
    struct {
      __IOM uint32_t clk_fltr_cap_m : 5;        /*!< [4..0] Clock Filter Capacitor Main                                        */
    } clk_fltr_cap_m_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t clr_addr_match;              /*!< (@ 0x000000E4) Clear I2C ADDR_MATCH Interrupt Register                    */
    
    struct {
      __IOM uint32_t clr_addr_match : 1;        /*!< [0..0] Clear address match interrupts raw status, and it's read
                                                     clear.                                                                    */
    } clr_addr_match_b;
  } ;
  
  union {
    __IOM uint32_t clr_dma_done;                /*!< (@ 0x000000E8) Clear I2C DMA_DONE Interrupt Register                      */
    
    struct {
      __IOM uint32_t clr_dma_done : 1;          /*!< [0..0] Clear dma_i2c_done_intr interrupts raw status, and it's
                                                     read clear.                                                               */
    } clr_dma_done_b;
  } ;
  
  union {
    __IOM uint32_t fltr;                        /*!< (@ 0x000000EC) I2C Bus Filter Register                                    */
    
    struct {
      __IOM uint32_t dig_fltr_deg : 4;          /*!< [3..0] I2C module digital filter degree                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t dig_fltr_en : 1;           /*!< [8..8] I2C module digital filter slection (enable)                        */
    } fltr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t sar1;                        /*!< (@ 0x000000F4) I2C Slave Address 1 Register                               */
    
    struct {
      __IOM uint32_t sar1       : 7;            /*!< [6..0] I2C Second Slave Address                                           */
    } sar1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t ver;                         /*!< (@ 0x000000FC) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t ver        : 32;           /*!< [31..0] I2C module version number                                         */
    } ver_b;
  } ;
} I2C2_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2C3                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C with 7-bit/10-bit SS/FS/HS mode in master and slave mode transmission (I2C3)
  */

typedef struct {                                /*!< (@ 0x40003800) I2C3 Structure                                             */
  
  union {
    __IOM uint32_t con;                         /*!< (@ 0x00000000) I2C Control Register                                       */
    
    struct {
      __IOM uint32_t mst_mod    : 1;            /*!< [0..0] This bit controls whether the I2C Module master is enabled.        */
      __IOM uint32_t spd        : 2;            /*!< [2..1] These bits control at which speed the I2C Module operates.         */
      __IOM uint32_t slv_10bit_addr : 1;        /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     I2C Module responds to 7- or 10-bit addresses.                            */
      __IOM uint32_t mst_10bit_addr : 1;        /*!< [4..4] This bit controls whether the I2C Module starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.                  */
      __IOM uint32_t rstrt_en   : 1;            /*!< [5..5] This bit determines whether RESTART conditions may be
                                                     sent when acting as a master.                                             */
      __IOM uint32_t slv_dis    : 1;            /*!< [6..6] This bit controls whether I2C has its slave 0 disabled.            */
      __IOM uint32_t slv_dis_1  : 1;            /*!< [7..7] This bit controls whether I2C has its slave 1 disabled.            */
    } con_b;
  } ;
  
  union {
    __IOM uint32_t tar;                         /*!< (@ 0x00000004) I2C Target Address Register                                */
    
    struct {
      __IOM uint32_t tar        : 10;           /*!< [9..0] This is the target address for any master transaction.             */
      __IOM uint32_t gc_start_byte : 1;         /*!< [10..10] If bit 11 (SPECIAL) is set to 1, then this bit indicates
                                                     whether a General Call or START byte command is to be performed
                                                     by the I2C Module. 0: General Call 1: START BYTE                          */
      __IOM uint32_t spec       : 1;            /*!< [11..11] This bit indicates whether software performs a General
                                                     Call or START BYTE command.                                               */
      __IOM uint32_t tar_10bit_addr : 1;        /*!< [12..12] This bit controls whether the I2C Module starts its
                                                     transfers in 7-or 10-bit addressing mode when acting as
                                                     a master.                                                                 */
    } tar_b;
  } ;
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t sar        : 10;           /*!< [9..0] The sar holds the slave address when the I2C is operating
                                                     as a slave.                                                               */
    } sar_b;
  } ;
  
  union {
    __IOM uint32_t hs_maddr;                    /*!< (@ 0x0000000C) I2C High Speed Master Code Address Register                */
    
    struct {
      __IOM uint32_t hs_maddr   : 3;            /*!< [2..0] This bit field holds the value of the I2C HS mode master
                                                     code                                                                      */
    } hs_maddr_b;
  } ;
  
  union {
    __IOM uint32_t dat_cmd;                     /*!< (@ 0x00000010) I2C Data Buffer and Command Register                       */
    
    struct {
      __IOM uint32_t dat        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus.                                                  */
      __OM  uint32_t cmd        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.          */
      __OM  uint32_t stp        : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __OM  uint32_t rstrt      : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.                                             */
      __OM  uint32_t null_dat   : 1;            /*!< [11..11] This bit controls whether to transfer slave address
                                                     only.                                                                     */
    } dat_cmd_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_hcnt;                 /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     standard speed.                                                           */
    } ss_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_lcnt;                 /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     standard speed.                                                           */
    } ss_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_hcnt;                 /*!< (@ 0x0000001C) Fast Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     fast speed.                                                               */
    } fs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_lcnt;                 /*!< (@ 0x00000020) Fast Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     fast speed.                                                               */
    } fs_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_hcnt;                 /*!< (@ 0x00000024) High Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high period count for
                                                     high speed.                                                               */
    } hs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_lcnt;                 /*!< (@ 0x00000028) High Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     high speed.                                                               */
    } hs_scl_lcnt_b;
  } ;
  
  union {
    __IM  uint32_t intr_stat;                   /*!< (@ 0x0000002C) I2C Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t intr_msk;                    /*!< (@ 0x00000030) I2C Interrupt Mask Register                                */
    
    struct {
      __IOM uint32_t rx_under   : 1;            /*!< [0..0] Correspond to intr_sts                                             */
      __IOM uint32_t rx_over    : 1;            /*!< [1..1] Correspond to intr_sts                                             */
      __IOM uint32_t rx_full    : 1;            /*!< [2..2] Correspond to intr_sts                                             */
      __IOM uint32_t tx_over    : 1;            /*!< [3..3] Correspond to intr_sts                                             */
      __IOM uint32_t tx_empty   : 1;            /*!< [4..4] Correspond to intr_sts                                             */
      __IOM uint32_t rd_req     : 1;            /*!< [5..5] Correspond to intr_sts                                             */
      __IOM uint32_t tx_abrt    : 1;            /*!< [6..6] Correspond to intr_sts                                             */
      __IOM uint32_t rx_done    : 1;            /*!< [7..7] Correspond to intr_sts                                             */
      __IOM uint32_t act        : 1;            /*!< [8..8] Correspond to intr_sts                                             */
      __IOM uint32_t stp_det    : 1;            /*!< [9..9] Correspond to intr_sts                                             */
      __IOM uint32_t strt_det   : 1;            /*!< [10..10] Correspond to intr_sts                                           */
      __IOM uint32_t gen_call   : 1;            /*!< [11..11] Correspond to intr_sts                                           */
      __IOM uint32_t addr0_match : 1;           /*!< [12..12] Correspond to intr_sts                                           */
      __IOM uint32_t addr1_match : 1;           /*!< [13..13] Correspond to intr_sts                                           */
      __IOM uint32_t ms_code_det : 1;           /*!< [14..14] Correspond to intr_sts                                           */
      __IOM uint32_t dma_i2c_done : 1;          /*!< [15..15] Correspond to intr_sts                                           */
    } intr_msk_b;
  } ;
  
  union {
    __IM  uint32_t raw_intr_stat;               /*!< (@ 0x00000034) I2C Raw Interrupt Status Register                          */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } raw_intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t rx_tl;                       /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t rx_tl      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
    } rx_tl_b;
  } ;
  
  union {
    __IOM uint32_t tx_tl;                       /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t tx_tl      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
    } tx_tl_b;
  } ;
  
  union {
    __IOM uint32_t clr_intr;                    /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t clr_intr   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the TX_ABRT_SOURCE register.                   */
    } clr_intr_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_under;                /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_rx_under : 1;          /*!< [0..0] Read this register to clear the rx_under interrupt (bit
                                                     0) of the raw_intr_stat register                                          */
    } clr_rx_under_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_over;                 /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_over : 1;           /*!< [0..0] Read this register to clear the rx_over interrupt (bit
                                                     1) of the raw_intr_stat register                                          */
    } clr_rx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_over;                 /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_over : 1;           /*!< [0..0] Read this register to clear the tx_over interrupt (bit
                                                     3) of the raw_intr_stat register.                                         */
    } clr_tx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_rd_req;                  /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t clr_rd_req : 1;            /*!< [0..0] Read this register to clear the rd_req interrupt (bit
                                                     5) of the raw_intr_stat register                                          */
    } clr_rd_req_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_abrt;                 /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_abrt : 1;           /*!< [0..0] Read this register to clear the tx_abrt interrupt (bit
                                                     6) of the raw_intr_stat register, and the tx_abrt_src register.This
                                                     also releases the tx fifo from the flushed/reset state,
                                                     allowing more writes to the TX FIFO. Refer to Bit 9 of
                                                     the tx_abrt_src register for an exception to clearing tx_abrt_src.        */
    } clr_tx_abrt_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_done;                 /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_done : 1;           /*!< [0..0] Read this register to clear the rx_done interrupt (bit
                                                     7) of the raw_intr_stat register                                          */
    } clr_rx_done_b;
  } ;
  
  union {
    __IOM uint32_t clr_act;                     /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_act    : 1;            /*!< [0..0] Reading this register clears the activity interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the activity interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the activity interrupt (bit 8) of the raw_intr_stat
                                                     register.                                                                 */
    } clr_act_b;
  } ;
  
  union {
    __IOM uint32_t clr_stp_det;                 /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_stp_det : 1;           /*!< [0..0] Read this register to clear the stop_det interrupt (bit
                                                     9) of the raw_intr_stat register.                                         */
    } clr_stp_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_strt_det;                /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t clr_strt_det : 1;          /*!< [0..0] Read this register to clear the start_det interrupt (bit
                                                     10) of the raw_intr_stat register.                                        */
    } clr_strt_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_gen_call;                /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_gen_call : 1;          /*!< [0..0] Read this register to clear the gen_call interrupt (bit
                                                     11) of raw_intr_stat register                                             */
    } clr_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Controls whether the I2C Module is enabled.                        */
      __IOM uint32_t abrt       : 1;            /*!< [1..1] Abort I2C current transfer is done w/o flush Tx/Rx FIFO            */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t sts;                         /*!< (@ 0x00000070) I2C Status Reigster                                        */
    
    struct {
      __IM  uint32_t act        : 1;            /*!< [0..0] I2C Activity Status.                                               */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full.                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or morevalid entries, this bit is cleared. This bit
                                                     field does not request an interrupt.                                      */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty.                                                    */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO CompletelyFull. When the receive FIFO iscompletely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared.                              */
      __IM  uint32_t mst_act    : 1;            /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t slv_act    : 1;            /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t mst_hold_tx_empty : 1;     /*!< [7..7] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in master mode.                                          */
      __IM  uint32_t mst_hold_rx_full : 1;      /*!< [8..8] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in master mode.                                           */
      __IM  uint32_t slv_hold_tx_empty : 1;     /*!< [9..9] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in slave mode.                                           */
      __IM  uint32_t slv_hold_rx_full : 1;      /*!< [10..10] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in slave mode.                                            */
      __IOM uint32_t bus_sts    : 2;            /*!< [12..11] Show current I2C bus status                                      */
    } sts_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000074) I2C Transmit FIFO Level Register                           */
    
    struct {
      __IM  uint32_t txflr      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000078) I2C Receive FIFO Level Register                            */
    
    struct {
      __IM  uint32_t rxflr      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IOM uint32_t sda_hold;                    /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register                          */
    
    struct {
      __IOM uint32_t sda_hold   : 16;           /*!< [15..0] Sets the required SDA hold timein units of clk period.            */
    } sda_hold_b;
  } ;
  
  union {
    __IOM uint32_t tx_abrt_src;                 /*!< (@ 0x00000080) I2C Transmit Abort Source Register                         */
    
    struct {
      __IM  uint32_t addr_7bit_nack : 1;        /*!< [0..0] 1: Master is in 7-bit addressing mode and the address
                                                     sent was not acknowledged by any slave.                                   */
      __IM  uint32_t addr1_10bit_nack : 1;      /*!< [1..1] 1: Master is in 10-bit address mode and the first 10-bit
                                                     address byte was not acknowledged by any slave.                           */
      __IM  uint32_t addr2_10bit_nack : 1;      /*!< [2..2] 1: Master is in 10-bit address mode and the second address
                                                     byte of the 10-bit address was not acknowledged by any
                                                     slave.                                                                    */
      __IM  uint32_t txdat_nack : 1;            /*!< [3..3] 1: This is a master-mode only bit. Master has received
                                                     an acknowledgement for the address, but when it sent data
                                                     byte(s) following the address, it did not receive an acknowledge
                                                     from the remote slave(s).                                                 */
      __IM  uint32_t gcall_nack : 1;            /*!< [4..4] 1: I2C Module in master mode sent a General Call and
                                                     no slave on the bus acknowledged the General Call.                        */
      __IM  uint32_t gcall_rd   : 1;            /*!< [5..5] 1: I2C Module in master mode sent a General Call but
                                                     the user programmed the byte following the General Call
                                                     to be a read from the bus (dat_cmd[9] is set to 1).                       */
      __IM  uint32_t hs_ackdet  : 1;            /*!< [6..6] 1: Master is in High Speed mode and the High Speed Master
                                                     code was acknowledged (wrong behavior).                                   */
      __IM  uint32_t sbyte_ackdet : 1;          /*!< [7..7] 1: Master has sent a START Byte and the START Byte was
                                                     acknowledged (wrong behavior).                                            */
      __IM  uint32_t norstrt_hs : 1;            /*!< [8..8] 1: The restart is disabled (rstrt_en bit (con[5]) = 0)
                                                     and the user is trying to use the master to transfer data
                                                     in High Speed mode.                                                       */
      __IM  uint32_t norstrt_sbyte : 1;         /*!< [9..9] 1: The restart is disabled (rstrt bit con[5]) = 0) and
                                                     the user is trying to send a START Byte.                                  */
      __IM  uint32_t norstrt_10bit_rd : 1;      /*!< [10..10] 1: The restart is disabled (rstrt_en bit (con[5]) =
                                                     0) and the master sends a read command in 10-bit addressing
                                                     mode.                                                                     */
      __IM  uint32_t mst_dis    : 1;            /*!< [11..11] 1: User tries to initiate a Master operation with the
                                                     Master mode disabled.                                                     */
      __IM  uint32_t arb_lost   : 1;            /*!< [12..12] 1: Master has lost arbitration, or if tx_abrt_src[14]
                                                     is also set, then the slave transmitter has lost arbitration.             */
      __IM  uint32_t slvflush_txfifo : 1;       /*!< [13..13] 1: Slave has received a read command and some data
                                                     exists in the TX FIFO so the slave issues a tx_abrt interrupt
                                                     to flush old data in TX FIFO.                                             */
      __IM  uint32_t slv_arblost : 1;           /*!< [14..14] 1: Slave lost the bus while transmitting data to a
                                                     remote master. Tx_abrt_src[12] is set at the same time.                   */
      __IM  uint32_t slvrd_intx : 1;            /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in cmd(bit 8) of dat_cmd register.                        */
    } tx_abrt_src_b;
  } ;
  
  union {
    __IOM uint32_t slv_dat_nack;                /*!< (@ 0x00000084) I2C Generate Slave Data NACK Register                      */
    
    struct {
      __IOM uint32_t slv_dat_nack : 1;          /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     I2C Module is a slavereceiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria.                                   */
    } slv_dat_nack_b;
  } ;
  
  union {
    __IOM uint32_t dma_cr;                      /*!< (@ 0x00000088) I2C DMA Control Reigster                                   */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel.                                                         */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel.                                                         */
    } dma_cr_b;
  } ;
  
  union {
    __IOM uint32_t dma_tdlr;                    /*!< (@ 0x0000008C) I2C DMA Transmit Data Level Register                       */
    
    struct {
      __IOM uint32_t tdlr       : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tdmae= 1.                                                             */
    } dma_tdlr_b;
  } ;
  
  union {
    __IOM uint32_t dma_rdlr;                    /*!< (@ 0x00000090) I2C DMA Receive Data Level Register                        */
    
    struct {
      __IOM uint32_t rdlr       : 4;            /*!< [3..0] Receive Data Level.                                                */
    } dma_rdlr_b;
  } ;
  
  union {
    __IOM uint32_t sda_setup;                   /*!< (@ 0x00000094) I2C SDA Setup Register                                     */
    
    struct {
      __IOM uint32_t sda_setup  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an clk frequency of 10 MHz, sda_setup
                                                     should be programmed to a value of 11. sda_setup must be
                                                     programmed with a minimum value of 2.                                     */
    } sda_setup_b;
  } ;
  
  union {
    __IOM uint32_t ack_gen_call;                /*!< (@ 0x00000098) I2C ACK General Call Register                              */
    
    struct {
      __IOM uint32_t ack_gen_call : 1;          /*!< [0..0] ACK General Call. When set to 1, I2C Module responds
                                                     with a ACK (by asserting data_oe) when it receives a General
                                                     Call. When set to 0, the I2C Module does not generate General
                                                     Call interrupts.                                                          */
    } ack_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t en_sts;                      /*!< (@ 0x0000009C) I2C Enable Status Register                                 */
    
    struct {
      __IM  uint32_t en         : 1;            /*!< [0..0] Enable Status.                                                     */
      __IM  uint32_t slv_dis_in_busy : 1;       /*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting of the ENABLE register
                                                     from 1 to 0.                                                              */
      __IM  uint32_t slv_rx_dat_lost : 1;       /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting of enable
                                                     from 1 to 0.                                                              */
      __IM  uint32_t dma_dis_sts : 2;           /*!< [4..3] DMA_DISABLE_WHILE_BUSY. 00: No ill disable event is active
                                                     01: I2C is disable while busy in legacy mode 10: I2C is
                                                     disable while busy in DMA mode 11: I2C is disable while
                                                     busy in Descriptor mode                                                   */
    } en_sts_b;
  } ;
  
  union {
    __IOM uint32_t dma_cmd;                     /*!< (@ 0x000000A0) I2C DMA Command Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Set to enable DMA mode.                                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t cmd        : 1;            /*!< [5..5] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the I2C Module
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. 1 = Read 0 = Write                                      */
      __IOM uint32_t stp        : 1;            /*!< [6..6] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __IOM uint32_t rstrt      : 1;            /*!< [7..7] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received when DMA mode is enabled.                    */
    } dma_cmd_b;
  } ;
  
  union {
    __IOM uint32_t dma_len;                     /*!< (@ 0x000000A4) I2C DMA Transfer Data Length Register                      */
    
    struct {
      __IOM uint32_t len        : 16;           /*!< [15..0] DMA transfer data length(R/W)                                     */
      __IM  uint32_t tr_len     : 16;           /*!< [31..16] DMA mode transfer bytes(Read only)                               */
    } dma_len_b;
  } ;
  
  union {
    __IOM uint32_t dma_mod;                     /*!< (@ 0x000000A8) I2C DMA Mode Register                                      */
    
    struct {
      __IOM uint32_t dma_mod    : 2;            /*!< [1..0] DMA operation mode                                                 */
    } dma_mod_b;
  } ;
  
  union {
    __IOM uint32_t slp;                         /*!< (@ 0x000000AC) I2C Sleep Control Register                                 */
    
    struct {
      __IOM uint32_t clk_ctrl   : 1;            /*!< [0..0] I2C clock control, write 1 controller would gate I2C
                                                     clock until I2C slave is enable and reset synchronized
                                                     register procedure is done                                                */
      __IM  uint32_t slp_clk_gated : 1;         /*!< [1..1] I2C clock has been gated (Read Only)                               */
    } slp_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t dat_fltr_rsts_l;             /*!< (@ 0x000000B8) Data Filter Resistor Low Register                          */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_l : 20;      /*!< [19..0] Data Filter Resistor Low                                          */
    } dat_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_rsts_m;             /*!< (@ 0x000000BC) Data Filter Resistor Main Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_m : 20;      /*!< [19..0] Data Filter Resistor Main                                         */
    } dat_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_l;             /*!< (@ 0x000000C0) Clock Filter Resistor Low Register                         */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_l : 20;      /*!< [19..0] Clock Filter Resistor Low                                         */
    } clk_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_m;             /*!< (@ 0x000000C4) Clock Filter Resistor Main Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_m : 20;      /*!< [19..0] Clock Filter Resistor Main                                        */
    } clk_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_l;              /*!< (@ 0x000000C8) Data Filter Capacitor Low Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_cap_l : 20;       /*!< [19..0] Data Filter Capacitor Low                                         */
    } dat_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_m;              /*!< (@ 0x000000CC) Data Filter Capacitor Main Register                        */
    
    struct {
      __IOM uint32_t dat_fltr_cap_m : 5;        /*!< [4..0] Data Filter Capacitor Main                                         */
    } dat_fltr_cap_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_l;              /*!< (@ 0x000000D0) Clock Filter Capacitor Low Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_cap_l : 20;       /*!< [19..0] Clock Filter Capacitor Low                                        */
    } clk_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_m;              /*!< (@ 0x000000D4) Clock Filter Capacitor Main Register                       */
    
    struct {
      __IOM uint32_t clk_fltr_cap_m : 5;        /*!< [4..0] Clock Filter Capacitor Main                                        */
    } clk_fltr_cap_m_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t clr_addr_match;              /*!< (@ 0x000000E4) Clear I2C ADDR_MATCH Interrupt Register                    */
    
    struct {
      __IOM uint32_t clr_addr_match : 1;        /*!< [0..0] Clear address match interrupts raw status, and it's read
                                                     clear.                                                                    */
    } clr_addr_match_b;
  } ;
  
  union {
    __IOM uint32_t clr_dma_done;                /*!< (@ 0x000000E8) Clear I2C DMA_DONE Interrupt Register                      */
    
    struct {
      __IOM uint32_t clr_dma_done : 1;          /*!< [0..0] Clear dma_i2c_done_intr interrupts raw status, and it's
                                                     read clear.                                                               */
    } clr_dma_done_b;
  } ;
  
  union {
    __IOM uint32_t fltr;                        /*!< (@ 0x000000EC) I2C Bus Filter Register                                    */
    
    struct {
      __IOM uint32_t dig_fltr_deg : 4;          /*!< [3..0] I2C module digital filter degree                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t dig_fltr_en : 1;           /*!< [8..8] I2C module digital filter slection (enable)                        */
    } fltr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t sar1;                        /*!< (@ 0x000000F4) I2C Slave Address 1 Register                               */
    
    struct {
      __IOM uint32_t sar1       : 7;            /*!< [6..0] I2C Second Slave Address                                           */
    } sar1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t ver;                         /*!< (@ 0x000000FC) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t ver        : 32;           /*!< [31..0] I2C module version number                                         */
    } ver_b;
  } ;
} I2C3_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                            SI                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Interface for setting the audio codec. (SI)
  */

typedef struct {                                /*!< (@ 0x40013000) SI Structure                                               */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) SI Control Register                                        */
    
    struct {
      __IOM uint32_t si_wr_start : 1;           /*!< [0..0] Si starts to write the register.                                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t si_read_start : 1;         /*!< [4..4] Si starts to read the register.                                    */
      __IM  uint32_t            : 2;
      __IOM uint32_t si_disable : 1;            /*!< [7..7] SI disable control                                                 */
      __IOM uint32_t si_address : 8;            /*!< [15..8] The address of codec                                              */
      __IOM uint32_t si_data    : 16;           /*!< [31..16] si data                                                          */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t clk_ctrl;                    /*!< (@ 0x00000004) SI Clock Control Register                                  */
    
    struct {
      __IOM uint32_t reg_dk_en  : 1;            /*!< [0..0] Gate SI clock                                                      */
    } clk_ctrl_b;
  } ;
} SI_Type;                                      /*!< Size = 8 (0x8)                                                            */



/* =========================================================================================================================== */
/* ================                                          SPORT0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Audio interface for the codec (SPORT0)
  */

typedef struct {                                /*!< (@ 0x40013800) SPORT0 Structure                                           */
  
  union {
    __IOM uint32_t tx_fifo_adr;                 /*!< (@ 0x00000000) SPORT TX FIFO Register                                     */
    
    struct {
      __IOM uint32_t tx_fifo_adr : 32;          /*!< [31..0] TX FIFO address                                                   */
    } tx_fifo_adr_b;
  } ;
  
  union {
    __IOM uint32_t ctrl_1;                      /*!< (@ 0x00000004) SPORT Control 1 Register                                   */
    
    struct {
      __IOM uint32_t sp_reset   : 1;            /*!< [0..0] Reset SPORT0 module                                                */
      __IOM uint32_t tx_inv_i2s_sclk : 1;       /*!< [1..1] Inverte sclk for TX                                                */
      __IOM uint32_t rx_inv_i2s_sclk : 1;       /*!< [2..2] Inverte sclk for RX                                                */
      __IOM uint32_t slave_clk_sel : 1;         /*!< [3..3] I2S or PCM slave for CLK path.                                     */
      __IOM uint32_t slave_data_sel : 1;        /*!< [4..4] I2S or PCM slave for DATA path.                                    */
      __IOM uint32_t sp_wclk_inverse : 1;       /*!< [5..5] Inverte I2S/PCM word clock.                                        */
      __IOM uint32_t sp_loopback : 1;           /*!< [6..6] Self loopback mode.                                                */
      __IOM uint32_t dsp_ctl_mode : 1;          /*!< [7..7] Handshaking control.                                               */
      __IOM uint32_t sp_data_format_sel : 3;    /*!< [10..8] Set data format                                                   */
      __IOM uint32_t sp_en_i2s_mono : 1;        /*!< [11..11] Set audio channel                                                */
      __IOM uint32_t sp_data_len_sel : 2;       /*!< [13..12] Set data length                                                  */
      __IOM uint32_t sp_inv_i2s_sclk : 1;       /*!< [14..14] Inverte I2S/PCM bit clock.                                       */
      __IOM uint32_t sp_i2s_self_lpbk_en : 1;   /*!< [15..15] Internal loopback mode.                                          */
      __IOM uint32_t sp_tx_disable : 1;         /*!< [16..16] SPORT TX control.                                                */
      __IOM uint32_t sp_start_tx : 1;           /*!< [17..17] Start TX.                                                        */
      __IOM uint32_t sp_adc_comp : 2;           /*!< [19..18] Compander control for ADC .                                      */
      __IOM uint32_t sp_sel_i2s_tx_ch : 2;      /*!< [21..20] Sel TX channel for DAC path.                                     */
      __IOM uint32_t tx_lsb_first : 1;          /*!< [22..22] MSB or LSB control for TX.                                       */
      __IOM uint32_t rx_lsb_first : 1;          /*!< [23..23] MSB or LSB control for RX.                                       */
      __IOM uint32_t sp_rx_disable : 1;         /*!< [24..24] SPORT RX control.                                                */
      __IOM uint32_t sp_start_rx : 1;           /*!< [25..25] Start RX.                                                        */
      __IOM uint32_t sp_dac_comp : 2;           /*!< [27..26] Compander control for DAC .                                      */
      __IOM uint32_t sp_sel_i2s_rx_ch : 2;      /*!< [29..28] Select RX channel for ADC path.                                  */
      __IOM uint32_t mclk_sel   : 1;            /*!< [30..30] Select MCLK output                                               */
      __IOM uint32_t long_frame_sync : 1;       /*!< [31..31] Frame sync mode                                                  */
    } ctrl_1_b;
  } ;
  
  union {
    __IOM uint32_t ctrl_2;                      /*!< (@ 0x00000008) SPORT Control 2 Register                                   */
    
    struct {
      __IOM uint32_t frame_sync_offset : 8;     /*!< [7..0] Long frame_syn control                                             */
      __IOM uint32_t debug_bus_sel : 3;         /*!< [10..8] Debug bus control                                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t clear_tx_err_cnt : 1;      /*!< [12..12] Clear TX error counter                                           */
      __IOM uint32_t clear_rx_err_cnt : 1;      /*!< [13..13] Clear RX error counter                                           */
      __IM  uint32_t            : 2;
      __IOM uint32_t mode_40mhz : 1;            /*!< [16..16] 40MHz mode                                                       */
      __IOM uint32_t mode_128fs : 1;            /*!< [17..17] 128fs mode                                                       */
      __IM  uint32_t            : 2;
      __IOM uint32_t tx_src_byte_swap : 1;      /*!< [20..20] Byte swap for TX                                                 */
      __IOM uint32_t tx_src_lr_swap : 1;        /*!< [21..21] LR swap for TX                                                   */
      __IOM uint32_t rx_snk_byte_swap : 1;      /*!< [22..22] Byte swap for RX                                                 */
      __IOM uint32_t rx_snk_lr_swap : 1;        /*!< [23..23] LR swap for RX                                                   */
      __IOM uint32_t int_enable : 8;            /*!< [31..24] Interrupt Enable                                                 */
    } ctrl_2_b;
  } ;
  
  union {
    __IOM uint32_t ctrl_3;                      /*!< (@ 0x0000000C) SPORT Control 3 Register                                   */
    
    struct {
      __IOM uint32_t tx_dsp_clear_int : 1;      /*!< [0..0] Clear tx interrupt                                                 */
      __IOM uint32_t rx_dsp_clear_int : 1;      /*!< [1..1] Clear rx interrupt                                                 */
      __IM  uint32_t            : 2;
      __IOM uint32_t tx_fifo_depth_half_sel : 1;/*!< [4..4] Reduce TX FIFO depth.                                              */
      __IOM uint32_t rx_fifo_depth_half_sel : 1;/*!< [5..5] Reduce RX FIFO depth.                                              */
    } ctrl_3_b;
  } ;
  
  union {
    __IOM uint32_t rx_fifo_adr;                 /*!< (@ 0x00000010) SPORT RX FIFO Register                                     */
    
    struct {
      __IOM uint32_t rx_fifo_adr : 32;          /*!< [31..0] RX FIFO address                                                   */
    } rx_fifo_adr_b;
  } ;
  
  union {
    __IM  uint32_t counter_status;              /*!< (@ 0x00000014) SPORT Counter Status Register                              */
    
    struct {
      __IM  uint32_t tx0_wcnt_bus : 8;          /*!< [7..0] TX0 FIFO write counter status                                      */
      __IM  uint32_t tx1_wcnt_bus : 8;          /*!< [15..8] TX1 FIFO write counter status                                     */
      __IM  uint32_t rx0_rcnt_bus : 8;          /*!< [23..16] RX0 FIFO read counter status                                     */
      __IM  uint32_t rx1_rcnt_bus : 8;          /*!< [31..24] RX1 FIFO read counter status                                     */
    } counter_status_b;
  } ;
  
  union {
    __IM  uint32_t err_counter;                 /*!< (@ 0x00000018) SPORT Error Counter Register                               */
    
    struct {
      __IM  uint32_t tx_err_cnt : 8;            /*!< [7..0] TX error counter                                                   */
      __IM  uint32_t rx_err_cnt : 8;            /*!< [15..8] RX error counter                                                  */
    } err_counter_b;
  } ;
  
  union {
    __IOM uint32_t gen_bclk;                    /*!< (@ 0x0000001C) SPORT Generate BCLK Register                               */
    
    struct {
      __IOM uint32_t mi         : 16;           /*!< [15..0] Set parameter for BCLK                                            */
      __IOM uint32_t ni         : 15;           /*!< [30..16] Set parameter for BCLK                                           */
      __IOM uint32_t mi_ni_update : 1;          /*!< [31..31] Update mi and ni                                                 */
    } gen_bclk_b;
  } ;
} SPORT0_Type;                                  /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                            I3C                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I3C (I3C)
  */

typedef struct {                                /*!< (@ 0x40044800) I3C Structure                                              */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} I3C_Type;                                     /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                          SGPIO0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial General Purpose Input / Output (SGPIO0)
  */

typedef struct {                                /*!< (@ 0x40046000) SGPIO0 Structure                                           */
  
  union {
    __IOM uint32_t rxtmr_ctrl;                  /*!< (@ 0x00000000) RX Timer Control Register                                  */
    
    struct {
      __IOM uint32_t rxtmr_cen  : 1;            /*!< [0..0] 0: Disabled. The counters are disabled. 1: Enabled. RXTC
                                                     and RXPRTC are enabled.                                                   */
      __IOM uint32_t rxtmr_crst : 1;            /*!< [1..1] RXTC and RXPRTC are synchronously reset on the next positive
                                                     edge of PCLK. The counters remain reset until RXTMR_CEN
                                                     is returned to zero. 0: Disabled. Do nothing. 1: Enabled.                 */
      __IM  uint32_t            : 6;
      __IOM uint32_t rxtmredge_sel : 2;         /*!< [9..8] RXTC will start and RXTMR_CEN will be set according to
                                                     receiving the trigger. 00: Disabled. Do nothing. 01: Receive
                                                     rising edges. 02: Receive falling edges. 03: Receive both
                                                     edges.                                                                    */
    } rxtmr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rxprval;                     /*!< (@ 0x00000004) RX Maximum Prescale Register                               */
    
    struct {
      __IOM uint32_t rxprval    : 16;           /*!< [15..0] Maximum value for the RX Prescale Counter                         */
    } rxprval_b;
  } ;
  
  union {
    __IOM uint32_t rxprtc;                      /*!< (@ 0x00000008) RX Timer Prescale Register                                 */
    
    struct {
      __IOM uint32_t rxprtc     : 16;           /*!< [15..0] RX Prescale Counter value.                                        */
    } rxprtc_b;
  } ;
  
  union {
    __IOM uint32_t rxtc;                        /*!< (@ 0x0000000C) RX Timer Counter Register                                  */
    
    struct {
      __IOM uint32_t rxtc       : 16;           /*!< [15..0] RX Timer Counter value.                                           */
    } rxtc_b;
  } ;
  
  union {
    __IOM uint32_t rxmc;                        /*!< (@ 0x00000010) Position Counter Register                                  */
    
    struct {
      __IOM uint32_t rx_mr0i_en : 1;            /*!< [0..0] Generate an interrupt when RXMR0 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr0rst_en : 1;          /*!< [1..1] Reset RXTC when RXMR0 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr0stop_en : 1;         /*!< [2..2] RXTC will stop and RXTMR_CEN will be cleared if RXMR0
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr0sclk_en : 1;         /*!< [3..3] Generate a shift clock for RX Data Register when RXMR0
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr1i_en : 1;            /*!< [4..4] Generate an interrupt when RXMR1 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr1rst_en : 1;          /*!< [5..5] Reset RXTC when RXMR1 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr1stop_en : 1;         /*!< [6..6] RXTC will stop and RXTMR_CEN will be cleared if RXMR1
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr1sclk_en : 1;         /*!< [7..7] Generate a shift clock for RX Data Register when RXMR1
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr2i_en : 1;            /*!< [8..8] Generate an interrupt when RXMR2 matches the value in
                                                     the RXTC. 0: Disable 1: Enable                                            */
      __IOM uint32_t rx_mr2rst_en : 1;          /*!< [9..9] Reset RXTC when RXMR2 matches RXTC. 0: Disable 1: Enable           */
      __IOM uint32_t rx_mr2stop_en : 1;         /*!< [10..10] RXTC will stop and RXTMR_CEN will be cleared if RXMR2
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_mr2sclk_en : 1;         /*!< [11..11] Generate a shift clock for RX Data Register when RXMR2
                                                     matches the value in the RXTC. 0: Disable 1: Enable                       */
      __IOM uint32_t rx_mr0mulrst_en : 1;       /*!< [12..12] Reset MULTC when RXMR0 matches RXTC. 0: Disable 1:
                                                     Enable                                                                    */
      __IOM uint32_t rx_mr0mulstop_en : 1;      /*!< [13..13] MULTC will stop and MULTMR_CEN will be cleared if RXMR0
                                                     matches RXTC. 0: Disable 1: Enable                                        */
      __IOM uint32_t rx_posrst_en : 1;          /*!< [14..14] Reset RXTC when each time RXPOSTC reaches 0x0.                   */
      __IOM uint32_t rx_posstop_en : 1;         /*!< [15..15] RXTC will stop and RXTMR_CEN will be cleared when each
                                                     time RXPOSTC reaches 0x0.                                                 */
    } rxmc_b;
  } ;
  
  union {
    __IOM uint32_t rxmr0;                       /*!< (@ 0x00000014) RX Match Register 0                                        */
    
    struct {
      __IOM uint32_t rxmr0      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr0_b;
  } ;
  
  union {
    __IOM uint32_t rxmr1;                       /*!< (@ 0x00000018) RX Match Register 1                                        */
    
    struct {
      __IOM uint32_t rxmr1      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr1_b;
  } ;
  
  union {
    __IOM uint32_t rxmr2;                       /*!< (@ 0x0000001C) RX Match Register 2                                        */
    
    struct {
      __IOM uint32_t rxmr2      : 16;           /*!< [15..0] RX timer counter match value.                                     */
    } rxmr2_b;
  } ;
  
  union {
    __IOM uint32_t cap_ctrl;                    /*!< (@ 0x00000020) Capture Control Register                                   */
    
    struct {
      __IOM uint32_t cap_en     : 1;            /*!< [0..0] CAPR is loaded with the value of RXTC when there is an
                                                     event on the input. 0: Disable 1: Enable.                                 */
      __IOM uint32_t capi_en    : 1;            /*!< [1..1] The capture load event generates an interrupt. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t capsrc_sel : 1;            /*!< [2..2] Select the capture trigger source. 0: RX input trigger
                                                     event 1: Multiple Counter match event                                     */
      __IOM uint32_t capfe_en   : 1;            /*!< [3..3] Capture on falling edge: a sequence of 1 then 0 causes
                                                     CAPR to be loaded with the contents of RXTC. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t capre_en   : 1;            /*!< [4..4] Capture on rising edge: a sequence of 0 then 1 causes
                                                     CAPR to be loaded with the contents of RXTC. 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t cap_rxtcrst_en : 1;        /*!< [5..5] Reset RXTC when the capture trigger event happens. 0:
                                                     Disable 1: Enable                                                         */
      __IOM uint32_t cap_rxtcstop_en : 1;       /*!< [6..6] RXTC will stop and RXTMR_CEN will be cleared if the capture
                                                     trigger event happens. 0: Disable 1: Enable                               */
      __IOM uint32_t cap_cmpval_sel : 1;        /*!< [7..7] RXDATA receives value when CAPR is bigger than CAP_CMPVAL.
                                                     0: RXDATA receives 0 1: RXDATA receives 1                                 */
      __IOM uint32_t capvalid_en : 1;           /*!< [8..8] The valid match needs that RXTMR_CEN is enabled. 0: Need
                                                     to enable RXTMR_CEN. 1: Do not need to enable RXTMR_CEN.                  */
      __IM  uint32_t            : 7;
      __IOM uint32_t cap_cmpval : 16;           /*!< [31..16] Compare this value with CAPR                                     */
    } cap_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t capr;                        /*!< (@ 0x00000024) Capture Register                                           */
    
    struct {
      __IM  uint32_t capr       : 16;           /*!< [15..0] RX timer counter capture value                                    */
    } capr_b;
  } ;
  
  union {
    __IOM uint32_t multmr_ctrl;                 /*!< (@ 0x00000028) Multiple Timer Control Register                            */
    
    struct {
      __IOM uint32_t multmr_cen : 1;            /*!< [0..0] 0: Disabled. The counters are disabled. 1: Enabled. MULTC
                                                     and MULPRTC are enabled.                                                  */
      __IOM uint32_t multmr_crst : 1;           /*!< [1..1] The Timer Counter and the Prescale Counter are synchronously
                                                     reset on the next positive edge of PCLK. The counters remain
                                                     reset until MULTMR_CEN is returned to zero. 0: Disabled.
                                                     Do nothing. 1: Enabled.                                                   */
      __IM  uint32_t            : 6;
      __IOM uint32_t mulmode_en : 2;            /*!< [9..8] Counter/Timer Mode This field selects which rising PCLK
                                                     edges can increment MULPRTC or clear MULPRTC and increment
                                                     MULTC. Timer Mode: MULTC is incremented when MULPRTC matches
                                                     MULPRVAL. Before change this mode, need to check that MUTMR_CEN
                                                     is 0. 00: Timer Mode. Incremented every rising PCLK edge.
                                                     01: Counter Mode rising edge. MULTC is incremented on rising
                                                     edges on the input. 02: Counter Mode falling edge. MULTC
                                                     is incremented on falling edges on the input. 03: Counter
                                                     Mode both edge. MULTC is incremented                                      */
    } multmr_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t mulprval;                    /*!< (@ 0x0000002C) Multiple Maximum Prescale Register                         */
    
    struct {
      __IOM uint32_t mulprval   : 16;           /*!< [15..0] Maximum value for the Multiple Prescale Counter                   */
    } mulprval_b;
  } ;
  
  union {
    __IOM uint32_t mulprtc;                     /*!< (@ 0x00000030) Multiple Timer Prescale Register                           */
    
    struct {
      __IOM uint32_t mulprtc    : 16;           /*!< [15..0] Multiple Prescale Counter value.                                  */
    } mulprtc_b;
  } ;
  
  union {
    __IOM uint32_t multc;                       /*!< (@ 0x00000034) Multiple Timer Counter Register                            */
    
    struct {
      __IOM uint32_t multc      : 16;           /*!< [15..0] Multiple Timer Counter value.                                     */
    } multc_b;
  } ;
  
  union {
    __IOM uint32_t mulmc;                       /*!< (@ 0x00000038) Multiple Match Control Register                            */
    
    struct {
      __IOM uint32_t mul_mr0i_en : 1;           /*!< [0..0] Generate an interrupt when BIT_PERI_MULMR0_GP0 or BIT_PERI_MULMR0_GP1
                                                     match the value in the BIT_PERI_MULTC. 0: Disable 1: Enable               */
      __IOM uint32_t mul_mr0rst_en : 1;         /*!< [1..1] Reset BIT_PERI_MULTC when BIT_PERI_MULMR0_GP0 or BIT_PERI_MULMR0_GP1
                                                     match BIT_PERI_MULTC. 0: Disable 1: Enable                                */
      __IOM uint32_t mul_mr0stop_en : 1;        /*!< [2..2] MULTC will stop and MULTMR_CEN will be cleared if MULMR0_GP0
                                                     or MULMR0_GP1 match MULTC. 0: Disable 1: Enable                           */
      __IOM uint32_t mul_mr0sclk_en : 1;        /*!< [3..3] Generate a shift clock for Multiple Data Register when
                                                     MULMR0_GP0 or MULMR0_GP1 match the value in the MULTC.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mul_mr0rxrst_en : 1;       /*!< [4..4] Reset RXTC when MULMR0_GP0 or MULMR0_GP1 match MULTC.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mul_mr0rxstop_en : 1;      /*!< [5..5] RXTC will stop and RXTMR_CEN will be cleared if MULMR0_GP0
                                                     or MULMR0_GP1 match MULTC. 0: Disable 1: Enable                           */
      __IOM uint32_t mul_mr0capsrc_en : 1;      /*!< [6..6] Change the capture trigger source. When match MULTC,
                                                     generate the Multiple Counter match event to make that
                                                     CAPR is loaded with the value of RXTC. 0: Disable 1: Enable               */
      __IOM uint32_t mul_mr0mcnt_en : 1;        /*!< [7..7] Let MUL_MCNT counts down when MULMR0_GP0 or MULMR0_GP1
                                                     match the value in the MULTC. 0: Disable 1: Enable                        */
      __IOM uint32_t mul_mcnti_en : 1;          /*!< [8..8] Generate an interrupt when MUL_MCNT reaches zero.                  */
      __IOM uint32_t mul_mcntrst_en : 1;        /*!< [9..9] Reset MULTC when each time MUL_MCNT reaches zero. 0:
                                                     Disable 1: Enable                                                         */
      __IOM uint32_t mul_mcntstop_en : 1;       /*!< [10..10] MULTC will stop and MULTMR_CEN will be cleared if each
                                                     time MUL_MCNT reaches zero. 0: Disable 1: Enable                          */
      __IOM uint32_t mul_fmode_en : 1;          /*!< [11..11] The match value of multiple match control is according
                                                     to multiple match FIFO. This mode only changes match values.
                                                     The match control is the same. 1->0 reset all FIFO logic
                                                     to initial state. 0: Disable 1: Enable                                    */
      __IOM uint32_t mul_dma_en : 1;            /*!< [12..12] Use DMA mode to write the match value of FIFO. Need
                                                     to set FMODE. 0: Disable 1: Enable                                        */
      __IOM uint32_t mul_dma_start : 1;         /*!< [13..13] When set DMA register and complete data prepartion,
                                                     set this bit in order to trigger that mutiple match FIFO
                                                     is loaded with data for the first time. 0: Disabled. Do
                                                     nothing. 1: Trigger DMA. Automatically change from 1 to
                                                     0.                                                                        */
      __IOM uint32_t mul_dma_unfli_en : 1;      /*!< [14..14] Generate an interrupt when multiple match FIFO is underflow
                                                     in the DMA mode. (MUL_DMA_EN = 1)                                         */
    } mulmc_b;
  } ;
  
  union {
    __IOM uint32_t mulmr01gp0;                  /*!< (@ 0x0000003C) Multiple Match Register 0 & 1 For Group 0                  */
    
    struct {
      __IOM uint32_t mulmr0_gp0 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
      __IOM uint32_t mulmr1_gp0 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
    } mulmr01gp0_b;
  } ;
  
  union {
    __IOM uint32_t mulmr23gp0;                  /*!< (@ 0x00000040) Multiple Match Register 2 & 3 For Group 0                  */
    
    struct {
      __IOM uint32_t mulmr2_gp0 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
      __IOM uint32_t mulmr3_gp0 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     0.                                                                        */
    } mulmr23gp0_b;
  } ;
  
  union {
    __IOM uint32_t mulmr01gp1;                  /*!< (@ 0x00000044) Multiple Match Register 0 & 1 For Group 1                  */
    
    struct {
      __IOM uint32_t mulmr0_gp1 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
      __IOM uint32_t mulmr1_gp1 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
    } mulmr01gp1_b;
  } ;
  
  union {
    __IOM uint32_t mulmr23gp1;                  /*!< (@ 0x00000048) Multiple Match Register 2 & 3 For Group 1                  */
    
    struct {
      __IOM uint32_t mulmr2_gp1 : 16;           /*!< [15..0] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
      __IOM uint32_t mulmr3_gp1 : 16;           /*!< [31..16] Multiple timer counter match value when TXDATA[0] is
                                                     1.                                                                        */
    } mulmr23gp1_b;
  } ;
  
  union {
    __IOM uint32_t mul_mcnt;                    /*!< (@ 0x0000004C) Multiple Match Counter Register                            */
    
    struct {
      __IOM uint32_t mul_mcnt   : 8;            /*!< [7..0] When MULMR0_GP0 or MULMR0_GP1 match MULTC, MUL_MCNT counts
                                                     down. Counting to zero can stop and reset the multiple
                                                     counter by multiple match control register.                               */
    } mul_mcnt_b;
  } ;
  
  union {
    __IOM uint32_t mulemr;                      /*!< (@ 0x00000050) External Match Control Register                            */
    
    struct {
      __IOM uint32_t mulemc1    : 2;            /*!< [1..0] When MULMR1_GP0 or MULMR1_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t mulemc2    : 2;            /*!< [3..2] When MULMR2_GP0 or MULMR2_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t mulemc3    : 2;            /*!< [5..4] When MULMR3_GP0 or MULMR3_GP1 are equal to MULTC, determines
                                                     the functionality of output. 00: Do nothing. 01: Output
                                                     is low. 10: Output is high. 11: Toggle.                                   */
      __IOM uint32_t rxemc0     : 2;            /*!< [7..6] When RXMR0 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IOM uint32_t rxemc1     : 2;            /*!< [9..8] When RXMR1 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IOM uint32_t rxemc2     : 2;            /*!< [11..10] When RXMR2 is equal to RXTC, determines the functionality
                                                     of output. 00: Do nothing. 01: Output is low. 10: Output
                                                     is high. 11: Toggle.                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t biout      : 1;            /*!< [16..16] Send TX to bi-direction open-drain output. When disable
                                                     output, bi-direction open-drain output is high. 0: Disable
                                                     output 1: Enable output                                                   */
    } mulemr_b;
  } ;
  
  union {
    __IOM uint32_t data_ctrl;                   /*!< (@ 0x00000054) Data Control Register                                      */
    
    struct {
      __IOM uint32_t rxsft_ie   : 1;            /*!< [0..0] Enable generating an interrupt when have a shift clock
                                                     for RX Data Register. 0: Disable 1: Enable                                */
      __IOM uint32_t mulsft_ie  : 1;            /*!< [1..1] Enable generating an interrupt when have a shift clock
                                                     for Multiple Data Register. 0: Disable 1: Enable                          */
      __IOM uint32_t rxload_ie  : 1;            /*!< [2..2] When RXDATA_DP is loaded with RXDATA, generate an interrupt.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t mulload_ie : 1;            /*!< [3..3] When MULDATA_DP is loaded with MULDATA, generate an interrupt.
                                                     0: Disable 1: Enable                                                      */
      __IOM uint32_t rxdatasrc_sel : 1;         /*!< [4..4] Select RXDATA input source. 0: External input 1: Capture
                                                     comparison                                                                */
      __IOM uint32_t pattern_match_mode : 1;    /*!< [5..5] Filter receving data. RXDATA_DP is programmed with the
                                                     pattern to be matched. RXDATA_DP is not loaded with RXDATA.
                                                     0: Do not match data 1: Match dat                                         */
      __IOM uint32_t pattern_match_ie : 1;      /*!< [6..6] When RXDATA_DP is equal to RXDATA & RXDATAMASK, generate
                                                     an interrupt. E.g. when looking for pattern 0x12XX XX34,
                                                     then RXDATA should be set to 0x12XX XX34 and RXDATAMASK
                                                     to 0xFF00 00FF. 0: Disable 1: Enable                                      */
      __IOM uint32_t rxdata_dir : 1;            /*!< [7..7] Select the input direction of the RXDATA 0: Input data
                                                     from MSB 1: Input data from LSB                                           */
      __IOM uint32_t txdata_dir : 1;            /*!< [8..8] Select the output direction of the TXDATA 0: Output data
                                                     from LSB 1: Output data from MSB                                          */
    } data_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rxdata;                      /*!< (@ 0x00000058) RX Data Register                                           */
    
    struct {
      __IOM uint32_t rxdata     : 32;           /*!< [31..0] The register shifts right at each active shift clock;
                                                     loading RXDATA[31] with data captured from input.                         */
    } rxdata_b;
  } ;
  
  union {
    __IOM uint32_t rxdata_dp;                   /*!< (@ 0x0000005C) RX Data Duplicate Register                                 */
    
    struct {
      __IOM uint32_t rxdata_dp  : 32;           /*!< [31..0] When each time RXPOSTC reaches 0x0, RXDATA_DP is loaded
                                                     with RXDATA.                                                              */
    } rxdata_dp_b;
  } ;
  
  union {
    __IOM uint32_t rxposr;                      /*!< (@ 0x00000060) RX Position Register                                       */
    
    struct {
      __IOM uint32_t rxpostc    : 5;            /*!< [4..0] When generate a shift clock for RX Data Register, RXPOSTC
                                                     counts down                                                               */
      __IM  uint32_t            : 3;
      __IOM uint32_t rxposrst   : 5;            /*!< [12..8] Reload value for RXPOSTC after RXPOSTC reaches 0x0.               */
    } rxposr_b;
  } ;
  
  union {
    __IOM uint32_t rxdatamask;                  /*!< (@ 0x00000064) RX Data Mask Register                                      */
    
    struct {
      __IOM uint32_t rxdatamask : 32;           /*!< [31..0] Mask for pattern match function.                                  */
    } rxdatamask_b;
  } ;
  
  union {
    __IOM uint32_t muldata;                     /*!< (@ 0x00000068) Multiple Data Register                                     */
    
    struct {
      __IOM uint32_t muldata    : 32;           /*!< [31..0] The register shifts right at each active shift clock;
                                                     output is set to MULDATA [0].                                             */
    } muldata_b;
  } ;
  
  union {
    __IOM uint32_t muldata_dp;                  /*!< (@ 0x0000006C) Multiple Data Duplicate Register                           */
    
    struct {
      __IOM uint32_t muldata_dp : 32;           /*!< [31..0] When each time MULPOSTC reaches 0x0, MULDATA_DP is loaded
                                                     with MULDATA.                                                             */
    } muldata_dp_b;
  } ;
  
  union {
    __IOM uint32_t mulposr;                     /*!< (@ 0x00000070) Multiple Position Register                                 */
    
    struct {
      __IOM uint32_t mulpostc   : 5;            /*!< [4..0] When generate a shift clock for Multiple Data Register,
                                                     MULPOSTC counts down.                                                     */
      __IM  uint32_t            : 3;
      __IOM uint32_t mulposrst  : 5;            /*!< [12..8] Reload value for MULPOSTC after MULPOSTC reaches 0x0.             */
    } mulposr_b;
  } ;
  
  union {
    __OM  uint32_t mulfdata;                    /*!< (@ 0x00000074) Multiple FIFO Data Register                                */
    
    struct {
      __OM  uint32_t mulfdata   : 32;           /*!< [31..0] Write the match value (FMR1, FMR0) or (FMR3, FMR2) to
                                                     FIFO.                                                                     */
    } mulfdata_b;
  } ;
  
  union {
    __IOM uint32_t is;                          /*!< (@ 0x00000078) SGPIO Interrupt Status Register                            */
    
    struct {
      __IOM uint32_t rx_mr0i_is : 1;            /*!< [0..0] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rx_mr1i_is : 1;            /*!< [1..1] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rx_mr2i_is : 1;            /*!< [2..2] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mul_mr0i_is : 1;           /*!< [3..3] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t capi_is    : 1;            /*!< [4..4] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rxsft_is   : 1;            /*!< [5..5] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulsft_is  : 1;            /*!< [6..6] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t rxload_is  : 1;            /*!< [7..7] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulload_is : 1;            /*!< [8..8] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t pattern_match_is : 1;      /*!< [9..9] Interrupt raw status 0: No Interrupt. 1: Interrupt requirement
                                                     met. Clear Interrupts; write 1 to clear.                                  */
      __IOM uint32_t mulmcnt_is : 1;            /*!< [10..10] Interrupt raw status 0: No Interrupt. 1: Interrupt
                                                     requirement met. Clear Interrupts; write 1 to clear.                      */
      __IOM uint32_t mul_dma_unfl_is : 1;       /*!< [11..11] Interrupt raw status 0: No Interrupt. 1: Interrupt
                                                     requirement met. Clear Interrupts; write 1 to clear.                      */
    } is_b;
  } ;
  
  union {
    __IOM uint32_t gf;                          /*!< (@ 0x0000007C) SGPIO Glitch Filter Register                               */
    
    struct {
      __IOM uint32_t gf         : 8;            /*!< [7..0] This register can enable or disable digital glitch filtering.
                                                     0: Disable 1: delay 1T clock 2: delay 2T clock etc. 255:
                                                     delay 255T clock                                                          */
    } gf_b;
  } ;
  
  union {
    __IOM uint32_t output;                      /*!< (@ 0x00000080) SGPIO Output Register                                      */
    
    struct {
      __IOM uint32_t output     : 1;            /*!< [0..0] This bit will act according to MULEMC1~3 and RXEMC0~2
                                                     bits. Drive the state of output by setting this bit. 0:
                                                     Output is low 1: Output is high                                           */
    } output_b;
  } ;
  
  union {
    __IOM uint32_t im;                          /*!< (@ 0x00000084) SGPIO Interrupt Mask Register                              */
    
    struct {
      __IOM uint32_t rx_mr0i_im : 1;            /*!< [0..0] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rx_mr1i_im : 1;            /*!< [1..1] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rx_mr2i_im : 1;            /*!< [2..2] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mul_mr0i_im : 1;           /*!< [3..3] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t capi_im    : 1;            /*!< [4..4] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rxsft_im   : 1;            /*!< [5..5] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulsft_im  : 1;            /*!< [6..6] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t rxload_im  : 1;            /*!< [7..7] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulload_im : 1;            /*!< [8..8] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t pattern_match_im : 1;      /*!< [9..9] interrupt mask: 0: un-mask 1: mask                                 */
      __IOM uint32_t mulmcnt_im : 1;            /*!< [10..10] interrupt mask: 0: un-mask 1: mask                               */
      __IOM uint32_t mul_dma_unfl_im : 1;       /*!< [11..11] interrupt mask: 0: un-mask 1: mask                               */
    } im_b;
  } ;
} SGPIO0_Type;                                  /*!< Size = 136 (0x88)                                                         */



/* =========================================================================================================================== */
/* ================                                         SDIO_DEV                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SDIO Device (SDIO_DEV)
  */

typedef struct {                                /*!< (@ 0x40050000) SDIO_DEV Structure                                         */
  __IM  uint32_t  RESERVED[40];
  
  union {
    __IOM uint32_t txbd_addr;                   /*!< (@ 0x000000A0) TX BD(Buffer Descriptor) Address Register                  */
    
    struct {
      __IOM uint32_t tx_bd_addr : 32;           /*!< [31..0] The base address of TXBD The value of this register
                                                     should be configure by CPU It should be 4 byte alignment
                                                     (Because TXBD Size is 8 Byte).                                            */
    } txbd_addr_b;
  } ;
  
  union {
    __IOM uint32_t txbd_num;                    /*!< (@ 0x000000A4) TX BD Number Register                                      */
    
    struct {
      __IOM uint32_t tx_bd_num  : 16;           /*!< [15..0] The Number of TXBD. Unit: Number The value of this register
                                                     should be configured at SDIO device HAL initialization                    */
    } txbd_num_b;
  } ;
  
  union {
    __IOM uint32_t txbd_wptr;                   /*!< (@ 0x000000A8) TX BD Write Pointer Register                               */
    
    struct {
      __IOM uint32_t tx_bd_h2c_wptr : 16;       /*!< [15..0] When the packet has been sent from Host to TX Buffer,
                                                     this index should be updated by SDIO Device HAL driver                    */
    } txbd_wptr_b;
  } ;
  
  union {
    __IOM uint32_t txbd_rptr;                   /*!< (@ 0x000000AC) TX BD Read Pointer Register                                */
    
    struct {
      __IOM uint32_t tx_bd_h2c_rptr : 16;       /*!< [15..0] When the TX packet has been processed and moved to MAC
                                                     TX FIFO, this index should be updated by HAL driver.                      */
    } txbd_rptr_b;
  } ;
  
  union {
    __IOM uint32_t rxbd_addr;                   /*!< (@ 0x000000B0) RX BD Address Register                                     */
    
    struct {
      __IOM uint32_t rx_bd_addr : 32;           /*!< [31..0] The base address of RX BD. The HAL driver should configure
                                                     this register at initial. It should be a 8-Byte aligned
                                                     address.                                                                  */
    } rxbd_addr_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_num;                    /*!< (@ 0x000000B4) RX BD Number Register                                      */
    
    struct {
      __IOM uint16_t rx_bd_num  : 16;           /*!< [15..0] The total number of RX BD This register should be configured
                                                     by HAL driver at initialization.                                          */
    } rxbd_num_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_wptr;                   /*!< (@ 0x000000B6) RX BD Write Pointer Register                               */
    
    struct {
      __IOM uint16_t rx_bd_c2h_wptr : 16;       /*!< [15..0] When the packet has been processed and has been moved
                                                     to host TX FIFO, this index should be updated by the HAL
                                                     driver.                                                                   */
    } rxbd_wptr_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_rptr;                   /*!< (@ 0x000000B8) RX BD Read Pointer Register                                */
    
    struct {
      __IOM uint16_t rx_bd_c2h_rptr : 16;       /*!< [15..0] When the packet has been processed and has been transfered
                                                     to host, the HW will update this RX BD index.                             */
    } rxbd_rptr_b;
  } ;
  
  union {
    __IOM uint8_t hci_rx_ctrl;                  /*!< (@ 0x000000BA) HCI RX Control Register                                    */
    
    struct {
      __IOM uint8_t rx_req      : 1;            /*!< [0..0] HAL driver triggers this bit to enable SDIO IP HW to
                                                     fetch RX BD info. SDIO HW fetch RX BD to get the RX length
                                                     and address and then start to transfer RX packet to SDIO
                                                     Host. This bit will be cleared when all RX BD transfer
                                                     is done.                                                                  */
    } hci_rx_ctrl_b;
  } ;
  
  union {
    __IOM uint8_t sdio_ctrl;                    /*!< (@ 0x000000BB) SDIO HW Control Register                                   */
    
    struct {
      __IOM uint8_t sdio_dat_edge_inv : 1;      /*!< [0..0] Set this bit to invert the SDIO data latch clock.                  */
      __IM  uint8_t             : 6;
      __IOM uint8_t sdio_dma_rst : 1;           /*!< [7..7] The HAL driver can set this bit to reset SDIO DMA HW.
                                                     This bit will be cleared automatically by the HW.                         */
    } sdio_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rx_req_addr;                 /*!< (@ 0x000000BC) RX Request Address Register                                */
    
    struct {
      __IOM uint32_t rx_req_addr : 32;          /*!< [31..0] The address of the requested RX packet. This register
                                                     is discarded for Ameba.                                                   */
    } rx_req_addr_b;
  } ;
  
  union {
    __IOM uint16_t int_mask;                    /*!< (@ 0x000000C0) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint16_t txbd_h2c_ovf : 1;          /*!< [0..0] Set this bit to enable the H2C TX BD overflow interrupt.           */
      __IOM uint16_t h2c_bus_res_fail : 1;      /*!< [1..1] Set this bit to enable the H2C bus resource failed interrupt.      */
      __IOM uint16_t h2c_dma_ok : 1;            /*!< [2..2] Set this bit to enable the H2C DMA done interrupt.                 */
      __IOM uint16_t c2h_dma_ok : 1;            /*!< [3..3] Set this bit to enable the C2H DMA done interrupt.                 */
      __IOM uint16_t h2c_msg    : 1;            /*!< [4..4] Set this bit to enable the H2C message interrupt.                  */
      __IOM uint16_t rpwm1      : 1;            /*!< [5..5] Set this bit to enable the RPWM interrupt.                         */
      __IOM uint16_t rpwm2      : 1;            /*!< [6..6] Set this bit to enable the RPWM2 interrupt.                        */
      __IOM uint16_t sdio_rst_cmd : 1;          /*!< [7..7] Set this bit to enable the SDIO reset command interrupt            */
      __IOM uint16_t rx_bd_err  : 1;            /*!< [8..8] Set this bit to enable the RX BD error interrupt.                  */
      __IOM uint16_t rx_bd_avai : 1;            /*!< [9..9] Set this bit to enable the RX BD available interrupt.              */
      __IOM uint16_t host_wake  : 1;            /*!< [10..10] Set this bit to enable the SDIO host wake event interrupt.       */
      __IOM uint16_t host_cmd11 : 1;            /*!< [11..11] Set this bit to enable the SDIO host CMD11(3.3v ->
                                                     1.8v) interrupt.                                                          */
    } int_mask_b;
  } ;
  
  union {
    __IOM uint16_t int_sts;                     /*!< (@ 0x000000C2) Interrupt Status Register                                  */
    
    struct {
      __IOM uint16_t txbd_h2c_ovf : 1;          /*!< [0..0] If there is not enough TX_BD for TX Packet, this interrupt
                                                     will be raised. The HAL driver write 1 to this bit to clear
                                                     this interript status.                                                    */
      __IOM uint16_t h2c_bus_res_fail : 1;      /*!< [1..1] If SDIO is going to move packet to TX FIFO and fails
                                                     to get bus resource, this interrupt raise. HAL driver write
                                                     1 to this bit to clear this interrupt status.                             */
      __IOM uint16_t h2c_dma_ok : 1;            /*!< [2..2] Trigger by SDIO HW for the event of packet is sent from
                                                     Host to TXFIFO                                                            */
      __IOM uint16_t c2h_dma_ok : 1;            /*!< [3..3] Trigger by SDIO HW for the event of packet is sent from
                                                     RXFIFO to Host                                                            */
      __IOM uint16_t h2c_msg    : 1;            /*!< [4..4] Trigger by SDIO HW for the event of H2C_MSG_INT occurs(REG_SDIO_H2C_MSG
                                                     is written)                                                               */
      __IOM uint16_t rpwm1      : 1;            /*!< [5..5] Trigger by SDIO HW for the event of the RPWM1 occurs(HRPWM2
                                                     is written) CPU should be able to receive this interrupt
                                                     even CPU clock is gated; therefore, this interrupt should
                                                     be connected to System On circuit.                                        */
      __IOM uint16_t rpwm2      : 1;            /*!< [6..6] Trigger by SDIO HW for the event of RPWM2 occurs (HRPWM
                                                     is toggled) CPU should be able to receive this interrupt
                                                     even CPU clock is gated; therefore, this interrupt should
                                                     be connected to System On circuit.                                        */
      __IOM uint16_t sdio_rst_cmd : 1;          /*!< [7..7] Trigger by SDIO HW when SDIO is reset. CPU should be
                                                     able to receive this interrupt even CPU clock is gated;
                                                     therefore, this interrupt should be connected to System
                                                     On circuit.                                                               */
      __IOM uint16_t rx_bd_err  : 1;            /*!< [8..8] Trigger by SDIO to CPU when detect RX_BD error                     */
      __IOM uint16_t rx_bd_avai : 1;            /*!< [9..9] If the free RXBD Number become larger than FREE_RXBD_COUNT(0xD8),
                                                     trigger this interrupt. This interrupt trigger only once
                                                     when free RXBD number cross FREE_RXBD_COUNT                               */
      __IOM uint16_t host_wake  : 1;            /*!< [10..10] When Host Send TRX CMD53 while CPU is not ready (SYSTEM_CPU_RDY_IND=0
                                                     or CPU_RDY_IND=0), trigger this interrupt to wake CPU,
                                                     and then indicate BUSY status to host. CPU should be able
                                                     to receive this interrupt even CPU clock is gated; therefore,
                                                     this interrupt should be connected to System On circuit.                  */
      __IOM uint16_t host_cmd11 : 1;            /*!< [11..11] When Host sends CMD11 to notify that the signal voltage
                                                     level is going to switch to 1.8v, the HW should issue this
                                                     interrupt to notify the local CPU to do the LDO power voltage
                                                     level switch.                                                             */
    } int_sts_b;
  } ;
  
  union {
    __IOM uint8_t ccpwm;                        /*!< (@ 0x000000C4) CCPWM Register (CPU domain Sync to HCPWM register)         */
    
    struct {
      __IM  uint8_t             : 1;
      __IOM uint8_t wlan_trx    : 1;            /*!< [1..1] 1: WLAN On; 0: WLAN Off.                                           */
      __IOM uint8_t rps_st      : 1;            /*!< [2..2] 1: AP Register Active State; 0: AP Register Sleep State;           */
      __IOM uint8_t wwlan       : 1;            /*!< [3..3] 1: Wake On WLAN State; 0: Normal State;                            */
      __IM  uint8_t             : 3;
      __IOM uint8_t toggle      : 1;            /*!< [7..7] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } ccpwm_b;
  } ;
  
  union {
    __IOM uint8_t sys_ind;                      /*!< (@ 0x000000C5) System Indication Register                                 */
    
    struct {
      __IOM uint8_t sys_cpu_rdy_ind : 1;        /*!< [0..0] Used to indicate the SDIO NIC driver that local CPU is
                                                     ready for TRX. Default: 0 This bit is synchronized to CPU_RDY_IND(Offset
                                                     0x87)                                                                     */
    } sys_ind_b;
  } ;
  
  union {
    __IOM uint16_t ccpwm2;                      /*!< (@ 0x000000C6) CCPWM2 Register (CPU domain Sync to HCPWM2 register)       */
    
    struct {
      __IOM uint16_t active     : 1;            /*!< [0..0] 1: indicate that the SDIO device is in the activate state.         */
      __IOM uint16_t dstandby   : 1;            /*!< [1..1] 1: indicates that the SDIO device is in the deep-standby
                                                     state.                                                                    */
      __IOM uint16_t fboot      : 1;            /*!< [2..2] 1: indicates that the SDIO device boot from the fast
                                                     boot                                                                      */
      __IOM uint16_t inic_fw_rdy : 1;           /*!< [3..3] Indicates the FW mode of the SDIO device: 1: iNIC firmware;
                                                     0: SDIO boot firmware.                                                    */
      __IM  uint16_t            : 11;
      __IOM uint16_t toggle     : 1;            /*!< [15..15] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } ccpwm2_b;
  } ;
  
  union {
    __IM  uint32_t h2c_msg;                     /*!< (@ 0x000000C8) CPU H2C Message Register (CPU domain Sync from
                                                                    SDIO_H2C_MSG register)                                     */
    
    struct {
      __IM  uint32_t h2c_msg    : 31;           /*!< [30..0] The message from SDIO host side driver.                           */
      __IM  uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } h2c_msg_b;
  } ;
  
  union {
    __IOM uint32_t c2h_msg;                     /*!< (@ 0x000000CC) CPU C2H Message Register (CPU domain Sync to
                                                                    SDIO_C2H_MSG register)                                     */
    
    struct {
      __IOM uint32_t c2h_msg    : 31;           /*!< [30..0] The message from local HAL driver to SDIO host side
                                                     driver.                                                                   */
      __IOM uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } c2h_msg_b;
  } ;
  
  union {
    __IM  uint16_t crpwm;                       /*!< (@ 0x000000D0) CRPWM Register (SDIO host side driver to local
                                                                    HAL driver, Sync from HRPWM register)                      */
    
    struct {
      __IM  uint16_t            : 1;
      __IM  uint16_t wlan_trx   : 1;            /*!< [1..1] 1: WLAN On; 0: WLAN Off.                                           */
      __IM  uint16_t rps_st     : 1;            /*!< [2..2] 1: AP Register Active State; 0: AP Register Sleep State;           */
      __IM  uint16_t wwlan      : 1;            /*!< [3..3] 1: Wake On WLAN State; 0: Normal State;                            */
      __IM  uint16_t            : 3;
      __IM  uint16_t toggle     : 1;            /*!< [7..7] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } crpwm_b;
  } ;
  
  union {
    __IM  uint16_t crpwm2;                      /*!< (@ 0x000000D2) CRPWM2 Register (SDIO host side driver to local
                                                                    HAL driver, Sync from HRPWM register)                      */
    
    struct {
      __IM  uint16_t resv       : 15;           /*!< [14..0] Reserved                                                          */
      __IM  uint16_t toggle     : 1;            /*!< [15..15] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } crpwm2_b;
  } ;
  
  union {
    __IOM uint32_t ahb_dma_ctrl;                /*!< (@ 0x000000D4) AHB DMA Control Register                                   */
    
    struct {
      __IOM uint32_t spdio_txff_wlevel : 7;     /*!< [6..0] SPDIO FIFO TX water level Range 1~126, it can be modified
                                                     only when AHB_DMA_CS = 000                                                */
      __IM  uint32_t            : 1;
      __IOM uint32_t spdio_rxff_wlevel : 7;     /*!< [14..8] SPDIO FIFO RX water level Range 1~126, it can be modified
                                                     only when AHB_DMA_CS = 000                                                */
      __IM  uint32_t            : 1;
      __IM  uint32_t ahb_dma_state : 4;         /*!< [19..16] AHB DMA state                                                    */
      __IM  uint32_t            : 1;
      __IM  uint32_t ahbm_spdio_ready : 1;      /*!< [21..21] SPDIO AHB Master HREADY signal                                   */
      __IM  uint32_t ahbm_spdio_trans : 2;      /*!< [23..22] SPDIO AHB Master HTRANS signal                                   */
      __IOM uint32_t rx_ahb_busy_wait_cnt : 4;  /*!< [27..24] When SPDIO RX transfer, AHB controller will wait BUSY
                                                     counter for AHB access target not response READY signal.
                                                     If timeout, AHB controller will issue AHB_BUS_RES_FAIL
                                                     INT to CPU.                                                               */
      __IOM uint32_t ahb_burst_type : 3;        /*!< [30..28] This field is used to control to SPDIO AHB support
                                                     Burst type. 3'b100: Support Burst 16 DW 3'b010: Support
                                                     Burst 8 DW 3'b001: Support Burst 4 DW Default is 3'b111,
                                                     all support.                                                              */
      __IOM uint32_t dispatch_txagg_pkt : 1;    /*!< [31..31] Enable SPDIO to dispatch the Aggregated TX packet.               */
    } ahb_dma_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t free_rxbd_cnt;               /*!< (@ 0x000000D8) Free RX BD Count Register                                  */
    
    struct {
      __IOM uint32_t fifo_cnt   : 7;            /*!< [6..0] The SPDIO Local FIFO counter, for debug usage.                     */
      __IM  uint32_t            : 1;
      __IOM uint32_t tx_buf_unit_size : 8;      /*!< [15..8] The Size of each single TX Buffer which is addressed
                                                     by TX_BD Unit: 64Byte Ex: 0x01=>64Byte 0x10=>1024Byte                     */
      __IOM uint32_t free_rx_bd_cnt : 16;       /*!< [31..16] If SPDIO_RXBD_C2H_RPTR is updated and the free RXBD
                                                     Number is larger than FREE_RXBD_COUNT, trigger RX_BD_AVAI_INT
                                                     interrupt.                                                                */
    } free_rxbd_cnt_b;
  } ;
  
  union {
    __IM  uint32_t h2c_msg_ext;                 /*!< (@ 0x000000DC) CPU H2C Extension Message Register (CPU domain
                                                                    Sync from SDIO_H2C_MSG_EXT register)                       */
    
    struct {
      __IM  uint32_t h2c_msg_ext : 31;          /*!< [30..0] The message from SDIO host side driver to the local
                                                     HAL driver.                                                               */
      __IM  uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } h2c_msg_ext_b;
  } ;
  
  union {
    __IOM uint32_t c2h_msg_ext;                 /*!< (@ 0x000000E0) CPU C2H Extension Message Register (CPU domain
                                                                    Sync to SDIO_C2H_MSG_EXT register)                         */
    
    struct {
      __IOM uint32_t c2h_msg_ext : 31;          /*!< [30..0] The message from local HAL driver to SDIO host side
                                                     driver.                                                                   */
      __IOM uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } c2h_msg_ext_b;
  } ;
} SDIO_DEV_Type;                                /*!< Size = 228 (0xe4)                                                         */



/* =========================================================================================================================== */
/* ================                                         ETHERNET                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief ETHERNET - for Ethernet connectivity (ETHERNET)
  */

typedef struct {                                /*!< (@ 0x40054000) ETHERNET Structure                                         */
  
  union {
    __IOM uint32_t idr0;                        /*!< (@ 0x00000000) MAC ID Register 1                                          */
    
    struct {
      __IOM uint32_t idr3       : 8;            /*!< [7..0] 4th byte of MAC ID                                                 */
      __IOM uint32_t idr2       : 8;            /*!< [15..8] 3rd byte of MAC ID                                                */
      __IOM uint32_t idr1       : 8;            /*!< [23..16] 2nd byte of MAC ID                                               */
      __IOM uint32_t idr0       : 8;            /*!< [31..24] 1st byte of MAC ID                                               */
    } idr0_b;
  } ;
  
  union {
    __IOM uint32_t idr4;                        /*!< (@ 0x00000004) MAC ID Register 2                                          */
    
    struct {
      __IM  uint32_t            : 16;
      __IOM uint32_t idr5       : 8;            /*!< [23..16] 6th byte of MAC ID                                               */
      __IOM uint32_t idr4       : 8;            /*!< [31..24] 5th byte of MAC ID                                               */
    } idr4_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t txok_rxok;                   /*!< (@ 0x00000010) TxRx Ok Counter Register                                   */
    
    struct {
      __IOM uint32_t rxok       : 16;           /*!< [15..0] 16-bit counter of Rx Ok packets. Rolls over automatically.
                                                     Write to clear.                                                           */
      __IOM uint32_t txok       : 16;           /*!< [31..16] 16-bit counter of Tx Ok packets. Rolls over automatically.
                                                     Write to clear.                                                           */
    } txok_rxok_b;
  } ;
  
  union {
    __IOM uint32_t txerr_rxerr;                 /*!< (@ 0x00000014) TxRx Error Counter Register                                */
    
    struct {
      __IOM uint32_t rxerr      : 16;           /*!< [15..0] 16-bit counter of Rx error packets. Rolls over automatically.
                                                     Write to clear.                                                           */
      __IOM uint32_t txerr      : 16;           /*!< [31..16] 16-bit counter of Tx error packets. Rolls over automatically.
                                                     Write to clear.                                                           */
    } txerr_rxerr_b;
  } ;
  __IM  uint32_t  RESERVED1[8];
  
  union {
    __IOM uint32_t com;                         /*!< (@ 0x00000038) Command Register                                           */
    
    struct {
      __IOM uint32_t rst        : 1;            /*!< [0..0] Reset: Setting to 1 forces the Ethernet module to a software
                                                     reset state which disables the transmitter and receiver,
                                                     reinitializes the FIFOs, triggers interrupt Swint for RISC
                                                     to reset the system buffer pointer to the initial value
                                                     Tx/Rx FDP. This bit is 1 during the reset operation, and
                                                     is cleared to 0 by the Ethernet Module when the reset operation
                                                     is complete.                                                              */
      __IOM uint32_t rxchksum   : 1;            /*!< [1..1] Receive checksum offload enable. 1: Enable. 0: Disable.            */
      __IOM uint32_t rxvlan     : 1;            /*!< [2..2] Receive VLAN de-tagging enable. 1: Enable. 0: Disable.             */
      __IOM uint32_t rxjumbo    : 1;            /*!< [3..3] 1: support jumbo packet receiving. The maximum packet
                                                     size is 16384 Bytes (0x4000). 0: Does not support jumbo
                                                     packet receiving.                                                         */
    } com_b;
  } ;
  
  union {
    __IOM uint32_t isr_imr;                     /*!< (@ 0x0000003C) Interrupt Status & Interrupt Mask Register                 */
    
    struct {
      __IOM uint32_t isr_rok    : 1;            /*!< [0..0] Interrupt status of Rx ok. Write 1 to clear                        */
      __IOM uint32_t isr_cnt_wrap : 1;          /*!< [1..1] Interrupt status of Tx/Rx counter wrap interrupt. Write
                                                     1 to clear                                                                */
      __IOM uint32_t isr_rer_runt : 1;          /*!< [2..2] Interrupt status of Rx error caused by runt error characterized
                                                     by the frame length in bytes being less than 64 bytes.
                                                     Write 1 to clear                                                          */
      __IM  uint32_t            : 1;
      __IOM uint32_t isr_rer_ovf : 1;           /*!< [4..4] Interrupt status of Rx FIFO overflow. Write 1 to clear             */
      __IOM uint32_t isr_rdu    : 1;            /*!< [5..5] Interrupt status of Rx descriptor ring1 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_tok    : 1;            /*!< [6..6] Interrupt status of Tx ok. Write 1 to clear                        */
      __IOM uint32_t isr_ter    : 1;            /*!< [7..7] Interrupt status of Tx error. Write 1 to clear                     */
      __IOM uint32_t isr_linkchg : 1;           /*!< [8..8] Interrupt status of link change. Write 1 to clear                  */
      __IOM uint32_t isr_tdu    : 1;            /*!< [9..9] Interrupt status of Tx descriptor ring1 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_swint  : 1;            /*!< [10..10] Interrupt status of software interrupt pending. Write
                                                     1 to clear                                                                */
      __IOM uint32_t isr_rdu2   : 1;            /*!< [11..11] Interrupt status of Rx descriptor ring2 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_rdu3   : 1;            /*!< [12..12] Interrupt status of Rx descriptor ring3 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_rdu4   : 1;            /*!< [13..13] Interrupt status of Rx descriptor ring4 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_rdu5   : 1;            /*!< [14..14] Interrupt status of Rx descriptor ring5 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t isr_rdu6   : 1;            /*!< [15..15] Interrupt status of Rx descriptor ring6 is unavailable.
                                                     Write 1 to clear                                                          */
      __IOM uint32_t imr_rok    : 1;            /*!< [16..16] Interrupt mask of Rx ok                                          */
      __IOM uint32_t imr_cnt_wrap : 1;          /*!< [17..17] Interrupt mask of Tx/Rx counter wrap interrupt                   */
      __IOM uint32_t imr_rer_runt : 1;          /*!< [18..18] Interrupt mask of Rx error caused by runt error characterized
                                                     by the frame length in bytes being less than 64 bytes                     */
      __IM  uint32_t            : 1;
      __IOM uint32_t imr_rer_ovf : 1;           /*!< [20..20] Interrupt mask of Rx FIFO overflow                               */
      __IOM uint32_t imr_rdu    : 1;            /*!< [21..21] Interrupt mask of Rx descriptor ring1 is unavailable             */
      __IOM uint32_t imr_tok    : 1;            /*!< [22..22] Interrupt mask of Tx ok                                          */
      __IOM uint32_t imr_ter    : 1;            /*!< [23..23] Interrupt mask of Tx error                                       */
      __IOM uint32_t imr_linkchg : 1;           /*!< [24..24] Interrupt mask of link change                                    */
      __IOM uint32_t imr_tdu    : 1;            /*!< [25..25] Interrupt mask of Tx descriptor ring1 is unavailable             */
      __IOM uint32_t imr_swint  : 1;            /*!< [26..26] Interrupt mask of software interrupt pending                     */
      __IOM uint32_t imr_rdu2   : 1;            /*!< [27..27] Interrupt mask of Rx descriptor ring2 is unavailable             */
      __IOM uint32_t imr_rdu3   : 1;            /*!< [28..28] Interrupt mask of Rx descriptor ring3 is unavailable             */
      __IOM uint32_t imr_rdu4   : 1;            /*!< [29..29] Interrupt mask of Rx descriptor ring4 is unavailable             */
      __IOM uint32_t imr_rdu5   : 1;            /*!< [30..30] Interrupt mask of Rx descriptor ring5 is unavailable             */
      __IOM uint32_t imr_rdu6   : 1;            /*!< [31..31] Interrupt mask of Rx descriptor ring6 is unavailable             */
    } isr_imr_b;
  } ;
  
  union {
    __IOM uint32_t tc;                          /*!< (@ 0x00000040) Transmit Configuration Register                            */
    
    struct {
      __IOM uint32_t r_tx_nopadding : 1;        /*!< [0..0] 1: HW does not pad short packet (< 60B). 0: HW pads short
                                                     packet to 64B.                                                            */
      __IM  uint32_t            : 7;
      __IOM uint32_t lbk        : 2;            /*!< [9..8] The loopback function must be independent of the link
                                                     state. 2'b00: normal operation 2'b01: Loopback mode_R2T
                                                     (lbkmode_r2t) : 2'b10: Reserved 2'b11: Loopback mode (lbk_mode).          */
      __IOM uint32_t ifg        : 3;            /*!< [12..10] InterFrameGap Time: This field allows the user to adjust
                                                     the interframe gap time longer than the standard: 9.6 us
                                                     for 10Mbps, 960 ns for 100Mbps. The time can be programmed
                                                     from 9.6 us to 14.4 us (10Mbps) and 960ns to 1440ns (100Mbps)             */
    } tc_b;
  } ;
  
  union {
    __IOM uint32_t rc;                          /*!< (@ 0x00000044) Receive Configuration Register                             */
    
    struct {
      __IOM uint32_t aap        : 1;            /*!< [0..0] Set to 1 to accept all packets with physical destination
                                                     address, 0 to reject                                                      */
      __IOM uint32_t apm        : 1;            /*!< [1..1] Set to 1 to accept physical match packets, 0 to reject.            */
      __IOM uint32_t am         : 1;            /*!< [2..2] Set to 1 to accept multicast packets, 0 to reject.                 */
      __IOM uint32_t ab         : 1;            /*!< [3..3] Set to 1 to accept broadcast packets, 0 to reject                  */
      __IOM uint32_t ar         : 1;            /*!< [4..4] Accept Runt: This bit allows the receiver to accept packets
                                                     that are smaller than 64 bytes. The packet must be at least
                                                     8 bytes long to be accepted as a runt. Set to 1 to accept
                                                     runt packets.                                                             */
      __IOM uint32_t aer        : 1;            /*!< [5..5] Accept Error Packet When set to 1, all packets with CRC
                                                     error, alignment error, and/or collided fragments will
                                                     be accepted; When set to 0, all packets with CRC error,
                                                     alignment error, and/or collided fragments will be rejected.              */
      __IOM uint32_t aflow      : 1;            /*!< [6..6] Accept flow control : When set to 1, flow control packet
                                                     will also be received & DMA to rx buffer for debug. Default
                                                     is 0                                                                      */
    } rc_b;
  } ;
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t ms;                          /*!< (@ 0x00000058) Media Status Register                                      */
    
    struct {
      __IOM uint32_t refclk_on  : 1;            /*!< [0..0] 1: REF_CLK on 0: REF_CLK off                                       */
      __IOM uint32_t refclk_phase : 1;          /*!< [1..1] 1: TXEN/TXD are transitioned in the falling edge; RXD
                                                     are also sampled in the falling edge 0: TXEN/TXD are transitioned
                                                     in the rising edge; RXD are also sampled in the rising
                                                     edge                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t gmac_md_mst : 1;           /*!< [6..6] 1: GMAC is used to be MDIO master. 0: GMAC is used to
                                                     be MDIO slave.                                                            */
      __IOM uint32_t reg_rmii2mii_en : 1;       /*!< [7..7] 1: transfer MII signals to RMII signals This function
                                                     is only valid in MII mode.                                                */
      __IM  uint32_t            : 2;
      __IOM uint32_t force_spd_mode : 1;        /*!< [10..10] 1: gmac is in force speed mode. 0: gmac speed status
                                                     is from md operation.                                                     */
      __IOM uint32_t rgmii_tx_encode_sts : 1;   /*!< [11..11] This bit is valid only in phy mode. 0: Does not support
                                                     rgmii in band status(link status, speed and duplex mode
                                                     of the PHY) by encoding txd. 1: Supports rgmii in band
                                                     status(link status, speed and duplex mode of the PHY) by
                                                     encoding txd.                                                             */
      __IOM uint32_t rgmii_rx_decode_sts : 1;   /*!< [12..12] 0: Does not support rgmii in band status (link status,
                                                     speed and duplex mode of the PHY) by decoding rxd. 1: Supports
                                                     rgmii in band status (link status, speed and duplex mode
                                                     of the PHY) by decoding rxd.                                              */
      __IOM uint32_t gmac_phy_mode : 1;         /*!< [13..13] 1: in phy mode. 0: not in phy mode.                              */
      __IM  uint32_t            : 1;
      __IOM uint32_t gmac_sel_phyif_0 : 1;      /*!< [15..15] 1: phy interface 0.works. 0: phy interface 1 works.              */
      __IOM uint32_t force_spd  : 2;            /*!< [17..16] Force gmac in 10/100/GIGA mode. 2'b00: 100M 2'b01:
                                                     10M 2'b10: GIGA 2'b11: not force mode.                                    */
      __IOM uint32_t forcelink  : 1;            /*!< [18..18] Force gmac in link ok mode. 1'b1: force gmac in linkok.
                                                     1'b0: link status is from MDIO auto-polling.                              */
      __IOM uint32_t forcedfulldup : 1;         /*!< [19..19] Force gmac operates at full duplex mode. 1'b1: force
                                                     gmac in full duplex mode. 1'b0: duplex status is from MDIO
                                                     auto-polling. Not means gmac is in half duplex mode.                      */
      __IOM uint32_t sel_mii    : 1;            /*!< [20..20] Indicates in mii mode.                                           */
      __IOM uint32_t nwcomplete : 1;            /*!< [21..21] Nway complete                                                    */
      __IOM uint32_t fulldupreg : 1;            /*!< [22..22] Indicates Full duplex mode from mdio results.                    */
      __IOM uint32_t sel_rgmii  : 1;            /*!< [23..23] Selects RGMII interface                                          */
      __IOM uint32_t rxpf       : 1;            /*!< [24..24] Pause Flag 1 = Ethernet module is in backoff state
                                                     because a pause packet received. 0 = pause state is clear.                */
      __IOM uint32_t txpf       : 1;            /*!< [25..25] Tx Pause frame 1 = Ethernet module has sent a pause
                                                     packet. 0 = the Ethernet module has sent a timer done packet.             */
      __IOM uint32_t linkb      : 1;            /*!< [26..26] Inverse of Link status. 0 = Link OK. 1 = Link Fail.              */
      __IOM uint32_t speed_10   : 1;            /*!< [27..27] {SPEED_1000, SPEED_10} 00: 100Mbps, 01: 10Mbps                   */
      __IOM uint32_t speed_1000 : 1;            /*!< [28..28] {SPEED_1000, SPEED_10} 10: 1000Mbps, 11: not allowed             */
      __IOM uint32_t txfce      : 1;            /*!< [29..29] Tx Flow Control Enable 1 = tx flow control enabled.
                                                     0 = tx flow control disabled.                                             */
      __IOM uint32_t rxfce      : 1;            /*!< [30..30] RX Flow control Enable: The flow control is enabled
                                                     in full-duplex mode only. Packets are dropped if buffer
                                                     is exhausted. Default is 0. 1 = Rx Flow Control Enabled.
                                                     0 = Rx Flow Control Disabled.                                             */
      __IOM uint32_t force_trxfce : 1;          /*!< [31..31] Force Tx/RX Flow Control: 1 = enabled Flow control
                                                     in the absence of NWAY. 0 = disables Flow control in the
                                                     absence of NWAY.                                                          */
    } ms_b;
  } ;
  
  union {
    __IOM uint32_t miia;                        /*!< (@ 0x0000005C) MII Access Register                                        */
    
    struct {
      __IOM uint32_t data       : 16;           /*!< [15..0] Defines the MII resgister data.                                   */
      __IOM uint32_t regaddr    : 5;            /*!< [20..16] Defines the MII register address.                                */
      __IM  uint32_t            : 1;
      __IOM uint32_t disable_auto_polling : 1;  /*!< [22..22] Disable auto polling feature of mdio operation. 0:
                                                     HW auto polling PCS status. 1: HW does not auto polling
                                                     PCS status.                                                               */
      __IM  uint32_t            : 3;
      __IOM uint32_t phyaddr    : 5;            /*!< [30..26] Defines the Phy address for the MII.                             */
      __IOM uint32_t flag       : 1;            /*!< [31..31] Flag bit, used to identify access to MII register 1:
                                                     Write data to MII register. Turns to 0 automatically upon
                                                     completion of MAC writing to the specified MII register.
                                                     0: Read data from MII register. Turns to 1 automatically
                                                     upon completion of MAC reading the specified MII register.                */
    } miia_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t vlan;                        /*!< (@ 0x00000064) VLAN Register                                              */
    
    struct {
      __IM  uint32_t            : 15;
      __IOM uint32_t tdsc_vlan_type : 1;        /*!< [15..15] 1: tx_vlan_action field in the Tx command descriptor
                                                     is for s-tag. 0: tx_vlan_action field in the Tx command
                                                     descriptor is for c-tag.                                                  */
      __IOM uint32_t stag_pid   : 16;           /*!< [31..16] Set the s-tag protocol identifier.                               */
    } vlan_b;
  } ;
  __IM  uint32_t  RESERVED4[1190];
  
  union {
    __IOM uint32_t txfdp1;                      /*!< (@ 0x00001300) Tx 1st Descriptor Ring Address Register                    */
    
    struct {
      __IOM uint32_t txfdp1     : 32;           /*!< [31..0] Tx 1st priority Descriptor Pointer to the Tx Ring.                */
    } txfdp1_b;
  } ;
  
  union {
    __IOM uint32_t txcdo1;                      /*!< (@ 0x00001304) Tx 1st Current Descriptor Offset Register                  */
    
    struct {
      __IOM uint32_t txcdo1     : 12;           /*!< [11..0] Tx 1st priority current descriptor offset: FDP+CDO =
                                                     current descriptor pointer. CDO increments by 16 bytes
                                                     each time.                                                                */
    } txcdo1_b;
  } ;
  __IM  uint32_t  RESERVED5[58];
  
  union {
    __IOM uint32_t rxfdp1;                      /*!< (@ 0x000013F0) Rx 1st Descriptor Ring Address Register                    */
    
    struct {
      __IOM uint32_t rxfdp1     : 32;           /*!< [31..0] Rx 1st queue Descriptor Pointer to the Rx Ring.                   */
    } rxfdp1_b;
  } ;
  
  union {
    __IOM uint32_t rxrs1cdo1;                   /*!< (@ 0x000013F4) Rx 1st Descriptor Ring Size & 1st Current Descriptor
                                                                    Offset Register                                            */
    
    struct {
      __IOM uint32_t rxringsize_1_h : 4;        /*!< [3..0] This is the bit[11:8] of RxRingSize1.                              */
      __IM  uint32_t            : 4;
      __IOM uint32_t rxringsize_1_l : 8;        /*!< [15..8] This is the total number of descriptors in the Rx descriptor
                                                     rings of 1st queue. (bit[7:0] of RxRingSize1) Act as bit
                                                     mask, eg. RxRingSize [11:0]: 0000_0000_1111: 16 descriptors
                                                     0000_0001_1111: 32 descriptors 0000_0011_1111: 64 descriptors
                                                     0000_0111_1111: 128 descriptors 0000_1111_1111: 256 descriptors
                                                     0001_1111_1111: 512 descriptors 0011_1111_1111: 1024 descriptors
                                                     0111_1111_1111: 2048 descriptors 1111_1111_1111: 4096 descriptors
                                                     Any other value in this register yields undefined results.                */
      __IOM uint32_t rxcdo1     : 12;           /*!< [27..16] Rx Current Descriptor Offset of 1st queue: RxFDP +
                                                     RxCDO = current descriptor pointer. CDO increments by 16
                                                     each time (each increment is one byte).                                   */
    } rxrs1cdo1_b;
  } ;
  __IM  uint32_t  RESERVED6[13];
  
  union {
    __IOM uint32_t rx_pse_des_thres_1_h;        /*!< (@ 0x0000142C) PHY Mode Clock Phase Control Register                      */
    
    struct {
      __IM  uint32_t            : 5;
      __IOM uint32_t phy_mode_clk_phase_chg : 1;/*!< [5..5] Changes the clock phase in the PHY mode                            */
    } rx_pse_des_thres_1_h_b;
  } ;
  
  union {
    __IOM uint32_t etnrxcpu1;                   /*!< (@ 0x00001430) Rx Ring1 Threshold Register                                */
    
    struct {
      __IOM uint32_t etnrxcpu1  : 32;           /*!< [31..0] Rx ring1 threshold settings                                       */
    } etnrxcpu1_b;
  } ;
  
  union {
    __IOM uint32_t io_cmd;                      /*!< (@ 0x00001434) I/O Command Register 0                                     */
    
    struct {
      __IOM uint32_t txfn1st    : 1;            /*!< [0..0] 1st Priority DMA-Ethernet Transmit enable. 1: Enable.
                                                     0: Disable.                                                               */
      __IOM uint32_t txfn2nd    : 1;            /*!< [1..1] 2nd Priority DMA-Ethernet Transmit enable. 1: Enable.
                                                     0: Disable.                                                               */
      __IOM uint32_t txfn3rd    : 1;            /*!< [2..2] 3rd Priority DMA-Ethernet Transmit enable. 1: Enable.
                                                     0: Disable.                                                               */
      __IOM uint32_t txfn4th    : 1;            /*!< [3..3] 4th Priority DMA-Ethernet Transmit enable. 1: Enable.
                                                     0: Disable.                                                               */
      __IOM uint32_t te         : 1;            /*!< [4..4] Tx Enable                                                          */
      __IOM uint32_t re         : 1;            /*!< [5..5] Rx Enable                                                          */
      __IOM uint32_t reg_int_timer_sel : 2;     /*!< [7..6] RXPktTimer, TXPktTimer Unit (TU)                                   */
      __IOM uint32_t rxintmitigation_l : 3;     /*!< [10..8] This sets the number of packets received before RxOK
                                                     interrupt is triggered. 0000: 1 pkt 0001: 4 pkts 0010:
                                                     8 pkts 0011: 12 pkts 0100: 16 pkts 0101: 20 pkts 0110:
                                                     24 pkts 0111: 28 pkts                                                     */
      __IOM uint32_t rxfth      : 2;            /*!< [12..11] Rx Threshold: Specifies the threshold level in the
                                                     Rx FIFO to begin the transmission. When the byte count
                                                     of the data in the Rx FIFO reaches this level, (or the
                                                     FIFO contains at least one complete packet or the end of
                                                     a packet) the Ethernet module will transmit this packet.
                                                     00: 1024 Bytes. 01: 128 Bytes. 10: 256 Bytes. 11: 512 Bytes.              */
      __IOM uint32_t rxpkttimer_l : 3;          /*!< [15..13] Timer to trigger RxOK interrupt before receipt of RxIntMitigation
                                                     pkts. 0000: no timer set 0001~1111: the timer interval
                                                     defining a multiple of TU Ex: 011 = timer interval set
                                                     to 3 x 4 =12 TU This only applies to packets of size larger
                                                     than 128 bytes. Once RxOK is asserted the timer mechanism
                                                     is reinitialized. For ingress pkt which is short than 128B,
                                                     RxOK interrupt asserts after DMA completes.                               */
      __IOM uint32_t txintmitigation_l : 3;     /*!< [18..16] This sets the number of packets received before TxOK
                                                     interrupt is triggered. 0000: 1 pkt 0001: 4 pkts 0010:
                                                     8 pkts 0011: 12 pkts 0100: 16 pkts 0101: 20 pkts 0110:
                                                     24 pkts 0111: 28 pkts                                                     */
      __IOM uint32_t tsh        : 2;            /*!< [20..19] Tx Threshold: Specifies the threshold level in the
                                                     Tx FIFO to begin the transmission. When the byte count
                                                     of the data in the Tx FIFO reaches this level, (or the
                                                     FIFO contains at least one complete packet or the end of
                                                     a packet) the Ethernet module will transmit this packet.
                                                     00: 128 Bytes. 01: 256 Bytes. 10: 512 Bytes. 11: 1024 Bytes.              */
      __IOM uint32_t rxintmitigation_h : 1;     /*!< [21..21] See bit[19:8]                                                    */
      __IOM uint32_t rxpkttimer_h : 1;          /*!< [22..22] See bit[15:13]                                                   */
      __IOM uint32_t txintmitigation_h : 1;     /*!< [23..23] See bit[18:16]                                                   */
      __IOM uint32_t txpkttimer : 4;            /*!< [27..24] Timer to trigger TxOK interrupt before receipt of TxIntMitigation
                                                     pkts. 0000: no timer set 0001~1111: the timer interval
                                                     defining a multiple of TU Ex: 0011 = timer interval sets
                                                     to 3 x 4 =12 TU Once TxOK is asserted the timer mechanism
                                                     is reinitialized.                                                         */
      __IOM uint32_t en_early_tx : 1;           /*!< [28..28] 0: disable, 1: enable. Disable early tx by GAMC while
                                                     tx command descriptor.IPCS, UDPCS or TCPCS are set to high.               */
      __IOM uint32_t max_dma_sel_h : 1;         /*!< [29..29] See bit[31]                                                      */
      __IOM uint32_t shortdesformat : 1;        /*!< [30..30] Short descriptor format 1: tx/rx descriptor will use
                                                     old format (4 x 32-bit each item) 0: use new format to
                                                     support sram mapping.                                                     */
      __IOM uint32_t max_dma_sel_l : 1;         /*!< [31..31] Select the dma burst size on bus. 00: 16 DW (1DW =
                                                     4 Bytes) 01: 32 DW 10: 64 DW 11: 128DW.                                   */
    } io_cmd_b;
  } ;
  
  union {
    __IOM uint32_t io_cmd1;                     /*!< (@ 0x00001438) I/O Command Register 1                                     */
    
    struct {
      __IM  uint32_t            : 8;
      __IOM uint32_t txfn5th    : 1;            /*!< [8..8] 5th Priority DMA-Ethernet Transmit enable. 1: Enable.
                                                     0: Disable.                                                               */
      __IM  uint32_t            : 5;
      __IOM uint32_t Tx_hl_pri_se : 2;          /*!< [15..14] 2'b00: TX ring uses strict priority. 2'b01: TX ring
                                                     uses high and low queue priority. Inside high queue, tx
                                                     ring is round robin. Inside low queue, tx ring is round
                                                     robin. Strict priority is used for high and low queue selection.
                                                     2'b10 and 2'b11: Reserved.                                                */
      __IOM uint32_t rxring1    : 1;            /*!< [16..16] Ethernet-DMA Receive Ring1 enable. 1: Enable. 0: Disable.        */
      __IOM uint32_t rxring2    : 1;            /*!< [17..17] Ethernet-DMA Receive Ring2 enable. 1: Enable. 0: Disable.        */
      __IOM uint32_t rxring3    : 1;            /*!< [18..18] Ethernet-DMA Receive Ring3 enable. 1: Enable. 0: Disable.        */
      __IOM uint32_t rxring4    : 1;            /*!< [19..19] Ethernet-DMA Receive Ring4 enable. 1: Enable. 0: Disable.        */
      __IOM uint32_t rxring5    : 1;            /*!< [20..20] Ethernet-DMA Receive Ring5 enable. 1: Enable. 0: Disable.        */
      __IOM uint32_t rxring6    : 1;            /*!< [21..21] Ethernet-DMA Receive Ring6 enable. 1: Enable. 0: Disable.        */
      __IM  uint32_t            : 2;
      __IOM uint32_t en_1gb     : 1;            /*!< [24..24] 1: support 1GB addressing in lx master bus. 0: Not
                                                     support.                                                                  */
      __IOM uint32_t en_rx_mring : 1;           /*!< [25..25] Enable rx multiple rings. 1: rx using multiple rings.
                                                     max: 6 rings (ring1 to ring6). 0: rx using single ring
                                                     (ring1 only).                                                             */
      __IOM uint32_t rxokint_msk_128b : 1;      /*!< [26..26] 1: For ingress pkt which is short than 128B, RxOK interrupt
                                                     asserts after DMA completes (compatible issue). 0: For
                                                     ingress pkt which is short than 128B, RxOK interrupt does
                                                     not assert after DMA completes.                                           */
      __IOM uint32_t en_precise_dma : 1;        /*!< [27..27] 0: disable precise DMA transfer. 1: enable precise
                                                     DMA transfer.                                                             */
      __IOM uint32_t dsc_format_extra : 3;      /*!< [30..28] Extra descriptor format. SW should set this field before
                                                     set io_cmd.te or io_cmd.re to 1.                                          */
    } io_cmd1_b;
  } ;
} ETHERNET_Type;                                /*!< Size = 5180 (0x143c)                                                      */



/* =========================================================================================================================== */
/* ================                                         SDIO_HOST                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief SDIO Host - for SD memory card storage (SDIO_HOST)
  */

typedef struct {                                /*!< (@ 0x40058000) SDIO_HOST Structure                                        */
  __IM  uint32_t  RESERVED[256];
  
  union {
    __IOM uint32_t sram_ctl;                    /*!< (@ 0x00000400) SRAM Control Register                                      */
    
    struct {
      __IOM uint32_t mem_region : 4;            /*!< [3..0] Set this bit to enable buffer SRAM direct access mode.             */
      __IOM uint32_t access_en  : 1;            /*!< [4..4] Set this bit to enable buffer SRAM direct access mode.             */
      __IOM uint32_t map_sel    : 1;            /*!< [5..5] 0: R-Bus = x01020304 => to flash 01, 02, 03, 04; 1: R-Bus
                                                     = x01020304 => to flash 04, 03, 02, 01                                    */
      __IOM uint32_t lx_burst_size : 2;         /*!< [7..6] Set the Lexra burst size. 0: 64 Bytes; 1: 128 Bytes;
                                                     2: 256 Bytes; 3: 128 Bytes                                                */
    } sram_ctl_b;
  } ;
  
  union {
    __IOM uint32_t dma_ctl1;                    /*!< (@ 0x00000404) DMA Control Register 1                                     */
    
    struct {
      __IOM uint32_t dram_sa    : 28;           /*!< [27..0] Dram start address for DMA transfer. This information
                                                     will be map to addcmd. (8 Bytes Unit, 1 means 8B)                         */
    } dma_ctl1_b;
  } ;
  
  union {
    __IOM uint32_t dma_ctl2;                    /*!< (@ 0x00000408) DMA Control Register 2                                     */
    
    struct {
      __IOM uint32_t dma_len    : 16;           /*!< [15..0] Transfer length for DMA transfer between DMA buffer
                                                     and DDR. (512B Unit, 1 means 512B)                                        */
    } dma_ctl2_b;
  } ;
  
  union {
    __IOM uint32_t dma_ctl3;                    /*!< (@ 0x0000040C) DMA Control Register 3                                     */
    
    struct {
      __IOM uint32_t dma_xfer   : 1;            /*!< [0..0] Set this bit to transfer data between DRAM and DMA buffer.
                                                     Direction must be set at next bit. The transfer length
                                                     is reference to DMA_CTL2[15:0]. This bit will be auto clear
                                                     when transfer done.                                                       */
      __IOM uint32_t ddr_wr     : 1;            /*!< [1..1] 1: Move data from DMA buffer to DDR; 0: Move data from
                                                     DDR to DMA Buffer.                                                        */
      __IM  uint32_t            : 2;
      __IOM uint32_t rsp17_sel  : 1;            /*!< [4..4] For response is R2 case, reponse will transfer by dma
                                                     and not store in register. 1: dma count to 16byte and send
                                                     sb1_req; 0: normal case.                                                  */
      __IOM uint32_t dat64_sel  : 1;            /*!< [5..5] For CMD6 case, read data length is 64byte (less than
                                                     256 byte) 1: dma count to 64byte and send sb1_req; 0: normal
                                                     case.                                                                     */
    } dma_ctl3_b;
  } ;
  
  union {
    __IOM uint32_t sys_low_pwr;                 /*!< (@ 0x00000410) Low Power Control Register                                 */
    
    struct {
      __IOM uint32_t dma_sram_rdy_num : 4;      /*!< [3..0] DMA SRAM ready cycle (leave sleep mode) (N+1) * clk_sys
                                                     period                                                                    */
      __IOM uint32_t dma_sram_lp_ena : 1;       /*!< [4..4] DMA SRAM low power enable                                          */
      __IM  uint32_t            : 1;
      __IOM uint32_t sys_clk_gate_ena : 1;      /*!< [6..6] DMA clk_sys gating enable                                          */
    } sys_low_pwr_b;
  } ;
  __IM  uint32_t  RESERVED1[4];
  
  union {
    __IOM uint32_t sd_isr;                      /*!< (@ 0x00000424) SD Interrupt Status Register                               */
    
    struct {
      __IOM uint32_t write_data : 1;            /*!< [0..0] 1 to set, 0 to clear bit with 1.                                   */
      __IOM uint32_t int1       : 1;            /*!< [1..1] SD Int1. Card End.                                                 */
      __IOM uint32_t int2       : 1;            /*!< [2..2] SD Int2. Card Error.                                               */
      __IM  uint32_t            : 1;
      __IOM uint32_t int4       : 1;            /*!< [4..4] SD Int4. DMA transfer done INT.                                    */
    } sd_isr_b;
  } ;
  
  union {
    __IOM uint32_t sd_isren;                    /*!< (@ 0x00000428) SD Interrupt Enable Register                               */
    
    struct {
      __IOM uint32_t write_data : 1;            /*!< [0..0] 1 to set, 0 to clear bit with 1.                                   */
      __IOM uint32_t int1en     : 1;            /*!< [1..1] SD Int1 Enable Card End INT Enable.                                */
      __IOM uint32_t int2en     : 1;            /*!< [2..2] SD Int2 Enable Card Error INT Enable.                              */
      __IM  uint32_t            : 1;
      __IOM uint32_t int4en     : 1;            /*!< [4..4] SD Int4 Enable dma_clr INT Enable.                                 */
    } sd_isren_b;
  } ;
  __IM  uint32_t  RESERVED2[18];
  
  union {
    __IOM uint32_t pad_ctl;                     /*!< (@ 0x00000474) Pad Control Register                                       */
    
    struct {
      __IOM uint32_t tune3318   : 1;            /*!< [0..0] Pad select 3.3v or 1.8v. 1: 3.3v; 0: 1.8v                          */
    } pad_ctl_b;
  } ;
  
  union {
    __IOM uint32_t ckgen_ctl;                   /*!< (@ 0x00000478) Clock Generation Control Register                          */
    
    struct {
      __IOM uint32_t clk_div    : 3;            /*!< [2..0] 000: div1; 001: div2; 010: div4; 011: div8                         */
      __IM  uint32_t            : 1;
      __IOM uint32_t crc_clk_src : 2;           /*!< [5..4] 00: ssc_clk; 01: ssc_clk_vp0; 10: ssc_clk_vp1                      */
      __IM  uint32_t            : 2;
      __IOM uint32_t sd30_push_clk_src : 2;     /*!< [9..8] 00: ssc_clk; 01: ssc_clk_vp0; 10: ssc_clk_vp1                      */
      __IM  uint32_t            : 2;
      __IOM uint32_t sd30_sample_clk_src : 2;   /*!< [13..12] 00: ssc_clk; 01: ssc_clk_vp0; 10: ssc_clk_vp1                    */
      __IM  uint32_t            : 2;
      __IOM uint32_t crc_clk_change : 1;        /*!< [16..16] 0: from crc_clk_src; 1: clk4M                                    */
      __IOM uint32_t sd30_push_change : 1;      /*!< [17..17] 0: from sd30_push_clk_src; 1: clk4M                              */
      __IOM uint32_t sd30_sample_change : 1;    /*!< [18..18] 0: from sd30_sample_clk_src; 1: clk4M                            */
    } ckgen_ctl_b;
  } ;
  __IM  uint32_t  RESERVED3[33];
  __IM  uint16_t  RESERVED4;
  
  union {
    __IOM uint8_t card_drive_sel;               /*!< (@ 0x00000502) Card Driving Selection Register                            */
    
    struct {
      __IOM uint8_t cf_drive    : 2;            /*!< [1..0] CF Interface Drive. 00: 4mA; 01: 8mA; 10: 12mA; 11: 12mA           */
      __IOM uint8_t xd_drive    : 2;            /*!< [3..2] XD Interface Drive. 00: 4mA; 01: 8mA; 10: 12mA; 11: 12mA           */
      __IOM uint8_t sd_drive    : 2;            /*!< [5..4] SD DAT7~4 Interface Drive. 00: 4mA; 01: 8mA; 10: 12mA;
                                                     11: 12mA                                                                  */
      __IOM uint8_t ms_drive    : 2;            /*!< [7..6] MS Interface Drive. 00: 4mA; 01: 8mA; 10: 12mA; 11: 12mA           */
    } card_drive_sel_b;
  } ;
  
  union {
    __IOM uint8_t card_stop;                    /*!< (@ 0x00000503) Stop Transfer Register                                     */
    
    struct {
      __IOM uint8_t cf_module   : 1;            /*!< [0..0] Target module is CF/MD card module. If set this bit the
                                                     transfer will be stop and the state machine of transfer
                                                     will return idle state.                                                   */
      __IOM uint8_t sm_module   : 1;            /*!< [1..1] Target module is SM/XD card module. If set this bit the
                                                     transfer will be stop and the state machine of transfer
                                                     will return idle state.                                                   */
      __IOM uint8_t sd_module   : 1;            /*!< [2..2] Target module is SD/MMC card module (SD). If set this
                                                     bit the transfer will be stop and the state machine of
                                                     transfer will return idle state.                                          */
      __IOM uint8_t ms_module   : 1;            /*!< [3..3] Target module is MS/MS-Pro/HG card module (MS). If set
                                                     this bit the transfer will be stop and the state machine
                                                     of transfer will return idle state.                                       */
      __IOM uint8_t sd2_module  : 1;            /*!< [4..4] Target module is SD/MMC card module (SD2). If set this
                                                     bit the transfer will be stop and the state machine of
                                                     transfer will return idle state.                                          */
      __IOM uint8_t ms2_module  : 1;            /*!< [5..5] Target module is MS/MS-Pro/HG card module (MS2). If set
                                                     this bit the transfer will be stop and the state machine
                                                     of transfer will return idle state.                                       */
    } card_stop_b;
  } ;
  __IM  uint32_t  RESERVED5[2];
  __IM  uint16_t  RESERVED6;
  
  union {
    __IOM uint8_t card_select;                  /*!< (@ 0x0000050E) Card Type Select Register                                  */
    
    struct {
      __IOM uint8_t card_sel    : 3;            /*!< [2..0] Card Select. Specify the current active card module.
                                                     000: CF module 001: XD module 010: SD module 011: MS module
                                                     100: I2C module 101: Reserved 110: SD2 module 111: MS2
                                                     module                                                                    */
    } card_select_b;
  } ;
  __IOM uint8_t   dummy1;                       /*!< (@ 0x0000050F) Dummy Register 1                                           */
  __IM  uint32_t  RESERVED7[3];
  __IM  uint16_t  RESERVED8;
  __IM  uint8_t   RESERVED9;
  
  union {
    __IOM uint8_t card_exist;                   /*!< (@ 0x0000051F) Card Detection Register                                    */
    
    struct {
      __IOM uint8_t cf_exist    : 1;            /*!< [0..0] CF Existence. If this bit is set it means CF/MD card
                                                     is in its socket.                                                         */
      __IOM uint8_t sm_exist    : 1;            /*!< [1..1] SM Existence. If this bit is set it means SM card is
                                                     in its socket.                                                            */
      __IOM uint8_t sd_exist    : 1;            /*!< [2..2] SD Existence. If this bit is set it means SD/MMC card
                                                     is in its socket.                                                         */
      __IOM uint8_t ms_exist    : 1;            /*!< [3..3] MS Existence. If this bit is set it means MS/MS-pro card
                                                     is in its socket.                                                         */
      __IOM uint8_t xd_exist    : 1;            /*!< [4..4] XD Existence. If this bit is set it means XD card is
                                                     in its socket.                                                            */
      __IOM uint8_t sd_wp       : 1;            /*!< [5..5] SD Write Protect. If this bit is set it means SD card
                                                     is mechanical write protected.                                            */
      __IOM uint8_t xd_wp       : 1;            /*!< [6..6] XD_WP Input. If the XD_WP pin is configure as input,
                                                     this bit reflect the level of XD_WP signal directly.                      */
    } card_exist_b;
  } ;
  
  union {
    __IOM uint8_t card_int_en;                  /*!< (@ 0x00000520) Card Interrupt Enable Register                             */
    
    struct {
      __IOM uint8_t cf_int_en   : 1;            /*!< [0..0] CF Card Interrupt Enable. If this bit is set it enables
                                                     the interrupt of CF card                                                  */
      __IOM uint8_t sm_int_en   : 1;            /*!< [1..1] SM Card Interrupt Enable. If this bit is set it enables
                                                     the interrupt of SM card                                                  */
      __IOM uint8_t sd_int_en   : 1;            /*!< [2..2] SD/MMC Interrupt Enable. If this bit is set it enables
                                                     the interrupt of SD/MMC card                                              */
      __IOM uint8_t ms_int_en   : 1;            /*!< [3..3] MS/MS-pro/HG card Interrupt Enable. If this bit is set
                                                     it enables the interrupt of MS/MS-pro card                                */
      __IOM uint8_t xd_int_en   : 1;            /*!< [4..4] XD Card Interrupt Enable. If this bit is set it enables
                                                     the interrupt of XD card                                                  */
      __IOM uint8_t sd2_int_en  : 1;            /*!< [5..5] SD/MMC (SD2) Interrupt Enable. If this bit is set it
                                                     enables the interrupt of SD/MMC card                                      */
      __IOM uint8_t ms2_int_en  : 1;            /*!< [6..6] MS/MS-pro/HG (MS2) card Interrupt Enable. If this bit
                                                     is set it enables the interrupt of MS/MS-pro card                         */
      __IOM uint8_t gpio_int_en : 1;            /*!< [7..7] GPIO[0] Interrupt Enable. If this bit is set it enables
                                                     the interrupt of GPIO0                                                    */
    } card_int_en_b;
  } ;
  
  union {
    __IOM uint8_t card_int_pend;                /*!< (@ 0x00000521) Card Interrupt Status Register                             */
    
    struct {
      __IOM uint8_t cf_int_pend : 1;            /*!< [0..0] CF Card Interrupt Pending. If this bit is set it means
                                                     the interrupt of CF card is pending and write '1' to this
                                                     bit to clear the interrupt flag to '0'                                    */
      __IOM uint8_t sm_int_pend : 1;            /*!< [1..1] SM Card Interrupt Pending. If this bit is set it means
                                                     the interrupt of SM card is pending and write '1' to this
                                                     bit to clear the interrupt flag to '0'                                    */
      __IOM uint8_t sd_int_pend : 1;            /*!< [2..2] SD/MMC Interrupt Pending. If this bit is set it means
                                                     the interrupt of SD/MMC card is pending and write '1' to
                                                     this bit to clear the interrupt flag to '0'                               */
      __IOM uint8_t ms_int_pend : 1;            /*!< [3..3] MS/MS-pro/HG card Interrupt Pending. If this bit is set
                                                     it means the interrupt of MS/MS-pro card is pending and
                                                     write '1' to this bit to clear the interrupt flag to '0'                  */
      __IOM uint8_t xd_int_pend : 1;            /*!< [4..4] XD Card Interrupt Pending. If this bit is set it means
                                                     the interrupt of XD card is pending and write '1' to this
                                                     bit to clear the interrupt flag to '0'                                    */
      __IOM uint8_t sd2_int_pend : 1;           /*!< [5..5] SD/MMC (SD2) Interrupt Pending. If this bit is set it
                                                     means the interrupt of SD/MMC card is pending and write
                                                     '1' to this bit to clear the interrupt flag to '0'                        */
      __IOM uint8_t ms2_int_pend : 1;           /*!< [6..6] MS/MS-pro/HG (MS2) card Interrupt Pending. If this bit
                                                     is set it means the interrupt of MS/MS-pro card is pending
                                                     and write '1' to this bit to clear the interrupt flag to
                                                     '0'                                                                       */
      __IOM uint8_t gpio_int_pend : 1;          /*!< [7..7] GPIO[0] Interrupt Pending. If this bit is set it means
                                                     the interrupt of GPIO0 is pending and write '1' to this
                                                     bit to clear the interrupt flag to '0'                                    */
    } card_int_pend_b;
  } ;
  __IM  uint16_t  RESERVED10;
  __IM  uint32_t  RESERVED11;
  __IM  uint8_t   RESERVED12;
  
  union {
    __IOM uint8_t card_clk_en_ctl;              /*!< (@ 0x00000529) Card Clock Enable Control Register                         */
    
    struct {
      __IOM uint8_t cf_clk_en   : 1;            /*!< [0..0] CF Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t xd_clk_en   : 1;            /*!< [1..1] XD Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t sd_clk_en   : 1;            /*!< [2..2] SD Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t ms_clk_en   : 1;            /*!< [3..3] MS Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t sd2_clk_en  : 1;            /*!< [4..4] SD2 Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t ms2_clk_en  : 1;            /*!< [5..5] MS2 Card Module Clock Enable Control. Disable clock can
                                                     save power. 0: Disable; 1: Enable                                         */
      __IOM uint8_t sw_clk_mode : 1;            /*!< [6..6] Switch Clock Mode. Clk_en use FW configuration of HW
                                                     setting. 0: Clk_en use FW configure 1: Clk_en use HW setting              */
      __IOM uint8_t auto_cbw    : 1;            /*!< [7..7] Auto CBW Mode. Used for card select option. 0: Card select
                                                     is configured by FW. 1: Card select is configured by HW.                  */
    } card_clk_en_ctl_b;
  } ;
  __IM  uint16_t  RESERVED13;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint8_t clk_pad_drive;                /*!< (@ 0x00000530) Clock Pad Driving Register                                 */
    
    struct {
      __IOM uint8_t nmos_drive  : 3;            /*!< [2..0] SD_CLK PAD NMOS drive select 3V3: 1V8: 000: x 10.1 x
                                                     1.93 001: x 13.5 x 3.85 010,100: x 16.9 x 5.78 011,101:
                                                     x 20.2 x 7.73 110: x 23.5 x 9.65 111: x 26.8 x 11.5                       */
      __IOM uint8_t pmos_drive  : 3;            /*!< [5..3] SD_CLK PAD PMOS drive select 3V3: 1V8: 000: x 7,07 x
                                                     2.27 001: x 14.2 x 4.61 010,100: x 21 x 6.68 011,101: x
                                                     27.9 x 9.14 110: x 34.9 x 11.5 111: x 42.4 x 13.8                         */
    } clk_pad_drive_b;
  } ;
  
  union {
    __IOM uint8_t cmd_pad_drive;                /*!< (@ 0x00000531) Command Pad Driving Register                               */
    
    struct {
      __IOM uint8_t nmos_drive  : 3;            /*!< [2..0] SD_CMD PAD NMOS drive select 3V3: 1V8: 000: x 10.1 x
                                                     1.93 001: x 13.5 x 3.85 010,100: x 16.9 x 5.78 011,101:
                                                     x 20.2 x 7.73 110: x 23.5 x 9.65 111: x 26.8 x 11.5                       */
      __IOM uint8_t pmos_drive  : 3;            /*!< [5..3] SD_CMD PAD PMOS drive select 3V3: 1V8: 000: x 7,07 x
                                                     2.27 001: x 14.2 x 4.61 010,100: x 21 x 6.68 011,101: x
                                                     27.9 x 9.14 110: x 34.9 x 11.5 111: x 42.4 x 13.8                         */
    } cmd_pad_drive_b;
  } ;
  
  union {
    __IOM uint8_t dat_pad_drive;                /*!< (@ 0x00000532) Data Pad Driving Register                                  */
    
    struct {
      __IOM uint8_t nmos_drive  : 3;            /*!< [2..0] SD_DAT[3:0] PAD NMOS drive select 3V3: 1V8: 000: x 10.1
                                                     x 1.93 001: x 13.5 x 3.85 010,100: x 16.9 x 5.78 011,101:
                                                     x 20.2 x 7.73 110: x 23.5 x 9.65 111: x 26.8 x 11.5                       */
      __IOM uint8_t pmos_drive  : 3;            /*!< [5..3] SD_DAT[3:0] PAD PMOS drive select 3V3: 1V8: 000: x 7,07
                                                     x 2.27 001: x 14.2 x 4.61 010,100: x 21 x 6.68 011,101:
                                                     x 27.9 x 9.14 110: x 34.9 x 11.5 111: x 42.4 x 13.8                       */
    } dat_pad_drive_b;
  } ;
  __IM  uint8_t   RESERVED15;
  __IM  uint32_t  RESERVED16[19];
  
  union {
    __IOM uint8_t sd_config1;                   /*!< (@ 0x00000580) SD Configuration Register 1                                */
    
    struct {
      __IOM uint8_t bus_width   : 2;            /*!< [1..0] 00: 1-bit bus 01: 4-bit bus 10: 8-bit bus 11: Reserved             */
      __IOM uint8_t mode_sel    : 2;            /*!< [3..2] 00: SD20 mode (single data rate; internal clock frequency
                                                     is 2 times as SD_CLK) 01: DDR mode (double data rate; internal
                                                     clock frequency is 2 times as SD_CLK) 10: SD30 mode (single
                                                     data rate; internal clock frequency is the same as SD_CLK;
                                                     sampling point turning can only be used in this mode) 11:
                                                     Reserved Note: When access SDR Card that needs to do sampling
                                                     turning, we must select SD30_mode; when access SDR Card
                                                     that needn't sampling turning, both SD20_mode and SD30_mode
                                                     is available.                                                             */
      __IOM uint8_t sd30_async_fifo_rst : 1;    /*!< [4..4] When SD30_mode is asserted, the input CMD/DAT will be
                                                     latched by an asynchronous FIFO. The write clock of FIFO
                                                     is sample clock; the read clock of FIFO is internal clock.
                                                     Write this bit to 1'b0 to reset write/read pointer of FIFO
                                                     after the frequency/phase of sample clock or internal clock
                                                     is changed.                                                               */
      __IM  uint8_t             : 1;
      __IOM uint8_t clk_div     : 1;            /*!< [6..6] Clock Divider (only available when initial mode is set)
                                                     0: SDCLK is divided by 128 1: SDCLK is divided by 256                     */
      __IOM uint8_t initial_mode : 1;           /*!< [7..7] Initial Mode (can not be used in SD30 mode) This bit
                                                     is used to control whether the SD clock will be divided
                                                     by clock divider 0: The SD clock can not be divided 1:
                                                     The SD clock will de divided by the value of Clock Divider                */
    } sd_config1_b;
  } ;
  
  union {
    __IOM uint8_t sd_config2;                   /*!< (@ 0x00000581) SD Configuration Register 2                                */
    
    struct {
      __IOM uint8_t rsp_type    : 2;            /*!< [1..0] Response Type Configure. 00: No response 01: 6-byte response
                                                     10: 17-byte response 11: Reserved                                         */
      __IOM uint8_t crc7_chk    : 1;            /*!< [2..2] CRC7 Check Enable. 0: Check CRC7 1: Not check CRC7                 */
      __IOM uint8_t wait_busy_end : 1;          /*!< [3..3] Wait busy End Enable If this bit is set, hardware will
                                                     wait (with SD_CLK continually toggling) till SD card is
                                                     ready (SD_DAT0 is 1). This bit is only available when HW
                                                     executes SEND_CMD_GET_RSP command code 0: .Not wait busy
                                                     end; HW will stop toggle SD clock after the command/response
                                                     transfer is completed, not concern about whether the SD_DAT0
                                                     is 1b or not 1: Wait busy end; HW will continue to toggle
                                                     SD clock if SD_DAT0 is 0b                                                 */
      __IOM uint8_t ignore_crc_sts_err : 1;     /*!< [4..4] Ignore Write CRC Error Enable. Set this bit to ignore
                                                     the write error. 0: Check whether CRC status returned by
                                                     card is correct 1: Not check whether CRC status returned
                                                     by card is correct                                                        */
      __IOM uint8_t wait_crc_sts_timeout : 1;   /*!< [5..5] Wait Write CRC Status Time Out Enable If this bit is
                                                     set, HW will check whether the write CRC status is sent
                                                     by card in time.(In SD3.0 spec, card should send the CRC
                                                     status within 8 clocks, HW will wait 16 clocks actually)
                                                     0: HW will Check whether the write CRC status is time-out
                                                     1: HW will Not Check whether the write CRC status is time-out             */
      __IOM uint8_t crc16_chk   : 1;            /*!< [6..6] CRC16 Check Enable. 0: Check CRC16 1: Not check CRC16              */
      __IOM uint8_t crc7_cal    : 1;            /*!< [7..7] CRC7 Calculation Enable. 0: Calculate CRC7 1: No calculation       */
    } sd_config2_b;
  } ;
  
  union {
    __IOM uint8_t sd_config3;                   /*!< (@ 0x00000582) SD Configuration Register 3                                */
    
    struct {
      __IOM uint8_t rsp_timeout_en : 1;         /*!< [0..0] SD CMD Response Time Out Enable. If this bit is set,
                                                     HW will not check whether card's response to command is
                                                     time-out. It is considered to time-out if there is no SD
                                                     command response within 80 periods of SD_CLK after the
                                                     end bit of command is on the bus. 0: Not check whether
                                                     the response to command is time-out 1: Check whether the
                                                     response to command is time-out                                           */
      __IOM uint8_t addr_mode   : 1;            /*!< [1..1] Address mode. 0: sector address mode SD start data address
                                                     set in SD read/write command argument(CMD18/CMD25) equal
                                                     to (the start sector address) which is set in SCSI command
                                                     read10/write10; 1: byte mode SD start data address set
                                                     in SD read/write command argument(CMD18/CMD25) equal to
                                                     (the start sector address <<9)                                            */
      __IOM uint8_t rsp_chk     : 1;            /*!< [2..2] SD CMD Response Check Enable When in Random auto mode,
                                                     If this bit is set, HW will check whether card's response
                                                     is received correctly or not. When not in random auto mode,
                                                     this bit is useless. 0: No check whether the response of
                                                     command is correct 1: Check whether the response to command
                                                     is correct                                                                */
      __IOM uint8_t sd20_clk_stop : 1;          /*!< [3..3] SD20 Clock Stop After Data Transfer Over Enable. (Default
                                                     Disable) In order to conform to eMMC spec(NAC minimum value
                                                     is 2 SD Clock cycle), when this bit is 1'b1 and data transfer
                                                     is over(Sector Count is 0), SD clock(SD20 mode) is stopped
                                                     immediately. 0: Disable 1: Enable                                         */
      __IOM uint8_t sd30_clk_stop : 1;          /*!< [4..4] SD30 Clock Stop After Data Transfer Over Enable. (Default
                                                     Disable) In order to conform to eMMC spec(NAC minimum value
                                                     is 2 SD Clock cycle), when this bit is 1'b1 and data transfer
                                                     is over(Sector Count is 0), SD clock(SD30 SDR and DDR mode)
                                                     is stopped immediately. 0: Disable 1: Enable                              */
      __IOM uint8_t wait_card_idle : 1;         /*!< [5..5] Data Phase Wait Card busy Enable. When this bit is set
                                                     , wait until SD card not busy, then set sd_end. 0: No wait
                                                     SD card not busy, set sd_end immediately when data transfer
                                                     is over 1: Wait until SD card is not busy, then set sd_end                */
      __IOM uint8_t cmd_start_wait_card_idle : 1;/*!< [6..6] CMD Start Wait No Card busy. When this bit is set , no
                                                     wait card busy and send command immediately. 0: Wait until
                                                     card is not busy, then send the pending command 1: No wait
                                                     card busy and send command immediately                                    */
      __IOM uint8_t stop_cmd_start_wait_card_idle : 1;/*!< [7..7] STOP CMD Start No Wait Card busy. This bit is only valid
                                                     when the SD card controller is auto in random auto mode.
                                                     In random auto mode, SD card controller will auto send
                                                     stop cmd(CMD12) after read/write cmd(cmd18/cmd25), this
                                                     bit control whether HW wait busy end before send CMD12
                                                     When this bit is set , no wait card busy and send stop
                                                     command (CMD12) immediately. 0: Wait until card is not
                                                     busy, then send the stop command (CMD12) 1: No wait card
                                                     busy and send stop command immediately                                    */
    } sd_config3_b;
  } ;
  
  union {
    __IOM uint8_t sd_status1;                   /*!< (@ 0x00000583) SD Status Register 1                                       */
    
    struct {
      __IOM uint8_t tune_patrn_err : 1;         /*!< [0..0] SD Tuning Pattern Compare Error. This bit will be set
                                                     to 1'b1, if the tuning data sampled by HW is not correct.                 */
      __IOM uint8_t crc_sts_timeout_err : 1;    /*!< [1..1] Get Write CRC Status Time-out Error This bit will be
                                                     set to 1'b1, if SD card doesn't return write CRC status
                                                     bits to host within 8 SD_CLK cycles after the end bit of
                                                     data packet is on the bus (actually, HW will wait 16 clocks).             */
      __IOM uint8_t crc_sts_val : 3;            /*!< [4..2] Status Of Write CRC Status. This field reflects write
                                                     error bits returned from SD card. When card check CRC error,
                                                     it sends back CRC status (101); when card check CRC no
                                                     error, it sends back CRC status (010); when flash programming
                                                     error, CRC status read (111).                                             */
      __IOM uint8_t crc_sts_err : 1;            /*!< [5..5] Write CRC Error. This bit will be set to 1'b1, if the
                                                     write CRC status bits are not equal to 3'b010. (this means
                                                     Card detected CRC16 error in the data it received from
                                                     host).                                                                    */
      __IOM uint8_t crc16_err   : 1;            /*!< [6..6] CRC16 Error. This bit will be set to 1'b1, if there is
                                                     CRC16 check error in the data from SD card.                               */
      __IOM uint8_t crc7_err    : 1;            /*!< [7..7] CRC7 Error. This bit will be set to 1'b1, if there is
                                                     CRC7 check error in the response from SD card.                            */
    } sd_status1_b;
  } ;
  
  union {
    __IOM uint8_t sd_status2;                   /*!< (@ 0x00000584) SD Status Register 2                                       */
    
    struct {
      __IOM uint8_t rsp_timeout_err : 1;        /*!< [0..0] SD CMD Response Timeout Error. This bit will be set to
                                                     1'b1, if there is no response within 80 periods of SD_CLK
                                                     after the end bit of command is on the bus.                               */
      __IOM uint8_t rsp_invalid : 1;            /*!< [1..1] SD CMD Response Invalid. If SD_CONFIGURE3 bit[2] is set,
                                                     this bit will reflect when the response is correct or not.
                                                     If this bit is set, sd_end and sd_error (SD_TRANSFER bit[6]
                                                     and bit[4]) will also be set 0: The response of command
                                                     is correct 1: The response to command is not correct                      */
      __IOM uint8_t cbw_state   : 4;            /*!< [5..2] CBW State Machine.                                                 */
    } sd_status2_b;
  } ;
  
  union {
    __IOM uint8_t sd_bus_status;                /*!< (@ 0x00000585) SD Bus Status Register                                     */
    
    struct {
      __IOM uint8_t cmd         : 1;            /*!< [0..0] This bit reflect the level of pin SD_CMD.                          */
      __IOM uint8_t dat3_0      : 4;            /*!< [4..1] This bit reflect the level of pin SD_DAT3~SD_DAT0.                 */
      __IM  uint8_t             : 1;
      __IOM uint8_t stop_sdclk_when_no_xfer : 1;/*!< [6..6] Stop SD_CLK toggling when no cmd/data transfer (ignore
                                                     the level of SDDAT0)                                                      */
      __IOM uint8_t sdclk_toggle : 1;           /*!< [7..7] SD_CLK Toggle Enable. If this bit is set, host will generate
                                                     SDCLK toggle signal even when there is no signal transaction
                                                     on the CMD/DAT bus                                                        */
    } sd_bus_status_b;
  } ;
  __IM  uint16_t  RESERVED17;
  __IM  uint8_t   RESERVED18;
  
  union {
    __IOM uint8_t sd_cmd0;                      /*!< (@ 0x00000589) SD Command Register 0                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[47:40] or Response Data[47:40].                            */
    } sd_cmd0_b;
  } ;
  
  union {
    __IOM uint8_t sd_cmd1;                      /*!< (@ 0x0000058A) SD Command Register 1                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[39:32] or Response Data[39:32].                            */
    } sd_cmd1_b;
  } ;
  
  union {
    __IOM uint8_t sd_cmd2;                      /*!< (@ 0x0000058B) SD Command Register 2                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[31:24] or Response Data[31:24].                            */
    } sd_cmd2_b;
  } ;
  
  union {
    __IOM uint8_t sd_cmd3;                      /*!< (@ 0x0000058C) SD Command Register 3                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[23:16] or Response Data[23:16].                            */
    } sd_cmd3_b;
  } ;
  
  union {
    __IOM uint8_t sd_cmd4;                      /*!< (@ 0x0000058D) SD Command Register 4                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[15:8] or Response Data[15:8].                              */
    } sd_cmd4_b;
  } ;
  
  union {
    __IOM uint8_t sd_cmd5;                      /*!< (@ 0x0000058E) SD Command Register 5                                      */
    
    struct {
      __IOM uint8_t cmd         : 8;            /*!< [7..0] Command[7:0] or Response Data[7:0].                                */
    } sd_cmd5_b;
  } ;
  
  union {
    __IOM uint8_t sd_byte_cnt_l;                /*!< (@ 0x0000058F) Byte Count Register (Low Byte)                             */
    
    struct {
      __IOM uint8_t byte_cnt_l  : 8;            /*!< [7..0] Byte Count[7:0]. Byte count in one block transferred
                                                     from/to SD card.                                                          */
    } sd_byte_cnt_l_b;
  } ;
  
  union {
    __IOM uint8_t sd_byte_cnt_h;                /*!< (@ 0x00000590) Byte Count Register (High Byte)                            */
    
    struct {
      __IOM uint8_t byte_cnt_h  : 3;            /*!< [2..0] Byte Count[10:8]. Byte count in one block transferred
                                                     from/to SD card.                                                          */
    } sd_byte_cnt_h_b;
  } ;
  
  union {
    __IOM uint8_t sd_blk_cnt_l;                 /*!< (@ 0x00000591) Block Count Register (Low Byte)                            */
    
    struct {
      __IOM uint8_t blk_cnt_l   : 8;            /*!< [7..0] Block Count[7:0]. Block count transferred from/to SD
                                                     card.                                                                     */
    } sd_blk_cnt_l_b;
  } ;
  
  union {
    __IOM uint8_t sd_blk_cnt_h;                 /*!< (@ 0x00000592) Block Count Register (High Byte)                           */
    
    struct {
      __IOM uint8_t blk_cnt_h   : 7;            /*!< [6..0] Block Count[14:8]. Byte count transferred from/to SD
                                                     card.                                                                     */
    } sd_blk_cnt_h_b;
  } ;
  
  union {
    __IOM uint8_t sd_xfer;                      /*!< (@ 0x00000593) SD Transfer Control Register                               */
    
    struct {
      __IOM uint8_t cmd_code    : 4;            /*!< [3..0] Command Code. These bits encoded each working mode of
                                                     SD card control module. 0000(NORMAL_WRITE): Write 1 or
                                                     2 bytes to SD card and the content are put into SD_CMD2
                                                     & SD_CMD3 in advance. Hardware ignores write error returned
                                                     from SD card in this case. 0001(AUTO_WRITE3): Hardware
                                                     writes data from Ring buffer to SD card and the data length
                                                     is (SD_BYTE_CNT * SD_BLOCK_CNT). Hardware can only write
                                                     even bytes (2, 4, 6, ..., 512) data from SRAM2 buffer to
                                                     SD card if data source is consigned to SRAM2 buffer in
                                                     th                                                                        */
      __IOM uint8_t err         : 1;            /*!< [4..4] If this bit is set which means some error occurs detailed
                                                     error information is in register SD_STAT.                                 */
      __IOM uint8_t idle_ste    : 1;            /*!< [5..5] Status of SD card module state machine When this bit
                                                     is set 1, it means that the SD card module state machine
                                                     is in idle state.                                                         */
      __IOM uint8_t end         : 1;            /*!< [6..6] If transfer starts this bit will be clear automatically
                                                     by hardware. And if transfer completes this bit will be
                                                     set and keep 1 until the next Start is set.                               */
      __IOM uint8_t start       : 1;            /*!< [7..7] The transfer is launch if set this bit.                            */
    } sd_xfer_b;
  } ;
  __IM  uint8_t   RESERVED19;
  
  union {
    __IOM uint8_t sd_cmd_ste;                   /*!< (@ 0x00000595) SD Command State Register                                  */
    
    struct {
      __IOM uint8_t cmd_ste     : 4;            /*!< [3..0] CMD State Machine                                                  */
      __IM  uint8_t             : 3;
      __IOM uint8_t cmd_ste_is_idle : 1;        /*!< [7..7] CMD State Machine is idle When this bit is 1'b1, it indicates
                                                     IDLE state of CMD State Machine                                           */
    } sd_cmd_ste_b;
  } ;
  
  union {
    __IOM uint8_t sd_data_ste;                  /*!< (@ 0x00000596) SD Data State Register                                     */
    
    struct {
      __IOM uint8_t data_ste    : 5;            /*!< [4..0] DATA State Machine                                                 */
      __IM  uint8_t             : 2;
      __IOM uint8_t data_ste_is_idle : 1;       /*!< [7..7] DATA State Machine is idle When this bit is 1'b1, it
                                                     indicates IDLE state of DATA State Machine                                */
    } sd_data_ste_b;
  } ;
} SDIO_HOST_Type;                               /*!< Size = 1431 (0x597)                                                       */



/* =========================================================================================================================== */
/* ================                                           GDMA0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA IP in low power platform with AXI interface. Only support up to 4092 data items. Common register struct for all channels (GDMA0)
  */

typedef struct {                                /*!< (@ 0x400612C0) GDMA0 Structure                                            */
  
  union {
    __IM  uint32_t raw_tfr;                     /*!< (@ 0x00000000) IntTfr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_tfr    : 6;            /*!< [5..0] Raw interrupt status of transfer complete                          */
    } raw_tfr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t raw_block;                   /*!< (@ 0x00000008) IntBlock Raw Interrupt Status Register                     */
    
    struct {
      __IM  uint32_t raw_block  : 6;            /*!< [5..0] Raw interrupt status of one block transfer complete                */
    } raw_block_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t raw_src_tran;                /*!< (@ 0x00000010) IntSrcTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_src_tran : 6;          /*!< [5..0] Raw interrupt status of source transfer complete                   */
    } raw_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IM  uint32_t raw_dst_tran;                /*!< (@ 0x00000018) IntDstTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_dst_tran : 6;          /*!< [5..0] Raw interrupt status of destination transfer complete              */
    } raw_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t raw_err;                     /*!< (@ 0x00000020) IntErr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_err    : 6;            /*!< [5..0] Raw interrupt status of transfer error                             */
    } raw_err_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IM  uint32_t status_tfr;                  /*!< (@ 0x00000028) IntTfr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_tfr : 6;            /*!< [5..0] Interrupt status of transfer complete                              */
    } status_tfr_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IM  uint32_t status_block;                /*!< (@ 0x00000030) IntBlock Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t status_block : 6;          /*!< [5..0] Interrupt status of one block transfer complete                    */
    } status_block_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IM  uint32_t status_src_tran;             /*!< (@ 0x00000038) IntSrcTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_src_tran : 6;       /*!< [5..0] Interrupt status of source transfer complete                       */
    } status_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IM  uint32_t status_dst_tran;             /*!< (@ 0x00000040) IntDstTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_dst_tran : 6;       /*!< [5..0] Interrupt status of destination transfer complete                  */
    } status_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IM  uint32_t status_err;                  /*!< (@ 0x00000048) IntErr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_err : 6;            /*!< [5..0] Interrupt status of transfer error                                 */
    } status_err_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t mask_tfr;                    /*!< (@ 0x00000050) IntTfr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_tfr   : 6;            /*!< [5..0] Interrupt mask of transfer complete                                */
    } mask_tfr_b;
  } ;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t mask_block;                  /*!< (@ 0x00000058) IntBlock Interrupt Mask Register                           */
    
    struct {
      __IOM uint32_t mask_block : 6;            /*!< [5..0] Interrupt mask of one block transfer complete                      */
    } mask_block_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t mask_src_tran;               /*!< (@ 0x00000060) IntSrcTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_src_tran : 6;         /*!< [5..0] Interrupt mask of source transfer complete                         */
    } mask_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t mask_dst_tran;               /*!< (@ 0x00000068) IntDstTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_dst_tran : 6;         /*!< [5..0] Interrupt mask of destination transfer complete                    */
    } mask_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t mask_err;                    /*!< (@ 0x00000070) IntErr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_err   : 6;            /*!< [5..0] Interrupt mask of transfer error                                   */
    } mask_err_b;
  } ;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t clear_tfr;                   /*!< (@ 0x00000078) IntTfr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t status_tfr : 6;            /*!< [5..0] Clear interrupt status of transfer complete                        */
    } clear_tfr_b;
  } ;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t clear_block;                 /*!< (@ 0x00000080) IntBlock Interrupt Clear Register                          */
    
    struct {
      __OM  uint32_t clear_block : 6;           /*!< [5..0] Clear interrupt status of one block transfer complete              */
    } clear_block_b;
  } ;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t clear_src_tran;              /*!< (@ 0x00000088) IntSrcTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_src_tran : 6;        /*!< [5..0] Clear interrupt status of source transfer complete                 */
    } clear_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t clear_dst_tran;              /*!< (@ 0x00000090) IntDstTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_dst_tran : 6;        /*!< [5..0] Clear interrupt status of destination transfer complete            */
    } clear_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint32_t clear_err;                   /*!< (@ 0x00000098) IntErr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t clear_err  : 6;            /*!< [5..0] Clear interrupt status of transfer error                           */
    } clear_err_b;
  } ;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IM  uint32_t status_int;                  /*!< (@ 0x000000A0) Combined Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t tfr        : 1;            /*!< [0..0] OR of the contents of StatusTfr register                           */
      __IM  uint32_t block      : 1;            /*!< [1..1] OR of the contents of StatusBlock register                         */
      __IM  uint32_t srct       : 1;            /*!< [2..2] OR of the contents of StatusSrcTran register                       */
      __IM  uint32_t dstt       : 1;            /*!< [3..3] OR of the contents of StatusDstTran register                       */
      __IM  uint32_t err        : 1;            /*!< [4..4] OR of the contents of StatusErr register                           */
    } status_int_b;
  } ;
  __IM  uint32_t  RESERVED20[13];
  
  union {
    __IOM uint32_t dma_cfg_reg;                 /*!< (@ 0x000000D8) Configuration Register                                     */
    
    struct {
      __IOM uint32_t dma_en     : 1;            /*!< [0..0] RTK_DMAC Enable bit. 0 : Disable, 1 : Enable                       */
    } dma_cfg_reg_b;
  } ;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint32_t ch_en_reg;                   /*!< (@ 0x000000E0) Channel Enable Register                                    */
    
    struct {
      __IOM uint32_t ch_en      : 6;            /*!< [5..0] Enables/Disables the channel. Setting this bit enables
                                                     a channel while clearing this bit disables the channel.
                                                     0 : Disable the Channel 1 : Enable the Channel The ChEnReg.CH_EN
                                                     bit is automatically cleared by hardware to disable the
                                                     channel after the last AXI transfer of the DMA transfer
                                                     to the destination has completed. Software can therefore
                                                     poll this bit to determine when this channel is free for
                                                     a new DMA transfer.                                                       */
      __IM  uint32_t            : 2;
      __OM  uint32_t ch_en_we   : 6;            /*!< [13..8] Channel enable write enable                                       */
    } ch_en_reg_b;
  } ;
  __IM  uint32_t  RESERVED22[5];
  
  union {
    __IOM uint32_t ch_reset_reg;                /*!< (@ 0x000000F8) Channel Reset Register                                     */
    
    struct {
      __IOM uint32_t ch_reset_en : 6;           /*!< [5..0] Reset channel enable. Set this bit to reset a channel;
                                                     clear this bit to finish the reset flow and release the
                                                     channel. 0 : reset the channel finish 1 : reset the channel
                                                     start The reset bit is not automatically cleared by hardware.
                                                     Software must clear it to finish software reset.                          */
      __IM  uint32_t            : 2;
      __IM  uint32_t ch_reset_en_we : 6;        /*!< [13..8] Channel reset write enable                                        */
    } ch_reset_reg_b;
  } ;
} GDMA0_Type;                                   /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                         GDMA0_CH0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA control registers for specific channels (GDMA0_CH0)
  */

typedef struct {                                /*!< (@ 0x40061000) GDMA0_CH0 Structure                                        */
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000000) Source Address Register for Channel x                      */
    
    struct {
      __IOM uint32_t sar        : 32;           /*!< [31..0] Source Address of DMA transfer. Updated after each source
                                                     transfer. The SINC field in the CTLx register determines
                                                     whether the address increments, decrements, or is left
                                                     unchanged on every source transfer throughout the block
                                                     transfer.                                                                 */
    } sar_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t dar;                         /*!< (@ 0x00000008) Destination Address Register for Channel x                 */
    
    struct {
      __IOM uint32_t dar        : 32;           /*!< [31..0] Destination address of DMA transfer. Updated after each
                                                     destination transfer. The DINC field in the CTLx register
                                                     determines whether the address increments, decrements,
                                                     or is left unchanged on every destination transfer throughout
                                                     the block transfer                                                        */
    } dar_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t llp;                         /*!< (@ 0x00000010) Linked List Pointer Register for Channel x                 */
    
    struct {
      __IOM uint32_t lms        : 2;            /*!< [1..0] List Master Select. Identifies the AHB layer/interface
                                                     where the memory device that stores the next linked list
                                                     item resides.                                                             */
      __IOM uint32_t loc        : 30;           /*!< [31..2] Starting address in memory of next LLI if block chaining
                                                     is enabled.                                                               */
    } llp_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t ctl_low;                     /*!< (@ 0x00000018) Lower Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t int_en     : 1;            /*!< [0..0] If set, then all interrupt-generating sources are enabled.
                                                     Functions as a global mask bit for all interrupts for the
                                                     channel. Raw interrupt registers still assert if this field
                                                     is 0.                                                                     */
      __IOM uint32_t dst_tr_width : 3;          /*!< [3..1] Destination Transfer Width. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t src_tr_width : 3;          /*!< [6..4] Source Transfer Width. The block_ts field should be modified
                                                     in accordance with this field. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t dinc       : 2;            /*!< [8..7] Destination Address Increment. Indicate whether to increment
                                                     to destination address on every destination transfer. If
                                                     the device is fetching data from a destination peripheral
                                                     FIFO with a fixed adress, then this field should be set
                                                     to No Change. 0x00 : Increment, 0x1x : NoChange.                          */
      __IOM uint32_t sinc       : 2;            /*!< [10..9] Source Address Increment. Indicate whether to increment
                                                     to source address on every source transfer. If the device
                                                     is fetching data from a source peripheral FIFO with a fixed
                                                     adress, then this field should be set to No Change. 0x00
                                                     : Increment, 0x1x : NoChange.                                             */
      __IOM uint32_t dest_msize : 3;            /*!< [13..11] Destination Burst Transaction Length. Number of data
                                                     items, each of width ctl.dst_tr_width, to be read from
                                                     the destination every time a destination burst transaction
                                                     request is mode.                                                          */
      __IOM uint32_t src_msize  : 3;            /*!< [16..14] Source Burst Transaction Length. Number of data items,
                                                     each of width ctl.src_tr_width, to be read from the source
                                                     every time a source burst transaction request is mode.                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t tt_fc      : 3;            /*!< [22..20] Transfer Type and Flow Control. The following transfer
                                                     types are supported. Memory to Memory, Memory to Peripheral,
                                                     Peripheral to Memory.                                                     */
      __IM  uint32_t            : 4;
      __IOM uint32_t llp_dst_en : 1;            /*!< [27..27] Block chaining is enabled on the destination side if
                                                     this field is high and llp.loc is non-zero.                               */
      __IOM uint32_t llp_src_en : 1;            /*!< [28..28] Block chaining is enabled on the source side if this
                                                     field is high and llp.loc is non-zero.                                    */
    } ctl_low_b;
  } ;
  
  union {
    __IOM uint32_t ctl_up;                      /*!< (@ 0x0000001C) Upper Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t block_ts   : 12;           /*!< [11..0] Block Transfer Size. When the RTK_DMAC is the flow controller,
                                                     the user writes this field before the channel is enabled
                                                     in order to indicate the block size. The block_ts should
                                                     be modified according to the src_tr_width field. Ex: If
                                                     src_tr_width = 4 byte, block_ts = 2.                                      */
    } ctl_up_b;
  } ;
  __IM  uint32_t  RESERVED3[8];
  
  union {
    __IOM uint32_t cfg_low;                     /*!< (@ 0x00000040) Lower Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IOM uint32_t inactive   : 1;            /*!< [0..0] Indicate the channel is inactive or not. 1: Inactive
                                                     state, 0: Active state.                                                   */
      __IM  uint32_t            : 7;
      __IOM uint32_t ch_susp    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared. There is no guarantee
                                                     that the current transaction will complete. Can also be
                                                     used in conjunction with CFGx.FIFO_EMPTY to cleanly disable
                                                     a channel without losing any data. 0 : Not suspended, 1
                                                     : Suspend DMA transfer from the source                                    */
      __IM  uint32_t fifo_empty : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.
                                                     Can be used in conjunction with CFGx.CH_SUSP to cleanly
                                                     disable a channel. 1 : Channel FIFO empty, 0 : Channel
                                                     FIFO not empty.                                                           */
      __IM  uint32_t            : 8;
      __IOM uint32_t dst_hs_pol : 1;            /*!< [18..18] Destination Handshaking Interface Polarity. 0 : Active
                                                     high, 1: Active low                                                       */
      __IOM uint32_t src_hs_pol : 1;            /*!< [19..19] Source Handshaking Interface Polarity. 0 : Active high,
                                                     1: Active low                                                             */
      __IOM uint32_t max_abrst  : 10;           /*!< [29..20] Maximum OCP Burst Length. Maximum OCP burst length
                                                     that is used for DMA transfers on this channel.                           */
      __IOM uint32_t reload_src : 1;            /*!< [30..30] Automatic Source Reload. The SAR register can be automatically
                                                     reloaded from its initial value at the end of every block
                                                     for multi-block transfers. Not support in LP-GDMA.                        */
      __IOM uint32_t reload_dst : 1;            /*!< [31..31] Automatic Destination Reload. The DAR register can
                                                     be automatically reloaded from its initial value at the
                                                     end of every block for multi-block transfers. Not support
                                                     in LP-GDMA.                                                               */
    } cfg_low_b;
  } ;
  
  union {
    __IOM uint32_t cfg_up;                      /*!< (@ 0x00000044) Upper Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t secure_en  : 1;            /*!< [3..3] Enable secure mode DMA transfer. This bit can only be
                                                     accessed by CPU under secure mode. Non-secure GDMA does
                                                     not have this bit.                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t src_per    : 4;            /*!< [10..7] Assigns a hardware handshaking interface to the source
                                                     of channels. The channel can then communicate with the
                                                     source peripheral connected to that interface through the
                                                     assigned hardware handshaking interface.                                  */
      __IOM uint32_t dest_per   : 4;            /*!< [14..11] Assigns a hardware handshaking interface to the destination
                                                     of channels. The channel can then communicate with the
                                                     destination peripheral connected to that interface through
                                                     the assigned hardware handshaking interface.                              */
      __IOM uint32_t extended_src_per : 1;      /*!< [15..15] The extened 4th bit of src_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
      __IOM uint32_t extended_dest_per : 1;     /*!< [16..16] The extened 4th bit of dest_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
    } cfg_up_b;
  } ;
} GDMA0_CH0_Type;                               /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                           I2S0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter IC Sound (I2S0)
  */

typedef struct {                                /*!< (@ 0x40062000) I2S0 Structure                                             */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) I2S Control Register                                       */
    
    struct {
      __IOM uint32_t iis_en     : 1;            /*!< [0..0] iis_en 0: disable 1: enable                                        */
      __IOM uint32_t tx_act     : 2;            /*!< [2..1] tx_act 00: rx path 01: tx path (internal lbk need enable)
                                                     10: tx_rx path bi-direction audio/voice application (not
                                                     involve 5.1 audio)                                                        */
      __IOM uint32_t audio_mono : 2;            /*!< [4..3] audio_mono 0 (00) : stereo audio 1 (01) : 5.1 audio 2
                                                     (10) : mono                                                               */
      __IOM uint32_t edge_sw    : 1;            /*!< [5..5] Chose to send data at the negative edge or positive edge
                                                     of SCK. 0: negative edge 1: positive edge                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t loop_back  : 1;            /*!< [7..7] internal testing                                                   */
      __IOM uint32_t format     : 2;            /*!< [9..8] digital interface format 0 (00) : i2s 1 (01) : left justified
                                                     2 (10) : right justified                                                  */
      __IOM uint32_t lr_swap    : 1;            /*!< [10..10] control whether dac appears in right or left phase
                                                     of ws clock 0 : left phase 1 : right phase                                */
      __IOM uint32_t sck_swap   : 1;            /*!< [11..11] invert sck 0: disable 1: enable                                  */
      __IOM uint32_t byte_swap  : 1;            /*!< [12..12] Make the data do the byte switch 0: Disable the switch
                                                     1: Enable the switch                                                      */
      __IM  uint32_t            : 2;
      __IOM uint32_t debug_switch : 2;          /*!< [16..15] switch 32bit debug signal                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t burst_size : 5;            /*!< [22..18] 1111 : burst16 1011 : burst12 0111 : burst8 0011 :
                                                     burst4                                                                    */
      __IM  uint32_t            : 4;
      __IOM uint32_t mute       : 1;            /*!< [27..27] mute function 0:disable 1:enable                                 */
      __IOM uint32_t slave_mode : 1;            /*!< [28..28] slave_mode 0: disable 1: enable                                  */
      __IOM uint32_t wl         : 2;            /*!< [30..29] word length 0 (00) : 16bits 1 (01) : 24bits 2 (10)
                                                     : 32bits 3 (11) : unused (error)                                          */
      __IOM uint32_t sw_rstn    : 1;            /*!< [31..31] 0 : sw_rstn 1 : no sw reset                                      */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t page_ptr_tx;                 /*!< (@ 0x00000004) TX Page pointer Register                                   */
    
    struct {
      __IM  uint32_t            : 2;
      __IOM uint32_t page_ptr_tx : 30;          /*!< [31..2] tx page pointer. this is a physical address with word-align
                                                     limitation                                                                */
    } page_ptr_tx_b;
  } ;
  
  union {
    __IOM uint32_t page_ptr_rx;                 /*!< (@ 0x00000008) RX Page pointer Register                                   */
    
    struct {
      __IM  uint32_t            : 2;
      __IOM uint32_t page_ptr_rx : 30;          /*!< [31..2] rx page pointer. this is a physical address with word-align
                                                     limitation                                                                */
    } page_ptr_rx_b;
  } ;
  
  union {
    __IOM uint32_t page_size_rate;              /*!< (@ 0x0000000C) Page Size and Sample Rate Register                         */
    
    struct {
      __IOM uint32_t page_size  : 12;           /*!< [11..0] page size (word unit)                                             */
      __IOM uint32_t page_num   : 2;            /*!< [13..12] page number                                                      */
      __IOM uint32_t sr         : 4;            /*!< [17..14] sample rate 0000: 8khz /7.35k, 0001: 12khz /11.025k
                                                     0010: 16khz /14.7k 0011: 24khz /22.05khz 0100: 32khz /29.4khz
                                                     0101: 48khz /44.1khz 0110: 64khz /58.8khz 0111: 96khz /88.2khz
                                                     1000: 192khz /176.4khz 1001: 384khz others: reserved                      */
      __IOM uint32_t clk_switch : 1;            /*!< [18..18] clk_iis switch 0: clk_iis is 98.304mhz (+-50ppm) 1:
                                                     clk_iis is 45.1584mhz (+-50ppm)                                           */
    } page_size_rate_b;
  } ;
  
  union {
    __IOM uint32_t tx_isr_en;                   /*!< (@ 0x00000010) TX Interrupt Enable Register                               */
    
    struct {
      __IOM uint32_t p0okie_tx  : 1;            /*!< [0..0] tx page 0 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p1okie_tx  : 1;            /*!< [1..1] tx page 1 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p2okie_tx  : 1;            /*!< [2..2] tx page 2 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p3okie_tx  : 1;            /*!< [3..3] tx page 3 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t page0unava_ie_tx : 1;      /*!< [4..4] tx page 0 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page1unava_ie_tx : 1;      /*!< [5..5] tx page 1 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page2unava_ie_tx : 1;      /*!< [6..6] tx page 2 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page3unava_ie_tx : 1;      /*!< [7..7] tx page 3 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t fifo_empty_ie_tx : 1;      /*!< [8..8] tx fifo empty interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
    } tx_isr_en_b;
  } ;
  
  union {
    __IOM uint32_t tx_isr_status;               /*!< (@ 0x00000014) TX Interrupt Status Register                               */
    
    struct {
      __IOM uint32_t p0okip_tx  : 1;            /*!< [0..0] tx page 0 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p1okip_tx  : 1;            /*!< [1..1] tx page 1 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p2okip_tx  : 1;            /*!< [2..2] tx page 2 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p3okip_tx  : 1;            /*!< [3..3] tx page 3 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t page0unava_ip_tx : 1;      /*!< [4..4] tx page 0 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page1unava_ip_tx : 1;      /*!< [5..5] tx page 1 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page2unava_ip_tx : 1;      /*!< [6..6] tx page 2 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page3unava_ip_tx : 1;      /*!< [7..7] tx page 3 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t fifo_empty_ip_tx : 1;      /*!< [8..8] tx fifo empty interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
    } tx_isr_status_b;
  } ;
  
  union {
    __IOM uint32_t rx_isr_en;                   /*!< (@ 0x00000018) RX Interrupt Enable Register                               */
    
    struct {
      __IOM uint32_t p0okie_rx  : 1;            /*!< [0..0] rx page 0 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p1okie_rx  : 1;            /*!< [1..1] rx page 1 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p2okie_rx  : 1;            /*!< [2..2] rx page 2 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t p3okie_rx  : 1;            /*!< [3..3] rx page 3 ok interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
      __IOM uint32_t page0unava_ie_rx : 1;      /*!< [4..4] rx page 0 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page1unava_ie_rx : 1;      /*!< [5..5] rx page 1 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page2unava_ie_rx : 1;      /*!< [6..6] rx page 2 unavailable interrupt enable 0: disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t page3unava_ie_rx : 1;      /*!< [7..7] rx page 3 unavailable interrupt enable 0 : disable interrupt
                                                     1: enable interrupt                                                       */
      __IOM uint32_t fifo_full_ie_rx : 1;       /*!< [8..8] rx fifo full interrupt enable 0: disable interrupt 1:
                                                     enable interrupt                                                          */
    } rx_isr_en_b;
  } ;
  
  union {
    __IOM uint32_t rx_isr_status;               /*!< (@ 0x0000001C) RX Interrupt Status Register                               */
    
    struct {
      __IOM uint32_t p0okip_rx  : 1;            /*!< [0..0] rx page 0 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p1okip_rx  : 1;            /*!< [1..1] rx page 1 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p2okip_rx  : 1;            /*!< [2..2] rx page 2 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t p3okip_rx  : 1;            /*!< [3..3] rx page 3 ok interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
      __IOM uint32_t page0unava_ip_rx : 1;      /*!< [4..4] rx page 0 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page1unava_ip_rx : 1;      /*!< [5..5] rx page 1 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page2unava_ip_rx : 1;      /*!< [6..6] rx page 2 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t page3unava_ip_rx : 1;      /*!< [7..7] rx page 3 unavailable interrupt pending 0: no interrupt
                                                     1: interrupt pending, write 1 to clear                                    */
      __IOM uint32_t fifo_full_ip_rx : 1;       /*!< [8..8] rx fifo full interrupt pending 0: no interrupt 1: interrupt
                                                     pending, write 1 to clear                                                 */
    } rx_isr_status_b;
  } ;
  
  union {
    __IOM uint32_t tx_page0_own;                /*!< (@ 0x00000020) TX Page0 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p0own_tx   : 1;            /*!< [31..31] tx page 0 own bit 0: page 0 owned by cpu 1: page 0
                                                     owned by iis controller                                                   */
    } tx_page0_own_b;
  } ;
  
  union {
    __IOM uint32_t tx_page1_own;                /*!< (@ 0x00000024) TX Page1 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p1own_tx   : 1;            /*!< [31..31] tx page 1 own bit 0: page 1 owned by cpu 1: page 1
                                                     owned by iis controller                                                   */
    } tx_page1_own_b;
  } ;
  
  union {
    __IOM uint32_t tx_page2_own;                /*!< (@ 0x00000028) TX Page2 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p2own_tx   : 1;            /*!< [31..31] tx page 2 own bit 0: page 2 owned by cpu 1: page 2
                                                     owned by iis controller                                                   */
    } tx_page2_own_b;
  } ;
  
  union {
    __IOM uint32_t tx_page3_own;                /*!< (@ 0x0000002C) TX Page3 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p3own_tx   : 1;            /*!< [31..31] tx page 3 own bit 0: page 3 owned by cpu 1: page 3
                                                     owned by iis controller                                                   */
    } tx_page3_own_b;
  } ;
  
  union {
    __IOM uint32_t rx_page0_own;                /*!< (@ 0x00000030) RX Page0 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p0own_rx   : 1;            /*!< [31..31] rx page 0 own bit 0: page 0 owned by cpu 1: page 0
                                                     owned by iis controller                                                   */
    } rx_page0_own_b;
  } ;
  
  union {
    __IOM uint32_t rx_page1_own;                /*!< (@ 0x00000034) RX Page1 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p1own_rx   : 1;            /*!< [31..31] rx page 1 own bit 0: page 1 owned by cpu 1: page 1
                                                     owned by iis controller                                                   */
    } rx_page1_own_b;
  } ;
  
  union {
    __IOM uint32_t rx_page2_own;                /*!< (@ 0x00000038) RX Page2 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p2own_rx   : 1;            /*!< [31..31] rx page 2 own bit 0: page 2 owned by cpu 1: page 2
                                                     owned by iis controller                                                   */
    } rx_page2_own_b;
  } ;
  
  union {
    __IOM uint32_t rx_page3_own;                /*!< (@ 0x0000003C) RX Page3 Own Bit Register                                  */
    
    struct {
      __IM  uint32_t            : 31;
      __IOM uint32_t p3own_rx   : 1;            /*!< [31..31] rx page 3 own bit 0: page 3 owned by cpu 1: page 3
                                                     owned by iis controller                                                   */
    } rx_page3_own_b;
  } ;
  
  union {
    __IM  uint32_t version_id;                  /*!< (@ 0x00000040) Version id                                                 */
    
    struct {
      __IM  uint32_t version_id : 32;           /*!< [31..0] version id                                                        */
    } version_id_b;
  } ;
} I2S0_Type;                                    /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                           PCM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Code Modulation (PCM0)
  */

typedef struct {                                /*!< (@ 0x40064000) PCM0 Structure                                             */
  
  union {
    __IOM uint32_t pcmcr;                       /*!< (@ 0x00000000) PCM interface Control Register                             */
    
    struct {
      __IM  uint32_t            : 8;
      __IOM uint32_t slave_sel  : 1;            /*!< [8..8] slave_mode 0: disable 1: enable                                    */
      __IOM uint32_t fsinv      : 1;            /*!< [9..9] pcm interface a frame synchronization invert. 0: pcm0fs
                                                     high active. 1: pcm0fs low active.                                        */
      __IM  uint32_t            : 2;
      __IOM uint32_t pcm_en     : 1;            /*!< [12..12] PCM Enable 0: Disable 1: Enable                                  */
      __IOM uint32_t linear_mode : 1;           /*!< [13..13] linear mode enable 0: enable compender 1: linear mode            */
      __IOM uint32_t loop_back  : 1;            /*!< [14..14] pcm loop back mode enable 0:disable 1:enable                     */
      __IM  uint32_t            : 2;
      __IOM uint32_t endian_swap : 1;           /*!< [17..17] edian swap 0:disable 1:enable                                    */
    } pcmcr_b;
  } ;
  
  union {
    __IOM uint32_t pachcnr03;                   /*!< (@ 0x00000004) channel0-3 specific control register                       */
    
    struct {
      __IOM uint32_t ch3re      : 1;            /*!< [0..0] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch3te      : 1;            /*!< [1..1] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch3ua      : 1;            /*!< [2..2] channel u law/ a law select. 0: u law, 1: a law                    */
      __IOM uint32_t ch3band    : 1;            /*!< [3..3] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch2re      : 1;            /*!< [8..8] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch2te      : 1;            /*!< [9..9] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch2ua      : 1;            /*!< [10..10] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch2band    : 1;            /*!< [11..11] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch1re      : 1;            /*!< [16..16] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch1te      : 1;            /*!< [17..17] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch1ua      : 1;            /*!< [18..18] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch1band    : 1;            /*!< [19..19] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch0re      : 1;            /*!< [24..24] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch0te      : 1;            /*!< [25..25] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch0ua      : 1;            /*!< [26..26] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch0band    : 1;            /*!< [27..27] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
    } pachcnr03_b;
  } ;
  
  union {
    __IOM uint32_t patsr03;                     /*!< (@ 0x00000008) channel0-3 time slot assignment register                   */
    
    struct {
      __IOM uint32_t ch3tsa     : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch2tsa     : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch1tsa     : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch0tsa     : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } patsr03_b;
  } ;
  
  union {
    __IOM uint32_t pabsize03;                   /*!< (@ 0x0000000C) channel0-3 buffer size register                            */
    
    struct {
      __IOM uint32_t ch3bsize   : 8;            /*!< [7..0] channel buffer size in unit of 4(n+1) bytes.                       */
      __IOM uint32_t ch2bsize   : 8;            /*!< [15..8] channel buffer size in unit of 4(n+1) bytes.                      */
      __IOM uint32_t ch1bsize   : 8;            /*!< [23..16] channel buffer size in unit of 4(n+1) bytes.                     */
      __IOM uint32_t ch0bsize   : 8;            /*!< [31..24] channel buffer size in unit of 4(n+1) bytes.                     */
    } pabsize03_b;
  } ;
  
  union {
    __IOM uint32_t ch0atxbsa;                   /*!< (@ 0x00000010) channel 0 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch0atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch1atxbsa;                   /*!< (@ 0x00000014) channel 1 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch1atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch2atxbsa;                   /*!< (@ 0x00000018) channel 2 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch2atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch3atxbsa;                   /*!< (@ 0x0000001C) channel 3 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch3atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch0arxbsa;                   /*!< (@ 0x00000020) channel 0 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch0arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch1arxbsa;                   /*!< (@ 0x00000024) channel 1 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch1arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch2arxbsa;                   /*!< (@ 0x00000028) channel 2 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch2arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch3arxbsa;                   /*!< (@ 0x0000002C) channel 3 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch3arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t paimr03;                     /*!< (@ 0x00000030) channel0-3 interrupt mask register                         */
    
    struct {
      __IOM uint32_t ch3rbp1uaie : 1;           /*!< [0..0] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch3rbp0uaie : 1;           /*!< [1..1] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch3tbp1uaie : 1;           /*!< [2..2] transmit buffer page1 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch3tbp0uaie : 1;           /*!< [3..3] transmit buffer page0 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch3p1rokie : 1;            /*!< [4..4] rx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch3p0rokie : 1;            /*!< [5..5] rx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch3p1tokie : 1;            /*!< [6..6] tx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch3p0tokie : 1;            /*!< [7..7] tx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch2rbp1uaie : 1;           /*!< [8..8] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch2rbp0uaie : 1;           /*!< [9..9] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch2tbp1uaie : 1;           /*!< [10..10] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch2tbp0uaie : 1;           /*!< [11..11] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch2p1rokie : 1;            /*!< [12..12] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch2p0rokie : 1;            /*!< [13..13] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch2p1tokie : 1;            /*!< [14..14] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch2p0tokie : 1;            /*!< [15..15] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch1rbp1uaie : 1;           /*!< [16..16] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch1rbp0uaie : 1;           /*!< [17..17] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch1tbp1uaie : 1;           /*!< [18..18] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch1tbp0uaie : 1;           /*!< [19..19] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch1p1rokie : 1;            /*!< [20..20] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch1p0rokie : 1;            /*!< [21..21] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch1p1tokie : 1;            /*!< [22..22] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch1p0tokie : 1;            /*!< [23..23] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch0rbp1uaie : 1;           /*!< [24..24] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch0rbp0uaie : 1;           /*!< [25..25] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch0tbp1uaie : 1;           /*!< [26..26] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch0tbp0uaie : 1;           /*!< [27..27] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch0p1rokie : 1;            /*!< [28..28] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch0p0rokie : 1;            /*!< [29..29] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch0p1tokie : 1;            /*!< [30..30] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch0p0tokie : 1;            /*!< [31..31] tx page 0 ok interrupt enable. 0: disable 1: enable              */
    } paimr03_b;
  } ;
  
  union {
    __IOM uint32_t paisr03;                     /*!< (@ 0x00000034) channel0-3 interrupt status register                       */
    
    struct {
      __IOM uint32_t ch3rxp1ua  : 1;            /*!< [0..0] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3rxp0ua  : 1;            /*!< [1..1] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3txp1ua  : 1;            /*!< [2..2] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3txp0ua  : 1;            /*!< [3..3] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3rxp1ip  : 1;            /*!< [4..4] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3rxp0ip  : 1;            /*!< [5..5] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3txp1ip  : 1;            /*!< [6..6] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch3txp0ip  : 1;            /*!< [7..7] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch2rxp1ua  : 1;            /*!< [8..8] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch2rxp0ua  : 1;            /*!< [9..9] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch2txp1ua  : 1;            /*!< [10..10] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch2txp0ua  : 1;            /*!< [11..11] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch2rxp1ip  : 1;            /*!< [12..12] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch2rxp0ip  : 1;            /*!< [13..13] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch2txp1ip  : 1;            /*!< [14..14] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch2txp0ip  : 1;            /*!< [15..15] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1rxp1ua  : 1;            /*!< [16..16] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1rxp0ua  : 1;            /*!< [17..17] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1txp1ua  : 1;            /*!< [18..18] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1txp0ua  : 1;            /*!< [19..19] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1rxp1ip  : 1;            /*!< [20..20] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1rxp0ip  : 1;            /*!< [21..21] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1txp1ip  : 1;            /*!< [22..22] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch1txp0ip  : 1;            /*!< [23..23] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0rxp1ua  : 1;            /*!< [24..24] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0rxp0ua  : 1;            /*!< [25..25] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0txp1ua  : 1;            /*!< [26..26] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0txp0ua  : 1;            /*!< [27..27] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0rxp1p   : 1;            /*!< [28..28] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0rxp0ip  : 1;            /*!< [29..29] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0txp1ip  : 1;            /*!< [30..30] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch0txp0ip  : 1;            /*!< [31..31] interrupt pending flag write 1 to clear the interrupt.           */
    } paisr03_b;
  } ;
  
  union {
    __IOM uint32_t pachcnr47;                   /*!< (@ 0x00000038) channel4-7 specific control register                       */
    
    struct {
      __IOM uint32_t ch7re      : 1;            /*!< [0..0] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch7te      : 1;            /*!< [1..1] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch7ua      : 1;            /*!< [2..2] channel u law/ a law select. 0: u law, 1: a law                    */
      __IOM uint32_t ch7band    : 1;            /*!< [3..3] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch6re      : 1;            /*!< [8..8] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch6te      : 1;            /*!< [9..9] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch6ua      : 1;            /*!< [10..10] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch6band    : 1;            /*!< [11..11] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch5re      : 1;            /*!< [16..16] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch5te      : 1;            /*!< [17..17] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch5ua      : 1;            /*!< [18..18] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch5band    : 1;            /*!< [19..19] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
      __IM  uint32_t            : 4;
      __IOM uint32_t ch4re      : 1;            /*!< [24..24] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch4te      : 1;            /*!< [25..25] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch4ua      : 1;            /*!< [26..26] channel u law/ a law select. 0: u law, 1: a law                  */
      __IOM uint32_t ch4band    : 1;            /*!< [27..27] narrow band /wide band select. 0: narrow band 1: wide
                                                     band                                                                      */
    } pachcnr47_b;
  } ;
  
  union {
    __IOM uint32_t patsr47;                     /*!< (@ 0x0000003C) channel4-7 time slot assignment register                   */
    
    struct {
      __IOM uint32_t ch7tsa     : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch6tsa     : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch5tsa     : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch4tsa     : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } patsr47_b;
  } ;
  
  union {
    __IOM uint32_t pabsize47;                   /*!< (@ 0x00000040) channel4-7 buffer size register                            */
    
    struct {
      __IOM uint32_t ch7bsize   : 8;            /*!< [7..0] channel buffer size in unit of 4(n+1) bytes.                       */
      __IOM uint32_t ch6bsize   : 8;            /*!< [15..8] channel buffer size in unit of 4(n+1) bytes.                      */
      __IOM uint32_t ch5bsize   : 8;            /*!< [23..16] channel buffer size in unit of 4(n+1) bytes.                     */
      __IOM uint32_t ch4bsize   : 8;            /*!< [31..24] channel buffer size in unit of 4(n+1) bytes.                     */
    } pabsize47_b;
  } ;
  
  union {
    __IOM uint32_t ch4atxbsa;                   /*!< (@ 0x00000044) channel 4 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch4atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch5atxbsa;                   /*!< (@ 0x00000048) channel 5 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch5atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch6atxbsa;                   /*!< (@ 0x0000004C) channel 6 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch6atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch7atxbsa;                   /*!< (@ 0x00000050) channel 7 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch7atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch4arxbsa;                   /*!< (@ 0x00000054) channel 4 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch4arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch5arxbsa;                   /*!< (@ 0x00000058) channel 5 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch5arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch6arxbsa;                   /*!< (@ 0x0000005C) channel 6 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch6arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch7arxbsa;                   /*!< (@ 0x00000060) channel 7 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch7arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t paimr47;                     /*!< (@ 0x00000064) channel4-7 interrupt mask register                         */
    
    struct {
      __IOM uint32_t ch7rbp1uaie : 1;           /*!< [0..0] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch7rbp0uaie : 1;           /*!< [1..1] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch7tbp1uaie : 1;           /*!< [2..2] transmit buffer page1 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch7tbp0uaie : 1;           /*!< [3..3] transmit buffer page0 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch7p1rokie : 1;            /*!< [4..4] rx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch7p0rokie : 1;            /*!< [5..5] rx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch7p1tokie : 1;            /*!< [6..6] tx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch7p0tokie : 1;            /*!< [7..7] tx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch6rbp1uaie : 1;           /*!< [8..8] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch6rbp0uaie : 1;           /*!< [9..9] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch6tbp1uaie : 1;           /*!< [10..10] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch6tbp0uaie : 1;           /*!< [11..11] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch6p1rokie : 1;            /*!< [12..12] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch6p0rokie : 1;            /*!< [13..13] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch6p1tokie : 1;            /*!< [14..14] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch6p0tokie : 1;            /*!< [15..15] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch5rbp1uaie : 1;           /*!< [16..16] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch5rbp0uaie : 1;           /*!< [17..17] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch5tbp1uaie : 1;           /*!< [18..18] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch5tbp0uaie : 1;           /*!< [19..19] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch5p1rokie : 1;            /*!< [20..20] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch5p0rokie : 1;            /*!< [21..21] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch5p1tokie : 1;            /*!< [22..22] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch5p0tokie : 1;            /*!< [23..23] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch4rbp1uaie : 1;           /*!< [24..24] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch4rbp0uaie : 1;           /*!< [25..25] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch4tbp1uaie : 1;           /*!< [26..26] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch4tbp0uaie : 1;           /*!< [27..27] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch4p1rokie : 1;            /*!< [28..28] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch4p0rokie : 1;            /*!< [29..29] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch4p1tokie : 1;            /*!< [30..30] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch4p0tokie : 1;            /*!< [31..31] tx page 0 ok interrupt enable. 0: disable 1: enable              */
    } paimr47_b;
  } ;
  
  union {
    __IOM uint32_t paisr47;                     /*!< (@ 0x00000068) channel4-7 interrupt status register                       */
    
    struct {
      __IOM uint32_t ch7rxp1ua  : 1;            /*!< [0..0] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7rxp0ua  : 1;            /*!< [1..1] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7txp1ua  : 1;            /*!< [2..2] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7txp0ua  : 1;            /*!< [3..3] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7rxp1ip  : 1;            /*!< [4..4] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7rxp0ip  : 1;            /*!< [5..5] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7txp1ip  : 1;            /*!< [6..6] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch7txp0ip  : 1;            /*!< [7..7] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch6rxp1ua  : 1;            /*!< [8..8] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch6rxp0ua  : 1;            /*!< [9..9] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch6txp1ua  : 1;            /*!< [10..10] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch6txp0ua  : 1;            /*!< [11..11] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch6rxp1ip  : 1;            /*!< [12..12] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch6rxp0ip  : 1;            /*!< [13..13] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch6txp1ip  : 1;            /*!< [14..14] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch6txp0ip  : 1;            /*!< [15..15] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5rxp1ua  : 1;            /*!< [16..16] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5rxp0ua  : 1;            /*!< [17..17] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5txp1ua  : 1;            /*!< [18..18] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5txp0ua  : 1;            /*!< [19..19] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5rxp1ip  : 1;            /*!< [20..20] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5rxp0ip  : 1;            /*!< [21..21] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5txp1ip  : 1;            /*!< [22..22] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch5txp0ip  : 1;            /*!< [23..23] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4rxp1ua  : 1;            /*!< [24..24] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4rxp0ua  : 1;            /*!< [25..25] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4txp1ua  : 1;            /*!< [26..26] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4txp0ua  : 1;            /*!< [27..27] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4rxp1p   : 1;            /*!< [28..28] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4rxp0ip  : 1;            /*!< [29..29] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4txp1ip  : 1;            /*!< [30..30] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch4txp0ip  : 1;            /*!< [31..31] interrupt pending flag write 1 to clear the interrupt.           */
    } paisr47_b;
  } ;
  
  union {
    __IOM uint32_t pachcnr811;                  /*!< (@ 0x0000006C) channel8-11 specific control register                      */
    
    struct {
      __IOM uint32_t ch11re     : 1;            /*!< [0..0] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch11te     : 1;            /*!< [1..1] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch11ua     : 1;            /*!< [2..2] channel u law/ a law select. 0: u law, 1: a law                    */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch10re     : 1;            /*!< [8..8] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch10te     : 1;            /*!< [9..9] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch10ua     : 1;            /*!< [10..10] channel u law/ a law select. 0: u law, 1: a law                  */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch9re      : 1;            /*!< [16..16] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch9te      : 1;            /*!< [17..17] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch9ua      : 1;            /*!< [18..18] channel u law/ a law select. 0: u law, 1: a law                  */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch8re      : 1;            /*!< [24..24] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch8te      : 1;            /*!< [25..25] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch8ua      : 1;            /*!< [26..26] channel u law/ a law select. 0: u law, 1: a law                  */
    } pachcnr811_b;
  } ;
  
  union {
    __IOM uint32_t patsr811;                    /*!< (@ 0x00000070) channel8-11 time slot assignment register                  */
    
    struct {
      __IOM uint32_t ch11tsa    : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch10tsa    : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch9tsa     : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch8tsa     : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } patsr811_b;
  } ;
  
  union {
    __IOM uint32_t pabsize811;                  /*!< (@ 0x00000074) channel8-11 buffer size register                           */
    
    struct {
      __IOM uint32_t ch11bsize  : 8;            /*!< [7..0] channel buffer size in unit of 4(n+1) bytes.                       */
      __IOM uint32_t ch10bsize  : 8;            /*!< [15..8] channel buffer size in unit of 4(n+1) bytes.                      */
      __IOM uint32_t ch9bsize   : 8;            /*!< [23..16] channel buffer size in unit of 4(n+1) bytes.                     */
      __IOM uint32_t ch8bsize   : 8;            /*!< [31..24] channel buffer size in unit of 4(n+1) bytes.                     */
    } pabsize811_b;
  } ;
  
  union {
    __IOM uint32_t ch8atxbsa;                   /*!< (@ 0x00000078) channel 8 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch8atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch9atxbsa;                   /*!< (@ 0x0000007C) channel 9 tx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch9atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch10atxbsa;                  /*!< (@ 0x00000080) channel 10 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch10atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch11atxbsa;                  /*!< (@ 0x00000084) channel 11 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch11atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch8arxbsa;                   /*!< (@ 0x00000088) channel 8 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch8arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch9arxbsa;                   /*!< (@ 0x0000008C) channel 9 rx buffer starting address pointer               */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch9arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch10arxbsa;                  /*!< (@ 0x00000090) channel 10 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch10arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch11arxbsa;                  /*!< (@ 0x00000094) channel 11 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch11arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t paimr811;                    /*!< (@ 0x00000098) channel8-11 interrupt mask register                        */
    
    struct {
      __IOM uint32_t ch11rbp1uaie : 1;          /*!< [0..0] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch11rbp0uaie : 1;          /*!< [1..1] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch11tbp1uaie : 1;          /*!< [2..2] transmit buffer page1 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch11tbp0uaie : 1;          /*!< [3..3] transmit buffer page0 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch11p1rokie : 1;           /*!< [4..4] rx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch11p0rokie : 1;           /*!< [5..5] rx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch11p1tokie : 1;           /*!< [6..6] tx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch11p0tokie : 1;           /*!< [7..7] tx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch10rbp1uaie : 1;          /*!< [8..8] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch10rbp0uaie : 1;          /*!< [9..9] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch10tbp1uaie : 1;          /*!< [10..10] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch10tbp0uaie : 1;          /*!< [11..11] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch10p1rokie : 1;           /*!< [12..12] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch10p0rokie : 1;           /*!< [13..13] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch10p1tokie : 1;           /*!< [14..14] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch10p0tokie : 1;           /*!< [15..15] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch9rbp1uaie : 1;           /*!< [16..16] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch9rbp0uaie : 1;           /*!< [17..17] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch9tbp1uaie : 1;           /*!< [18..18] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch9tbp0uaie : 1;           /*!< [19..19] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch9p1rokie : 1;            /*!< [20..20] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch9p0rokie : 1;            /*!< [21..21] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch9p1tokie : 1;            /*!< [22..22] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch9p0tokie : 1;            /*!< [23..23] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch8rbp1uaie : 1;           /*!< [24..24] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch8rbp0uaie : 1;           /*!< [25..25] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch8tbp1uaie : 1;           /*!< [26..26] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch8tbp0uaie : 1;           /*!< [27..27] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch8p1rokie : 1;            /*!< [28..28] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch8p0rokie : 1;            /*!< [29..29] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch8p1tokie : 1;            /*!< [30..30] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch8p0tokie : 1;            /*!< [31..31] tx page 0 ok interrupt enable. 0: disable 1: enable              */
    } paimr811_b;
  } ;
  
  union {
    __IOM uint32_t paisr811;                    /*!< (@ 0x0000009C) channel8-11 interrupt status register                      */
    
    struct {
      __IOM uint32_t ch11rxp1ua : 1;            /*!< [0..0] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11rxp0ua : 1;            /*!< [1..1] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11txp1ua : 1;            /*!< [2..2] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11txp0ua : 1;            /*!< [3..3] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11rxp1ip : 1;            /*!< [4..4] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11rxp0ip : 1;            /*!< [5..5] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11txp1ip : 1;            /*!< [6..6] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch11txp0ip : 1;            /*!< [7..7] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch10rxp1ua : 1;            /*!< [8..8] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch10rxp0ua : 1;            /*!< [9..9] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch10txp1ua : 1;            /*!< [10..10] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch10txp0ua : 1;            /*!< [11..11] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch10rxp1ip : 1;            /*!< [12..12] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch10rxp0ip : 1;            /*!< [13..13] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch10txp1ip : 1;            /*!< [14..14] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch10txp0ip : 1;            /*!< [15..15] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9rxp1ua  : 1;            /*!< [16..16] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9rxp0ua  : 1;            /*!< [17..17] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9txp1ua  : 1;            /*!< [18..18] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9txp0ua  : 1;            /*!< [19..19] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9rxp1ip  : 1;            /*!< [20..20] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9rxp0ip  : 1;            /*!< [21..21] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9txp1ip  : 1;            /*!< [22..22] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch9txp0ip  : 1;            /*!< [23..23] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8rxp1ua  : 1;            /*!< [24..24] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8rxp0ua  : 1;            /*!< [25..25] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8txp1ua  : 1;            /*!< [26..26] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8txp0ua  : 1;            /*!< [27..27] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8rxp1p   : 1;            /*!< [28..28] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8rxp0ip  : 1;            /*!< [29..29] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8txp1ip  : 1;            /*!< [30..30] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch8txp0ip  : 1;            /*!< [31..31] interrupt pending flag write 1 to clear the interrupt.           */
    } paisr811_b;
  } ;
  
  union {
    __IOM uint32_t pachcnr1215;                 /*!< (@ 0x000000A0) channel12-15 specific control register                     */
    
    struct {
      __IOM uint32_t ch15re     : 1;            /*!< [0..0] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch15te     : 1;            /*!< [1..1] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch15ua     : 1;            /*!< [2..2] channel u law/ a law select. 0: u law, 1: a law                    */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch14re     : 1;            /*!< [8..8] channel receiver enable. 0: disable 1: enable Reset the
                                                     state by setting 1 to 0                                                   */
      __IOM uint32_t ch14te     : 1;            /*!< [9..9] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch14ua     : 1;            /*!< [10..10] channel u law/ a law select. 0: u law, 1: a law                  */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch13re     : 1;            /*!< [16..16] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch13te     : 1;            /*!< [17..17] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch13ua     : 1;            /*!< [18..18] channel u law/ a law select. 0: u law, 1: a law                  */
      __IM  uint32_t            : 5;
      __IOM uint32_t ch12re     : 1;            /*!< [24..24] channel receiver enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch12te     : 1;            /*!< [25..25] channel transmitter enable. 0: disable 1: enable Reset
                                                     the state by setting 1 to 0                                               */
      __IOM uint32_t ch12ua     : 1;            /*!< [26..26] channel u law/ a law select. 0: u law, 1: a law                  */
    } pachcnr1215_b;
  } ;
  
  union {
    __IOM uint32_t patsr1215;                   /*!< (@ 0x000000A4) channel12-15 time slot assignment register                 */
    
    struct {
      __IOM uint32_t ch15tsa    : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch14tsa    : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch13tsa    : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch12tsa    : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } patsr1215_b;
  } ;
  
  union {
    __IOM uint32_t pabsize1215;                 /*!< (@ 0x000000A8) channel12-15 buffer size register                          */
    
    struct {
      __IOM uint32_t ch15bsize  : 8;            /*!< [7..0] channel buffer size in unit of 4(n+1) bytes.                       */
      __IOM uint32_t ch14bsize  : 8;            /*!< [15..8] channel buffer size in unit of 4(n+1) bytes.                      */
      __IOM uint32_t ch13bsize  : 8;            /*!< [23..16] channel buffer size in unit of 4(n+1) bytes.                     */
      __IOM uint32_t ch12bsize  : 8;            /*!< [31..24] channel buffer size in unit of 4(n+1) bytes.                     */
    } pabsize1215_b;
  } ;
  
  union {
    __IOM uint32_t ch12atxbsa;                  /*!< (@ 0x000000AC) channel 12 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch12atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch13atxbsa;                  /*!< (@ 0x000000B0) channel 13 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch13atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch14atxbsa;                  /*!< (@ 0x000000B4) channel 14 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch14atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch15atxbsa;                  /*!< (@ 0x000000B8) channel 15 tx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch15atxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch12arxbsa;                  /*!< (@ 0x000000BC) channel 12 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch12arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch13arxbsa;                  /*!< (@ 0x000000C0) channel 13 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch13arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch14arxbsa;                  /*!< (@ 0x000000C4) channel 14 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch14arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t ch15arxbsa;                  /*!< (@ 0x000000C8) channel 15 rx buffer starting address pointer              */
    
    struct {
      __IOM uint32_t p0own      : 1;            /*!< [0..0] page0 own bit 1: page0 owned by pcm controller 0: page0
                                                     owned by cpu                                                              */
      __IOM uint32_t p1own      : 1;            /*!< [1..1] page1 own bit 1: page1 owned by pcm controller 0: page1
                                                     owned by cpu                                                              */
      __IOM uint32_t bufptr     : 30;           /*!< [31..2] physical buffer starting address. the buffer address
                                                     must word aligned.                                                        */
    } ch15arxbsa_b;
  } ;
  
  union {
    __IOM uint32_t paimr1215;                   /*!< (@ 0x000000CC) channel12-15 interrupt mask register                       */
    
    struct {
      __IOM uint32_t ch15rbp1uaie : 1;          /*!< [0..0] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch15rbp0uaie : 1;          /*!< [1..1] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch15tbp1uaie : 1;          /*!< [2..2] transmit buffer page1 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch15tbp0uaie : 1;          /*!< [3..3] transmit buffer page0 unavailable interrupt enable. 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch15p1rokie : 1;           /*!< [4..4] rx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch15p0rokie : 1;           /*!< [5..5] rx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch15p1tokie : 1;           /*!< [6..6] tx page 1 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch15p0tokie : 1;           /*!< [7..7] tx page 0 ok interrupt enable. 0: disable 1: enable                */
      __IOM uint32_t ch14rbp1uaie : 1;          /*!< [8..8] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch14rbp0uaie : 1;          /*!< [9..9] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch14tbp1uaie : 1;          /*!< [10..10] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch14tbp0uaie : 1;          /*!< [11..11] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch14p1rokie : 1;           /*!< [12..12] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch14p0rokie : 1;           /*!< [13..13] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch14p1tokie : 1;           /*!< [14..14] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch14p0tokie : 1;           /*!< [15..15] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch13rbp1uaie : 1;          /*!< [16..16] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch13rbp0uaie : 1;          /*!< [17..17] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch13tbp1uaie : 1;          /*!< [18..18] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch13tbp0uaie : 1;          /*!< [19..19] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch13p1rokie : 1;           /*!< [20..20] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch13p0rokie : 1;           /*!< [21..21] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch13p1tokie : 1;           /*!< [22..22] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch13p0tokie : 1;           /*!< [23..23] tx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch12rbp1uaie : 1;          /*!< [24..24] receive buffer page1 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch12rbp0uaie : 1;          /*!< [25..25] receive buffer page0 unavailable interrupt enable 0:
                                                     disable 1: enable                                                         */
      __IOM uint32_t ch12tbp1uaie : 1;          /*!< [26..26] transmit buffer page1 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch12tbp0uaie : 1;          /*!< [27..27] transmit buffer page0 unavailable interrupt enable.
                                                     0: disable 1: enable                                                      */
      __IOM uint32_t ch12p1rokie : 1;           /*!< [28..28] rx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch12p0rokie : 1;           /*!< [29..29] rx page 0 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch12p1tokie : 1;           /*!< [30..30] tx page 1 ok interrupt enable. 0: disable 1: enable              */
      __IOM uint32_t ch12p0tokie : 1;           /*!< [31..31] tx page 0 ok interrupt enable. 0: disable 1: enable              */
    } paimr1215_b;
  } ;
  
  union {
    __IOM uint32_t paisr1215;                   /*!< (@ 0x000000D0) channel12-15 interrupt status register                     */
    
    struct {
      __IOM uint32_t ch15rxp1ua : 1;            /*!< [0..0] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15rxp0ua : 1;            /*!< [1..1] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15txp1ua : 1;            /*!< [2..2] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15txp0ua : 1;            /*!< [3..3] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15rxp1ip : 1;            /*!< [4..4] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15rxp0ip : 1;            /*!< [5..5] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15txp1ip : 1;            /*!< [6..6] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch15txp0ip : 1;            /*!< [7..7] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch14rxp1ua : 1;            /*!< [8..8] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch14rxp0ua : 1;            /*!< [9..9] interrupt pending flag write 1 to clear the interrupt.             */
      __IOM uint32_t ch14txp1ua : 1;            /*!< [10..10] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch14txp0ua : 1;            /*!< [11..11] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch14rxp1ip : 1;            /*!< [12..12] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch14rxp0ip : 1;            /*!< [13..13] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch14txp1ip : 1;            /*!< [14..14] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch14txp0ip : 1;            /*!< [15..15] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13rxp1ua : 1;            /*!< [16..16] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13rxp0ua : 1;            /*!< [17..17] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13txp1ua : 1;            /*!< [18..18] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13txp0ua : 1;            /*!< [19..19] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13rxp1ip : 1;            /*!< [20..20] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13rxp0ip : 1;            /*!< [21..21] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13txp1ip : 1;            /*!< [22..22] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch13txp0ip : 1;            /*!< [23..23] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12rxp1ua : 1;            /*!< [24..24] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12rxp0ua : 1;            /*!< [25..25] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12txp1ua : 1;            /*!< [26..26] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12txp0ua : 1;            /*!< [27..27] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12rxp1p  : 1;            /*!< [28..28] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12rxp0ip : 1;            /*!< [29..29] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12txp1ip : 1;            /*!< [30..30] interrupt pending flag write 1 to clear the interrupt.           */
      __IOM uint32_t ch12txp0ip : 1;            /*!< [31..31] interrupt pending flag write 1 to clear the interrupt.           */
    } paisr1215_b;
  } ;
  
  union {
    __IOM uint32_t paintmap;                    /*!< (@ 0x000000D4) intmap                                                     */
    
    struct {
      __IOM uint32_t intmap     : 32;           /*!< [31..0] Not support                                                       */
    } paintmap_b;
  } ;
  
  union {
    __IOM uint32_t pawtsr03;                    /*!< (@ 0x000000D8) channel0-3 wideband time slot assignment register          */
    
    struct {
      __IOM uint32_t ch3wtsa    : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch2wtsa    : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch1wtsa    : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch0wtsa    : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } pawtsr03_b;
  } ;
  
  union {
    __IOM uint32_t pawtsr47;                    /*!< (@ 0x000000DC) channel4-7 wideband time slot assignment register          */
    
    struct {
      __IOM uint32_t ch7tsa     : 5;            /*!< [4..0] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch6tsa     : 5;            /*!< [12..8] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch5tsa     : 5;            /*!< [20..16] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
      __IM  uint32_t            : 3;
      __IOM uint32_t ch4tsa     : 5;            /*!< [28..24] pcm interface a time slot assignment for rx/tx fifo.
                                                     Slot0 - slot31 if configured as 16 bit linear mode, only
                                                     even number time slot is allowed                                          */
    } pawtsr47_b;
  } ;
  
  union {
    __IOM uint32_t bufowchk;                    /*!< (@ 0x000000E0) pcm rx buffer data overwrite indicate                      */
    
    struct {
      __IOM uint32_t ch0overw   : 1;            /*!< [0..0] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch1overw   : 1;            /*!< [1..1] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch2overw   : 1;            /*!< [2..2] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch3overw   : 1;            /*!< [3..3] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch4overw   : 1;            /*!< [4..4] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch5overw   : 1;            /*!< [5..5] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch6overw   : 1;            /*!< [6..6] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch7overw   : 1;            /*!< [7..7] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch8overw   : 1;            /*!< [8..8] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch9overw   : 1;            /*!< [9..9] rx buffer data overwrite indicate. write 1 to clear the
                                                     status.                                                                   */
      __IOM uint32_t ch10overw  : 1;            /*!< [10..10] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
      __IOM uint32_t ch11overw  : 1;            /*!< [11..11] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
      __IOM uint32_t ch12overw  : 1;            /*!< [12..12] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
      __IOM uint32_t ch13overw  : 1;            /*!< [13..13] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
      __IOM uint32_t ch14overw  : 1;            /*!< [14..14] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
      __IOM uint32_t ch15overw  : 1;            /*!< [15..15] rx buffer data overwrite indicate. write 1 to clear
                                                     the status.                                                               */
    } bufowchk_b;
  } ;
} PCM0_Type;                                    /*!< Size = 228 (0xe4)                                                         */



/* =========================================================================================================================== */
/* ================                                           CRYP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Crypto Engine (CRYP)
  */

typedef struct {                                /*!< (@ 0x40070000) CRYP Structure                                             */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} CRYP_Type;                                    /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           WLAN                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Wireless LAN (WLAN)
  */

typedef struct {                                /*!< (@ 0x40080000) WLAN Structure                                             */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} WLAN_Type;                                    /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                            USB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG (USB)
  */

typedef struct {                                /*!< (@ 0x400C0000) USB Structure                                              */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} USB_Type;                                     /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                            ISP                                            ================ */
/* =========================================================================================================================== */

#if 0
/**
  * @brief ISP (ISP)
  */

typedef struct {                                /*!< (@ 0x40300000) ISP Structure                                              */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} ISP_Type;                                     /*!< Size = 4 (0x4)                                                            */
#endif


/* =========================================================================================================================== */
/* ================                                            VOE                                            ================ */
/* =========================================================================================================================== */

#if 0
/**
  * @brief Video Offload Engine (VOE)
  */

typedef struct {                                /*!< (@ 0x40490000) VOE Structure                                              */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} VOE_Type;                                     /*!< Size = 4 (0x4)                                                            */
#endif



/* =========================================================================================================================== */
/* ================                                            TFT                                            ================ */
/* =========================================================================================================================== */

#if 0
/**
  * @brief TFT Display Controller (TFT)
  */

typedef struct {                                /*!< (@ 0x40494000) TFT Structure                                              */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} TFT_Type;                                     /*!< Size = 4 (0x4)                                                            */
#endif



/* =========================================================================================================================== */
/* ================                                          H264Enc                                          ================ */
/* =========================================================================================================================== */

#if 0
/**
  * @brief H.264 Encoder Engine (H264Enc)
  */

typedef struct {                                /*!< (@ 0x40500000) H264Enc Structure                                          */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} H264Enc_Type;                                 /*!< Size = 4 (0x4)                                                            */
#endif



/* =========================================================================================================================== */
/* ================                                          MJPGEnc                                          ================ */
/* =========================================================================================================================== */

#if 0
/**
  * @brief Motion JPEG Encoder Engine (MJPGEnc)
  */

typedef struct {                                /*!< (@ 0x40580000) MJPGEnc Structure                                          */
  
  union {
    __IM  uint32_t not_exposed_reg;             /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } not_exposed_reg_b;
  } ;
} MJPGEnc_Type;                                 /*!< Size = 4 (0x4)                                                            */
#endif



/* =========================================================================================================================== */
/* ================                                           ICC_H                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter CPU Communication on HP Platform - for HP and LP CPU can communicate each other (ICC_H)
  */

typedef struct {                                /*!< (@ 0x50002C10) ICC_H Structure                                            */
  
  union {
    __IM  uint32_t icch_hrlw0;                  /*!< (@ 0x00000000) HP Read LP Write Register 0                                */
    
    struct {
      __IM  uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } icch_hrlw0_b;
  } ;
  
  union {
    __IM  uint32_t icch_hrlw1;                  /*!< (@ 0x00000004) HP Read LP Write Register 1                                */
    
    struct {
      __IM  uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } icch_hrlw1_b;
  } ;
  
  union {
    __IM  uint32_t icch_hrlw2;                  /*!< (@ 0x00000008) HP Read LP Write Register 2                                */
    
    struct {
      __IM  uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } icch_hrlw2_b;
  } ;
  
  union {
    __IM  uint32_t icch_hrlw3;                  /*!< (@ 0x0000000C) HP Read LP Write Register 3                                */
    
    struct {
      __IM  uint32_t hrlw       : 32;           /*!< [31..0] The information maintained by LP CPU. It could be message
                                                     queue information: write pointer Q_L2H or the read pointer
                                                     of Q_H2L.                                                                 */
    } icch_hrlw3_b;
  } ;
  
  union {
    __IM  uint32_t icch_lptg;                   /*!< (@ 0x00000010) LP Toggle Register                                         */
    
    struct {
      __IM  uint32_t lptg0      : 1;            /*!< [0..0] It's a 1 bit sequence number for HRLW0 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IM  uint32_t lptg1      : 1;            /*!< [1..1] It's a 1 bit sequence number for HRLW1 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IM  uint32_t lptg2      : 1;            /*!< [2..2] It's a 1 bit sequence number for HRLW2 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IM  uint32_t lptg3      : 1;            /*!< [3..3] It's a 1 bit sequence number for HRLW3 register updating.
                                                     Toggle this bit will assert the corresponding interrupt
                                                     on the HP CPU.                                                            */
      __IM  uint32_t            : 12;
      __IM  uint32_t l2htg0     : 1;            /*!< [16..16] The toggle bit for HLRW0 register updating.                      */
      __IM  uint32_t l2htg1     : 1;            /*!< [17..17] The toggle bit for HLRW1 register updating.                      */
      __IM  uint32_t l2htg2     : 1;            /*!< [18..18] The toggle bit for HLRW2 register updating.                      */
      __IM  uint32_t l2htg3     : 1;            /*!< [19..19] The toggle bit for HLRW3 register updating.                      */
      __IM  uint32_t l2htgs     : 1;            /*!< [20..20] The toggle bit for REG_SEMA register updating.                   */
    } icch_lptg_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t icch_sema;                   /*!< (@ 0x00000018) HW Semaphore Register                                      */
    
    struct {
      __IM  uint32_t sema0_ls_own : 1;          /*!< [0..0] The "Owned by LP" bit of the HW semaphore0.1: the HW
                                                     semaphore0 is owned by LS platform.                                       */
      __IOM uint32_t sema0_hs_own : 1;          /*!< [1..1] The "Owned by HP" bit of the HW semaphore0.1: the HW
                                                     semaphore0 is owned by HP platform.                                       */
      __IM  uint32_t sema1_ls_own : 1;          /*!< [2..2] The "Owned by LP" bit of the HW semaphore1.1: the HW
                                                     semaphore1 is owned by LS platform.                                       */
      __IOM uint32_t sema1_hs_own : 1;          /*!< [3..3] The "Owned by HP" bit of the HW semaphore1.1: the HW
                                                     semaphore1 is owned by HP platform.                                       */
      __IM  uint32_t sema2_ls_own : 1;          /*!< [4..4] The "Owned by LP" bit of the HW semaphore2.1: the HW
                                                     semaphore2 is owned by LS platform.                                       */
      __IOM uint32_t sema2_hs_own : 1;          /*!< [5..5] The "Owned by HP" bit of the HW semaphore2.1: the HW
                                                     semaphore2 is owned by HP platform.                                       */
      __IM  uint32_t sema3_ls_own : 1;          /*!< [6..6] The "Owned by LP" bit of the HW semaphore3.1: the HW
                                                     semaphore3 is owned by LS platform.                                       */
      __IOM uint32_t sema3_hs_own : 1;          /*!< [7..7] The "Owned by HP" bit of the HW semaphore3.1: the HW
                                                     semaphore3 is owned by HP platform.                                       */
      __IM  uint32_t sema4_ls_own : 1;          /*!< [8..8] The "Owned by LP" bit of the HW semaphore4.1: the HW
                                                     semaphore4 is owned by LS platform.                                       */
      __IOM uint32_t sema4_hs_own : 1;          /*!< [9..9] The "Owned by HP" bit of the HW semaphore4.1: the HW
                                                     semaphore4 is owned by HP platform.                                       */
      __IM  uint32_t sema5_ls_own : 1;          /*!< [10..10] The "Owned by LP" bit of the HW semaphore5.1: the HW
                                                     semaphore5 is owned by LS platform.                                       */
      __IOM uint32_t sema5_hs_own : 1;          /*!< [11..11] The "Owned by HP" bit of the HW semaphore5.1: the HW
                                                     semaphore5 is owned by HP platform.                                       */
      __IM  uint32_t sema6_ls_own : 1;          /*!< [12..12] The "Owned by LP" bit of the HW semaphore6.1: the HW
                                                     semaphore6 is owned by LS platform.                                       */
      __IOM uint32_t sema6_hs_own : 1;          /*!< [13..13] The "Owned by HP" bit of the HW semaphore6.1: the HW
                                                     semaphore6 is owned by HP platform.                                       */
      __IM  uint32_t sema7_ls_own : 1;          /*!< [14..14] The "Owned by LP" bit of the HW semaphore7.1: the HW
                                                     semaphore7 is owned by LS platform.                                       */
      __IOM uint32_t sema7_hs_own : 1;          /*!< [15..15] The "Owned by HP" bit of the HW semaphore7.1: the HW
                                                     semaphore7 is owned by HP platform.                                       */
      __IM  uint32_t sema8_ls_own : 1;          /*!< [16..16] The "Owned by LP" bit of the HW semaphore8.1: the HW
                                                     semaphore8 is owned by LS platform.                                       */
      __IOM uint32_t sema8_hs_own : 1;          /*!< [17..17] The "Owned by HP" bit of the HW semaphore8.1: the HW
                                                     semaphore8 is owned by HP platform.                                       */
      __IM  uint32_t sema9_ls_own : 1;          /*!< [18..18] The "Owned by LP" bit of the HW semaphore9.1: the HW
                                                     semaphore9 is owned by LS platform.                                       */
      __IOM uint32_t sema9_hs_own : 1;          /*!< [19..19] The "Owned by HP" bit of the HW semaphore9.1: the HW
                                                     semaphore9 is owned by HP platform.                                       */
      __IM  uint32_t sema10_ls_own : 1;         /*!< [20..20] The "Owned by LP" bit of the HW semaphore10.1: the
                                                     HW semaphore10 is owned by LS platform.                                   */
      __IOM uint32_t sema10_hs_own : 1;         /*!< [21..21] The "Owned by HP" bit of the HW semaphore10.1: the
                                                     HW semaphore10 is owned by HP platform.                                   */
      __IM  uint32_t sema11_ls_own : 1;         /*!< [22..22] The "Owned by LP" bit of the HW semaphore11.1: the
                                                     HW semaphore11 is owned by LS platform.                                   */
      __IOM uint32_t sema11_hs_own : 1;         /*!< [23..23] The "Owned by HP" bit of the HW semaphore11.1: the
                                                     HW semaphore11 is owned by HP platform.                                   */
      __IM  uint32_t sema12_ls_own : 1;         /*!< [24..24] The "Owned by LP" bit of the HW semaphore12.1: the
                                                     HW semaphore12 is owned by LS platform.                                   */
      __IOM uint32_t sema12_hs_own : 1;         /*!< [25..25] The "Owned by HP" bit of the HW semaphore13.1: the
                                                     HW semaphore13 is owned by HP platform.                                   */
      __IM  uint32_t sema13_ls_own : 1;         /*!< [26..26] The "Owned by LP" bit of the HW semaphore13.1: the
                                                     HW semaphore13 is owned by LS platform.                                   */
      __IOM uint32_t sema13_hs_own : 1;         /*!< [27..27] The "Owned by HP" bit of the HW semaphore15.1: the
                                                     HW semaphore16 is owned by HP platform.                                   */
      __IM  uint32_t sema14_ls_own : 1;         /*!< [28..28] The "Owned by LP" bit of the HW semaphore14.1: the
                                                     HW semaphore14 is owned by LS platform.                                   */
      __IOM uint32_t sema14_hs_own : 1;         /*!< [29..29] The "Owned by HP" bit of the HW semaphore14.1: the
                                                     HW semaphore14 is owned by HP platform.                                   */
      __IM  uint32_t sema15_ls_own : 1;         /*!< [30..30] The "Owned by LP" bit of the HW semaphore15.1: the
                                                     HW semaphore15 is owned by LS platform.                                   */
      __IOM uint32_t sema15_hs_own : 1;         /*!< [31..31] The "Owned by HP" bit of the HW semaphore15.1: the
                                                     HW semaphore15 is owned by HP platform.                                   */
    } icch_sema_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t icch_hlrw0;                  /*!< (@ 0x00000020) HP and LP Read/Write Register 0                            */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores. Since both CPU
                                                     can write these registers, the writing side should read
                                                     the register back to check is the writing successful.                     */
    } icch_hlrw0_b;
  } ;
  
  union {
    __IOM uint32_t icch_hlrw1;                  /*!< (@ 0x00000024) HP Read LP Write Register 5                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } icch_hlrw1_b;
  } ;
  
  union {
    __IOM uint32_t icch_hlrw2;                  /*!< (@ 0x00000028) HP Read LP Write Register 6                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } icch_hlrw2_b;
  } ;
  
  union {
    __IOM uint32_t icch_hlrw3;                  /*!< (@ 0x0000002C) HP Read LP Write Register 7                                */
    
    struct {
      __IOM uint32_t hlrw       : 32;           /*!< [31..0] The information could be writen by LP CPU or HP_CPU.
                                                     It could be used as hardware semaphores.                                  */
    } icch_hlrw3_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr0;                  /*!< (@ 0x00000030) HP Write LP Read Register 0                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr0_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr1;                  /*!< (@ 0x00000034) HP Write LP Read Register 1                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr1_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr2;                  /*!< (@ 0x00000038) HP Write LP Read Register 2                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr2_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr3;                  /*!< (@ 0x0000003C) HP Write LP Read Register 3                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr3_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr4;                  /*!< (@ 0x00000040) HP Write LP Read Register 4                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr4_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr5;                  /*!< (@ 0x00000044) HP Write LP Read Register 5                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr5_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr6;                  /*!< (@ 0x00000048) HP Write LP Read Register 6                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr6_b;
  } ;
  
  union {
    __IOM uint32_t icch_hwlr7;                  /*!< (@ 0x0000004C) HP Write LP Read Register 7                                */
    
    struct {
      __IOM uint32_t hwlr       : 32;           /*!< [31..0] The information maintained by HP CPU. It could be message
                                                     queue information: start address, queue size, write pointer
                                                     Q_H2L or the read pointer of Q_L2H.                                       */
    } icch_hwlr7_b;
  } ;
  
  union {
    __IOM uint32_t icch_hptg;                   /*!< (@ 0x00000050) HP Toggle Register                                         */
    
    struct {
      __IOM uint32_t hptg0      : 1;            /*!< [0..0] It's a 1 bit sequence number for HWLR0 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg1      : 1;            /*!< [1..1] It's a 1 bit sequence number for HWLR1 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg2      : 1;            /*!< [2..2] It's a 1 bit sequence number for HWLR2 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg3      : 1;            /*!< [3..3] It's a 1 bit sequence number for HWLR3 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg4      : 1;            /*!< [4..4] It's a 1 bit sequence number for HWLR4 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg5      : 1;            /*!< [5..5] It's a 1 bit sequence number for HWLR5 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg6      : 1;            /*!< [6..6] It's a 1 bit sequence number for HWLR6 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t hptg7      : 1;            /*!< [7..7] It's a 1 bit sequence number for HWLR7 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IM  uint32_t            : 8;
      __IOM uint32_t h2ltg0     : 1;            /*!< [16..16] It's a 1 bit sequence number for HLRW0 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t h2ltg1     : 1;            /*!< [17..17] It's a 1 bit sequence number for HLRW1 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t h2ltg2     : 1;            /*!< [18..18] It's a 1 bit sequence number for HLRW2 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t h2ltg3     : 1;            /*!< [19..19] It's a 1 bit sequence number for HLRW3 register updating.
                                                     Toggle this bit (0 to 1 or 1 to 0) will assert the corresponding
                                                     interrupt on the LP CPU.                                                  */
      __IOM uint32_t h2ltgs     : 1;            /*!< [20..20] This bit is used to control the enable of the interrupt
                                                     triggered by the H2LTGS toggles. 0/1: Disable/Enable Interrupt            */
    } icch_hptg_b;
  } ;
  
  union {
    __IOM uint32_t icch_lptgie;                 /*!< (@ 0x00000054) LP Toggle Interrupt Enable Register                        */
    
    struct {
      __IOM uint32_t lptgie0    : 1;            /*!< [0..0] This bit is used to control the enable of the interrupt
                                                     triggered by the LPTG0 toggles.                                           */
      __IOM uint32_t lptgie1    : 1;            /*!< [1..1] This bit is used to control the enable of the interrupt
                                                     triggered by the LPTG1 toggles.                                           */
      __IOM uint32_t lptgie2    : 1;            /*!< [2..2] This bit is used to control the enable of the interrupt
                                                     triggered by the LPTG2 toggles.                                           */
      __IOM uint32_t lptgie3    : 1;            /*!< [3..3] This bit is used to control the enable of the interrupt
                                                     triggered by the LPTG3 toggles.                                           */
      __IM  uint32_t            : 12;
      __IOM uint32_t l2htgie0   : 1;            /*!< [16..16] This bit is used to control the enable of the interrupt
                                                     triggered by the L2HTG0 toggles.                                          */
      __IOM uint32_t l2htgie1   : 1;            /*!< [17..17] This bit is used to control the enable of the interrupt
                                                     triggered by the L2HTG1 toggles.                                          */
      __IOM uint32_t l2htgie2   : 1;            /*!< [18..18] This bit is used to control the enable of the interrupt
                                                     triggered by the L2HTG2 toggles.                                          */
      __IOM uint32_t l2htgie3   : 1;            /*!< [19..19] This bit is used to control the enable of the interrupt
                                                     triggered by the L2HTG3 toggles.                                          */
      __IOM uint32_t l2htgies   : 1;            /*!< [20..20] This bit is used to control the enable of the interrupt
                                                     triggered by the L2HTGS toggles.                                          */
    } icch_lptgie_b;
  } ;
  
  union {
    __IOM uint32_t icch_lptgis;                 /*!< (@ 0x00000058) LP Toggle Interrupt Status Register                        */
    
    struct {
      __IOM uint32_t lptgis0    : 1;            /*!< [0..0] This bit is used to show the interrupt status which is
                                                     triggered by the LPTG0 toggles. This usually means the
                                                     LP CPU has updated the register HRLW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t lptgis1    : 1;            /*!< [1..1] This bit is used to show the interrupt status which is
                                                     triggered by the LPTG1 toggles. This usually means the
                                                     LP CPU has updated the register HRLW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t lptgis2    : 1;            /*!< [2..2] This bit is used to show the interrupt status which is
                                                     triggered by the LPTG2 toggles. This usually means the
                                                     LP CPU has updated the register HRLW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t lptgis3    : 1;            /*!< [3..3] This bit is used to show the interrupt status which is
                                                     triggered by the LPTG3 toggles. This usually means the
                                                     LP CPU has updated the register HRLW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IM  uint32_t            : 12;
      __IOM uint32_t l2htgis0   : 1;            /*!< [16..16] This bit is used to show the interrupt status which
                                                     is triggered by the L2HTG0 toggles. This usually means
                                                     the LP CPU has updated the register HLRW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t l2htgis1   : 1;            /*!< [17..17] This bit is used to show the interrupt status which
                                                     is triggered by the L2HTG1 toggles. This usually means
                                                     the LP CPU has updated the register HLRW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t l2htgis2   : 1;            /*!< [18..18] This bit is used to show the interrupt status which
                                                     is triggered by the L2HTG2 toggles. This usually means
                                                     the LP CPU has updated the register HLRW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t l2htgis3   : 1;            /*!< [19..19] This bit is used to show the interrupt status which
                                                     is triggered by the L2HTG3 toggles. This usually means
                                                     the LP CPU has updated the register HLRW3. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
      __IOM uint32_t l2htgiss   : 1;            /*!< [20..20] This bit is used to show the interrupt status which
                                                     is triggered by the L2HTGS toggles. This usually means
                                                     the LP CPU has updated the register REG_SEMA. 0: No interrupt;
                                                     1: Interrupt is pending. Write 1 to clear.                                */
    } icch_lptgis_b;
  } ;
} ICC_H_Type;                                   /*!< Size = 92 (0x5c)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define _SYSON_BASE                 0x40000000UL
#define GPIO_BASE                   0x40001000UL
#define TG0_BASE                    0x40002000UL
#define TM0_BASE                    0x40002040UL
#define TM1_BASE                    0x40002080UL
#define TM2_BASE                    0x400020C0UL
#define TM3_BASE                    0x40002100UL
#define TM4_BASE                    0x40002140UL
#define TM5_BASE                    0x40002180UL
#define TM6_BASE                    0x400021C0UL
#define TM7_BASE                    0x40002200UL
#define TG1_BASE                    0x40002400UL
#define TM8_BASE                    0x40002440UL
#define TM9_BASE                    0x40002480UL
#define TM10_BASE                   0x400024C0UL
#define TM11_BASE                   0x40002500UL
#define TM12_BASE                   0x40002540UL
#define TM13_BASE                   0x40002580UL
#define TM14_BASE                   0x400025C0UL
#define TM15_BASE                   0x40002600UL
#define PWM_COMM_BASE               0x40003000UL
#define PWM0_BASE                   0x40003020UL
#define PWM1_BASE                   0x40003040UL
#define PWM2_BASE                   0x40003060UL
#define PWM3_BASE                   0x40003080UL
#define PWM4_BASE                   0x400030A0UL
#define PWM5_BASE                   0x400030C0UL
#define PWM6_BASE                   0x400030E0UL
#define PWM7_BASE                   0x40003100UL
#define SPIC_BASE                   0x40006000UL
#define ADC_BASE                    0x40010000UL
#define UART0_BASE                  0x40040000UL
#define UART1_BASE                  0x40040400UL
#define UART2_BASE                  0x40040800UL
#define SSI0_BASE                   0x40042000UL
#define SSI1_BASE                   0x40074000UL
#define SSI2_BASE                   0x40042800UL
#define SSI3_BASE                   0x40042C00UL
#define I2C0_BASE                   0x40044000UL
#define I2C2_BASE                   0x40003400UL
#define I2C3_BASE                   0x40003800UL
#define SI_BASE                     0x40013000UL
#define SPORT0_BASE                 0x40013800UL
#define I3C_BASE                    0x40044800UL
#define SGPIO0_BASE                 0x40046000UL
#define SGPIO1_BASE                 0x40046100UL
#define SGPIO2_BASE                 0x40046200UL
#define SDIO_DEV_BASE               0x40050000UL
#define ETHERNET_BASE               0x40054000UL
#define SDIO_HOST_BASE              0x40058000UL
#define GDMA0_BASE                  0x400612C0UL
#define GDMA0_CH0_BASE              0x40061000UL
#define GDMA0_CH1_BASE              0x40061058UL
#define GDMA0_CH2_BASE              0x400610B0UL
#define GDMA0_CH3_BASE              0x40061108UL
#define GDMA0_CH4_BASE              0x40061160UL
#define GDMA0_CH5_BASE              0x400611B8UL
#define GDMA1_BASE                  0x400602C0UL
#define GDMA1_CH0_BASE              0x40060000UL
#define GDMA1_CH1_BASE              0x40060058UL
#define GDMA1_CH2_BASE              0x400600B0UL
#define GDMA1_CH3_BASE              0x40060108UL
#define GDMA1_CH4_BASE              0x40060160UL
#define GDMA1_CH5_BASE              0x400601B8UL
#define I2S0_BASE                   0x40062000UL
#define I2S1_BASE                   0x40063000UL
#define PCM0_BASE                   0x40064000UL
#define PCM1_BASE                   0x40065000UL
#define CRYP_BASE                   0x40070000UL
#define WLAN_BASE                   0x40080000UL
#define USB_BASE                    0x400C0000UL
#define ISP_BASE                    0x40300000UL
#define VOE_BASE                    0x40492000UL
#define TFT_BASE                    0x40494000UL
#define H264Enc_BASE                0x40500000UL
#define MJPGEnc_BASE                0x40580000UL
#define ICC_H_BASE                  0x50002C10UL
#define SGDMA0_BASE                 0x500612C0UL
#define SGDMA0_CH0_BASE             0x50061000UL
#define SGDMA0_CH1_BASE             0x50061058UL
#define SGDMA0_CH2_BASE             0x500610B0UL
#define SGDMA0_CH3_BASE             0x50061108UL
#define SGDMA0_CH4_BASE             0x50061160UL
#define SGDMA0_CH5_BASE             0x500611B8UL
#define SGDMA1_BASE                 0x500602C0UL
#define SGDMA1_CH0_BASE             0x50060000UL
#define SGDMA1_CH1_BASE             0x50060058UL
#define SGDMA1_CH2_BASE             0x500600B0UL
#define SGDMA1_CH3_BASE             0x50060108UL
#define SGDMA1_CH4_BASE             0x50060160UL
#define SGDMA1_CH5_BASE             0x500601B8UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define _SYSON                      ((_SYSON_Type*)            _SYSON_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define TG0                         ((TG0_Type*)               TG0_BASE)
#define TM0                         ((TM0_Type*)               TM0_BASE)
#define TM1                         ((TM0_Type*)               TM1_BASE)
#define TM2                         ((TM0_Type*)               TM2_BASE)
#define TM3                         ((TM0_Type*)               TM3_BASE)
#define TM4                         ((TM0_Type*)               TM4_BASE)
#define TM5                         ((TM0_Type*)               TM5_BASE)
#define TM6                         ((TM0_Type*)               TM6_BASE)
#define TM7                         ((TM0_Type*)               TM7_BASE)
#define TG1                         ((TG0_Type*)               TG1_BASE)
#define TM8                         ((TM0_Type*)               TM8_BASE)
#define TM9                         ((TM0_Type*)               TM9_BASE)
#define TM10                        ((TM0_Type*)               TM10_BASE)
#define TM11                        ((TM0_Type*)               TM11_BASE)
#define TM12                        ((TM0_Type*)               TM12_BASE)
#define TM13                        ((TM0_Type*)               TM13_BASE)
#define TM14                        ((TM0_Type*)               TM14_BASE)
#define TM15                        ((TM0_Type*)               TM15_BASE)
#define PWM_COMM                    ((PWM_COMM_Type*)          PWM_COMM_BASE)
#define PWM0                        ((PWM0_Type*)              PWM0_BASE)
#define PWM1                        ((PWM0_Type*)              PWM1_BASE)
#define PWM2                        ((PWM0_Type*)              PWM2_BASE)
#define PWM3                        ((PWM0_Type*)              PWM3_BASE)
#define PWM4                        ((PWM0_Type*)              PWM4_BASE)
#define PWM5                        ((PWM0_Type*)              PWM5_BASE)
#define PWM6                        ((PWM0_Type*)              PWM6_BASE)
#define PWM7                        ((PWM0_Type*)              PWM7_BASE)
#define SPIC                        ((SPIC_Type*)              SPIC_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define UART2                       ((UART0_Type*)             UART2_BASE)
#define SSI0                        ((SSI0_Type*)              SSI0_BASE)
#define SSI1                        ((SSI0_Type*)              SSI1_BASE)
#define SSI2                        ((SSI0_Type*)              SSI2_BASE)
#define SSI3                        ((SSI0_Type*)              SSI3_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define I2C2                        ((I2C2_Type*)              I2C2_BASE)
#define I2C3                        ((I2C3_Type*)              I2C3_BASE)
#define SI                          ((SI_Type*)                SI_BASE)
#define SPORT0                      ((SPORT0_Type*)            SPORT0_BASE)
#define I3C                         ((I3C_Type*)               I3C_BASE)
#define SGPIO0                      ((SGPIO0_Type*)            SGPIO0_BASE)
#define SGPIO1                      ((SGPIO0_Type*)            SGPIO1_BASE)
#define SGPIO2                      ((SGPIO0_Type*)            SGPIO2_BASE)
#define SDIO_DEV                    ((SDIO_DEV_Type*)          SDIO_DEV_BASE)
#define ETHERNET                    ((ETHERNET_Type*)          ETHERNET_BASE)
#define SDIO_HOST                   ((SDIO_HOST_Type*)         SDIO_HOST_BASE)
#define GDMA0                       ((GDMA0_Type*)             GDMA0_BASE)
#define GDMA0_CH0                   ((GDMA0_CH0_Type*)         GDMA0_CH0_BASE)
#define GDMA0_CH1                   ((GDMA0_CH0_Type*)         GDMA0_CH1_BASE)
#define GDMA0_CH2                   ((GDMA0_CH0_Type*)         GDMA0_CH2_BASE)
#define GDMA0_CH3                   ((GDMA0_CH0_Type*)         GDMA0_CH3_BASE)
#define GDMA0_CH4                   ((GDMA0_CH0_Type*)         GDMA0_CH4_BASE)
#define GDMA0_CH5                   ((GDMA0_CH0_Type*)         GDMA0_CH5_BASE)
#define GDMA1                       ((GDMA0_Type*)             GDMA1_BASE)
#define GDMA1_CH0                   ((GDMA0_CH0_Type*)         GDMA1_CH0_BASE)
#define GDMA1_CH1                   ((GDMA0_CH0_Type*)         GDMA1_CH1_BASE)
#define GDMA1_CH2                   ((GDMA0_CH0_Type*)         GDMA1_CH2_BASE)
#define GDMA1_CH3                   ((GDMA0_CH0_Type*)         GDMA1_CH3_BASE)
#define GDMA1_CH4                   ((GDMA0_CH0_Type*)         GDMA1_CH4_BASE)
#define GDMA1_CH5                   ((GDMA0_CH0_Type*)         GDMA1_CH5_BASE)
#define I2S0                        ((I2S0_Type*)              I2S0_BASE)
#define I2S1                        ((I2S0_Type*)              I2S1_BASE)
#define PCM0                        ((PCM0_Type*)              PCM0_BASE)
#define PCM1                        ((PCM0_Type*)              PCM1_BASE)
#define CRYP                        ((CRYP_Type*)              CRYP_BASE)
#define WLAN                        ((WLAN_Type*)              WLAN_BASE)
#define USB                         ((USB_Type*)               USB_BASE)
//#define ISP                         ((ISP_Type*)               ISP_BASE)
//#define VOE                         ((VOE_Type*)               VOE_BASE)
//#define TFT                         ((TFT_Type*)               TFT_BASE)
//#define H264Enc                     ((H264Enc_Type*)           H264Enc_BASE)
//#define MJPGEnc                     ((MJPGEnc_Type*)           MJPGEnc_BASE)
#define ICC_H                       ((ICC_H_Type*)             ICC_H_BASE)
#define SGDMA0                      ((GDMA0_Type*)             SGDMA0_BASE)
#define SGDMA0_CH0                  ((GDMA0_CH0_Type*)         SGDMA0_CH0_BASE)
#define SGDMA0_CH1                  ((GDMA0_CH0_Type*)         SGDMA0_CH1_BASE)
#define SGDMA0_CH2                  ((GDMA0_CH0_Type*)         SGDMA0_CH2_BASE)
#define SGDMA0_CH3                  ((GDMA0_CH0_Type*)         SGDMA0_CH3_BASE)
#define SGDMA0_CH4                  ((GDMA0_CH0_Type*)         SGDMA0_CH4_BASE)
#define SGDMA0_CH5                  ((GDMA0_CH0_Type*)         SGDMA0_CH5_BASE)
#define SGDMA1                      ((GDMA0_Type*)             SGDMA1_BASE)
#define SGDMA1_CH0                  ((GDMA0_CH0_Type*)         SGDMA1_CH0_BASE)
#define SGDMA1_CH1                  ((GDMA0_CH0_Type*)         SGDMA1_CH1_BASE)
#define SGDMA1_CH2                  ((GDMA0_CH0_Type*)         SGDMA1_CH2_BASE)
#define SGDMA1_CH3                  ((GDMA0_CH0_Type*)         SGDMA1_CH3_BASE)
#define SGDMA1_CH4                  ((GDMA0_CH0_Type*)         SGDMA1_CH4_BASE)
#define SGDMA1_CH5                  ((GDMA0_CH0_Type*)         SGDMA1_CH5_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* RTL8195BHP_H */


/** @} */ /* End of group rtl8195bhp */

/** @} */ /* End of group Realtek Semiconductor Corp. */


